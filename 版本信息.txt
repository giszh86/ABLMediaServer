ABLMediaServer-2022-11-30【 彻底解码CUDA硬解码H264出多帧同时返回造成编码丢失，引发H264转码视频花屏  】 
1、修正H265、H264执行转码的条件判断 ，如果是H265、需要加上条件 strcmp(szVideoCodec, "H265") == 0)，如果是H264 需要加上条件 strcmp(szVideoCodec, "H264") == 0)
	if (nConvertObjectCount < ABL_MediaServerPort.convertMaxObject && ((m_h265ConvertH264Struct.H265ConvertH264_enable == 1 && strcmp(szVideoCodec, "H265") == 0) || (m_h265ConvertH264Struct.H264DecodeEncode_enable == 1 && strcmp(szVideoCodec, "H264") == 0) ))
	{//执行转码
 		if (!H265ConvertH264(szVideo, nLength, szVideoCodec))
			return false;
		if (H265ConvertH264_enable == true && (m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0) && !(m_mediaCodecInfo.nWidth == m_h265ConvertH264Struct.convertOutWidth && m_mediaCodecInfo.nHeight == m_h265ConvertH264Struct.convertOutHeight))
		{//更改宽，高 
			m_mediaCodecInfo.nWidth = m_h265ConvertH264Struct.convertOutWidth;
			m_mediaCodecInfo.nHeight = m_h265ConvertH264Struct.convertOutHeight;
		}
	}

2、Linux下面分辨率低于 1280 x 720 不转码 ，否则硬件转码崩溃 
	if (nCudaDecodeChan == 0 && cudaCodec_Init != NULL )
	{
		if (CheckVideoIsIFrame(szVideoCodec, szVideo, nLength))
		{
			if (GetVideoWidthHeight(szVideoCodec, szVideo, nLength))
			{
				if(m_mediaCodecInfo.nWidth >= 1280)
				{
				  if (strcmp(szVideoCodec, "H264") == 0)
					cudaCodec_CreateVideoDecode(cudaCodecVideo_H264, cudaCodecVideo_NV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, nCudaDecodeChan);
				 else if (strcmp(szVideoCodec, "H265") == 0)
					cudaCodec_CreateVideoDecode(cudaCodecVideo_HEVC, cudaCodecVideo_NV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, nCudaDecodeChan);
				}
			}
		}
		
		if(m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nWidth < 1280 )
		{//Linux 平台硬件转码704 X 576 造成崩溃，所有这些分辨率都不转码，直接输出，否则造成崩溃
			H265ConvertH264_enable = true ;
			
			nCudaDecodeFrameCount = 1;
			nOutLength = nLength ;
			if (pOutEncodeBuffer == NULL)
			{
				nConvertObjectCount ++;
				pOutEncodeBuffer = new unsigned char[CudaDecodeH264EncodeH264FIFOBufferLength];
			}
			memcpy(pOutEncodeBuffer,szVideo,nLength);
			return true ;
		}
	}
  	
ABLMediaServer-2022-11-29【 彻底解码CUDA硬解码H264出多帧同时返回造成编码丢失，引发H264转码视频花屏  】 
1、消息通知断线重连事件恢复为3秒
	if (ABL_MediaServerPort.hook_enable == 1 && ( nCreateHttpClientTimer >= 30 || pMessageNoticeFifo.GetSize() > 0 ) )
	{//3秒检查一下
		nCreateHttpClientTimer = 0;
		CreateHttpClientFunc();
	}

2、	hls 开启切片条件增加 && m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0 
	if (enable_hls == 1 && nMediaSourceType == MediaSourceType_LiveMedia && m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0 )

ABLMediaServer-2022-11-28【 彻底解码CUDA硬解码H264出多帧同时返回造成编码丢失，引发H264转码视频花屏  】 
1、在媒体源更新视频帧速度，不再更新发送列表里面队列的帧速度，在PushVideo 函数里面分享视频帧时再更新视频帧速度 
	void   CMediaStreamSource::UpdateVideoFrameSpeed(int nVideoSpeed,int netType)
	{
		netBaseNetType = netType ;

		//异常的视频帧速度
		if (nVideoSpeed <= 0)
			return;

		m_mediaCodecInfo.nVideoFrameRate = nVideoSpeed;

		bUpdateVideoSpeed = true;
	}

    //分享视频帧时 更新视频帧速度  
	MediaSendMap::iterator it;
	uint64_t               nClient;
	for (it = mediaSendMap.begin(); it != mediaSendMap.end(); )
	{
		boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient((*it).second);
		if (pClient != NULL)
		{
			pClient->mediaCodecInfo.nVideoFrameRate = m_mediaCodecInfo.nVideoFrameRate;

2、创建硬解码需要检测 ，硬件资源是否为空 cudaEncode_Init != NULL
	if (nCudaDecodeChan == 0 && cudaEncode_Init != NULL )
	{
		if (CheckVideoIsIFrame(szVideoCodec, szVideo, nLength))
		{
			if (GetVideoWidthHeight(szVideoCodec, szVideo, nLength))
			{
				if (strcmp(szVideoCodec, "H264") == 0)
					cudaCreateVideoDecode(cudaCodecVideo_H264, cudaCodecVideo_YV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, nCudaDecodeChan);
				else if (strcmp(szVideoCodec, "H265") == 0)
					cudaCreateVideoDecode(cudaCodecVideo_HEVC, cudaCodecVideo_YV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, nCudaDecodeChan);
			}
		}
	}

3、Linux 平台销毁硬解码资源需要增加条件 ABL_bInitCudaSDKFlag == true 
	#else
		if(ABL_bInitCudaSDKFlag && pCudaDecodeHandle != NULL && pCudaEncodeHandle != NULL)
		{
		 cudaCodec_UnInit();
		 cudaEncode_UnInit();
		 
		 dlclose(pCudaDecodeHandle);
		 dlclose(pCudaEncodeHandle);
		}
	#endif

ABLMediaServer-2022-11-25【 彻底解码CUDA硬解码H264出多帧同时返回造成编码丢失，引发H264转码视频花屏  】 
1、水印字符串设置为1280个字节，否则用户修改多行字符时报错
	char filterVideoText[1280];
	
	//文本水印
	char szFilter[2048] = { 0 };
	sprintf(szFilter, "drawtext=fontfile=./simhei.ttf:fontsize=%d:fontcolor=%s:alpha=%.1f:x=%d:y=%d:text=", nFontSize,  FontColor, FontAlpha, FontLeft, FontTop);
	WriteLog(Log_Debug, "StartFilter  szFilter = %s  ", szFilter);

ABLMediaServer-2022-11-24【 彻底解码CUDA硬解码H264出多帧同时返回造成编码丢失，引发H264转码视频花屏  】 
1、CUDA硬解码H264会出现解码4帧的现象，所以在编码H264时,多帧需要拼接 
   nEncodeBufferLengthCount = nOutLength = 0;
   for (int i = 0; i < nCudaDecodeFrameCount; i++)
   {
	  avFrameSWS.AVFrameSWSYUV(pCudaDecodeYUVFrame[i], nCudeDecodeOutLength);				   

	  if(nCudaDecodeFrameCount == 1)//只有1帧
		videoEncode.EncodecYUV(avFrameSWS.szDestData, avFrameSWS.numBytes2, pOutEncodeBuffer, &nOutLength);
	  else
	  {//多帧 
		  videoEncode.EncodecYUV(avFrameSWS.szDestData, avFrameSWS.numBytes2, pOutEncodeBuffer + (nEncodeBufferLengthCount + sizeof(int)), &nOutLength);
		  if (nOutLength > 0)
		  {
			  memcpy(pOutEncodeBuffer + nEncodeBufferLengthCount, (unsigned char*)&nOutLength, sizeof(nOutLength));
			  nEncodeBufferLengthCount += nOutLength + sizeof(nOutLength);
		  }
	  }
   }

2、优化录像下载 8、16、255 倍速录像下载 ，调整下载速度 40M ~ 60M 之间 
		else//录像下载
		{
			nDownloadFrameCount++;
			if (nDownloadFrameCount % 10 == 0)
			{
			  if (abs(m_dScaleValue - 8.0) <= 0.01)
				 Sleep(50);
			  else if (abs(m_dScaleValue - 16.0) <= 0.01)
				 Sleep(40);
			}
		}
	}
	else if (abs(m_dScaleValue - 255.0) <= 0.01 )
	{//rtsp录像下载
		nDownloadFrameCount ++;
		if(nDownloadFrameCount % 10 == 0)
		   Sleep(35);
	}

3、代理拉流、国标接入增加 H264是否解码、降分辨率 
	char  H264DecodeEncode_enable[64];//H264是否解码再编码 	
	
   if (strlen(m_addStreamProxyStruct.H264DecodeEncode_enable) > 0)
	 pClient->m_h265ConvertH264Struct.H264DecodeEncode_enable = atoi(m_addStreamProxyStruct.H264DecodeEncode_enable);
	
4、当启动对该路进行转码时，还是尝试创建转码句柄、进行转码，不能立即设置视频编码格式
	if (!(nConvertObjectCount < ABL_MediaServerPort.convertMaxObject && m_h265ConvertH264Struct.H265ConvertH264_enable == 1))
	{
		if (strlen(m_mediaCodecInfo.szVideoName) == 0)
		  strcpy(m_mediaCodecInfo.szVideoName, szVideoCodec);
	}
		
5、Linux 硬件转码情况下 修正 水印 宽、高  m_h265ConvertH264Struct.convertOutWidth, m_h265ConvertH264Struct.convertOutHeight
 	bool  CMediaStreamSource::ChangeVideoFilter(char *filterText, int fontSize, char *fontColor, float fontAlpha, int fontLeft, int fontTop)
	{
		std::lock_guard<std::mutex> lock(mediaSendMapLock);
		
		if (pFFVideoFilter == NULL) 
		  return false ;

		SAFE_DELETE(pFFVideoFilter);
		pFFVideoFilter = new CFFVideoFilter();
		if(pFFVideoFilter)
		{
		  pFFVideoFilter->waterMarkText = filterText ;
		  pFFVideoFilter->StartFilter(AV_PIX_FMT_YUV420P, m_h265ConvertH264Struct.convertOutWidth, m_h265ConvertH264Struct.convertOutHeight, 25, fontSize, fontColor, fontAlpha, fontLeft,fontTop);
		  return true ;
		}
		else
			return false ;
	}

		
ABLMediaServer-2022-11-22【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、增加媒体转码参数结构 
	//真对单独某一路视频转码结构
	struct H265ConvertH264Struct
	{
		int  H265ConvertH264_enable;
		int  convertOutWidth;
		int	 convertOutHeight;
		int  convertOutBitrate;

		H265ConvertH264Struct()
		{
		  H265ConvertH264_enable = 0;
		  convertOutWidth = 0;
		  convertOutHeight = 0;
		  convertOutBitrate = 512;
		}
	};

	增加代理拉流接入、国标接入的转码参数判断 
	 
	if (strlen(m_addStreamProxyStruct.convertOutWidth) > 0 && strlen(m_addStreamProxyStruct.convertOutHeight) > 0)
	{
		int nWidth  = atoi(m_addStreamProxyStruct.convertOutWidth);
		int nHeight = atoi(m_addStreamProxyStruct.convertOutHeight);
		if (!((nWidth == 1920 && nHeight == 1080) || (nWidth == 1280 && nHeight == 720) || (nWidth == 960 && nHeight == 640) || 
			(nWidth == 800 && nHeight == 480) || (nWidth == 720 && nHeight == 576) || (nWidth == 720 && nHeight == 480 ) || 
			(nWidth == 640 && nHeight == 480) || (nWidth == 352 && nHeight == 288) || (nWidth == 320 && nHeight == 240) ))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"convertOutWidth : %d ,convertOutHeight: %d error. reference value [ 1280 x 720 ,960 x 640 ,800 x 480 ,720 x 576 , 720 x 480 ,640 x 480 ,352 x 288 ]\"}", IndexApiCode_ParamError, nWidth,nHeight);
			ResponseSuccess(szResponseBody);
			return false;
		}
	}

2、创建媒体源增加一个转码参数
   CMediaStreamSource::CMediaStreamSource(char* szURL, uint64_t nClientTemp, MediaSourceType nSourceType, uint32_t nDuration, H265ConvertH264Struct  h265ConvertH264Struct)

3、如果连接失败，删除对象采用原来的加入到断裂链表即可。   
	void LIBNET_CALLMETHOD	onconnect(NETHANDLE clihandle,
		uint8_t result)
	{
		if (result == 0)
		{
	 
		 pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));

4、创建媒体源时，采用外部指定的转码参数进行转码		 
   CMediaStreamSource::CMediaStreamSource(char* szURL, uint64_t nClientTemp, MediaSourceType nSourceType, uint32_t nDuration, H265ConvertH264Struct  h265ConvertH264Struct)
   {
	 memcpy((char*)&m_h265ConvertH264Struct, (char*)&h265ConvertH264Struct, sizeof(H265ConvertH264Struct));

	 //如果外部指定转码的宽、高则该路视频执行转码
	if (m_h265ConvertH264Struct.convertOutWidth > 0 && m_h265ConvertH264Struct.convertOutHeight > 0)
	{
		m_h265ConvertH264Struct.H265ConvertH264_enable = 1;
	}
	else
	{//使用默认的宽、高
		if (ABL_MediaServerPort.H265ConvertH264_enable == 1)
		{
			m_h265ConvertH264Struct.convertOutWidth = ABL_MediaServerPort.convertOutWidth;
			m_h265ConvertH264Struct.convertOutHeight = ABL_MediaServerPort.convertOutHeight;
		}
	}

	//如果配置文件指定转码，则所有视频都进行转码
	if (ABL_MediaServerPort.H265ConvertH264_enable == 1)
		m_h265ConvertH264Struct.H265ConvertH264_enable = 1;

	if (m_h265ConvertH264Struct.H265ConvertH264_enable == 1 && m_h265ConvertH264Struct.convertOutWidth > 0 && m_h265ConvertH264Struct.convertOutHeight > 0)
	{//确定转码输出的码流大小
		if (m_h265ConvertH264Struct.convertOutWidth <= 352)
			m_h265ConvertH264Struct.convertOutBitrate = 512;
		else if (m_h265ConvertH264Struct.convertOutWidth > 352 && m_h265ConvertH264Struct.convertOutWidth <= 640)
			m_h265ConvertH264Struct.convertOutBitrate = 768;
		else if (m_h265ConvertH264Struct.convertOutWidth > 640 && m_h265ConvertH264Struct.convertOutWidth <= 960)
			m_h265ConvertH264Struct.convertOutBitrate = 1024;
		else if (m_h265ConvertH264Struct.convertOutWidth > 960 && m_h265ConvertH264Struct.convertOutWidth <= 1280)
			m_h265ConvertH264Struct.convertOutBitrate = 1220;
		else
			m_h265ConvertH264Struct.convertOutBitrate = 1560;
	}
	//由配置文件的H264视频解码，转码覆盖本路视频的转码参数
	m_h265ConvertH264Struct.H264DecodeEncode_enable = ABL_MediaServerPort.H264DecodeEncode_enable;

5、检测转码宽、高是否合法
 	if (strlen(m_addStreamProxyStruct.convertOutWidth) > 0 && strlen(m_addStreamProxyStruct.convertOutHeight) > 0)
	{
		int nWidth  = atoi(m_addStreamProxyStruct.convertOutWidth);
		int nHeight = atoi(m_addStreamProxyStruct.convertOutHeight);
		if (!((nWidth == 1920 && nHeight == 1080) || (nWidth == 1280 && nHeight == 720) || (nWidth == 960 && nHeight == 640) || 
			(nWidth == 800 && nHeight == 480) || (nWidth == 720 && nHeight == 576) || (nWidth == 720 && nHeight == 480 ) || 
			(nWidth == 640 && nHeight == 480) || (nWidth == 352 && nHeight == 288) || (nWidth == 320 && nHeight == 240) ))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"convertOutWidth : %d ,convertOutHeight: %d error. reference value [ 1280 x 720 ,960 x 640 ,800 x 480 ,720 x 576 , 720 x 480 ,640 x 480 ,352 x 288 ]\"}", IndexApiCode_ParamError, nWidth,nHeight);
			ResponseSuccess(szResponseBody);
			return false;
		}
	}

6、在rtsp代理拉流中，发送 paly 命令 采用完整 url 	
	void  CNetClientRecvRtsp::SendPlay(WWW_AuthenticateType wwwType)
	{//\r\nScale: 255

		//把 session 里面; 后面字符串去掉  
		string strSession = szSessionID;
		int    nPos2 = strSession.find(";", 0);
		if (nPos2 > 0)
		{
			szSessionID[nPos2] = 0x00;
			WriteLog(Log_Debug, "SendPlay() ，nClient = %llu ,strSessionID = %s , szSessionID = %s ", nClient, strSession.c_str(), szSessionID);
		}

		if (wwwType == WWW_Authenticate_None)
		{
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: ABL_RtspServer_3.0.1\r\nSession: %s\r\nRange: npt=0.000-\r\n\r\n", m_rtspStruct.szSrcRtspPullUrl, CSeq, szSessionID);
		}
		else if (wwwType == WWW_Authenticate_MD5)
		{
			Authenticator author;
			char*         szResponse;

			author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
			author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
			szResponse = (char*)author.computeDigestResponse("PLAY", m_rtspStruct.szSrcRtspPullUrl); //要注意 uri ,有时候没有最后的 斜杠 /

			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: ABL_RtspServer_3.0.1\r\nSession: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nRange: npt=0.000-\r\n\r\n", m_rtspStruct.szSrcRtspPullUrl, CSeq, szSessionID, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szSrcRtspPullUrl, szResponse);

			author.reclaimDigestResponse(szResponse);
		}
	
7、区别录像回放、录像下载，增加录像以8倍速下载
	//rtsp 播放类型
	enum ABLRtspPlayerType
	{
		RtspPlayerType_Unknow = -1 ,  //未知 
		RtspPlayerType_Liveing = 0 , //实时播放
		RtspPlayerType_RecordReplay = 1 ,//录像回放
		RtspPlayerType_RecordDownload = 2,//录像下载
	};

	if (pThis->m_rtspPlayerType == RtspPlayerType_RecordReplay)
	{//录像回放
	  if (pThis->CheckVideoIsIFrame(pThis->mediaCodecInfo.szVideoName, pThis->s_packet+4, pThis->nRetLength))
		  pThis->pMediaSource->PushVideo(pThis->s_packet, pThis->nRetLength+4, pThis->mediaCodecInfo.szVideoName);
	}else //录像下载
		pThis->pMediaSource->PushVideo(pThis->s_packet, pThis->nRetLength + 4, pThis->mediaCodecInfo.szVideoName);

	
ABLMediaServer-2022-11-16【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、媒体源类增加linux平台得修改水印字符函数
 	bool  CMediaStreamSource::ChangeVideoFilter(char *filterText, int fontSize, char *fontColor, float fontAlpha, int fontLeft, int fontTop)
	{
		std::lock_guard<std::mutex> lock(mediaSendMapLock);
		
		if (pFFVideoFilter == NULL) 
		  return false ;

		SAFE_DELETE(pFFVideoFilter);
		pFFVideoFilter = new CFFVideoFilter();
		if(pFFVideoFilter)
		{
		  pFFVideoFilter->waterMarkText = filterText ;
		  pFFVideoFilter->StartFilter(AV_PIX_FMT_YUV420P, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, 25, fontSize, fontColor, fontAlpha, fontLeft,fontTop);
		  return true ;
		}
		else
			return false ;
	}

2、Http请求修改水印字符时，需要判断不同的平台 
	if(ABL_MediaServerPort.H265DecodeCpuGpuType == 0)
	{//软转码
	  tmpMediaSource->videoEncode.ChangeVideoFilter(text, atoi(size), color, atof(alpha), atoi(left), atoi(top));
	}else  
	{//硬件转码 
#ifdef OS_System_Windows
	  tmpMediaSource->videoEncode.ChangeVideoFilter(text, atoi(size), color, atof(alpha), atoi(left), atoi(top));
#else
	  tmpMediaSource->ChangeVideoFilter(text, atoi(size), color, atof(alpha), atoi(left), atoi(top));
#endif			
	}


ABLMediaServer-2022-11-15【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、在周工的水印类CFFVideoFilter 增加拷贝YUV函数 
	bool CFFVideoFilter::CopyYUVData(unsigned char* pOutYUVData)
	{
		if(!bRunFlag || filterFrame == NULL )
			return false ;
		
		if(filterFrame->data[0] == NULL || filterFrame->data[1] == NULL || filterFrame->data[2] == NULL)
			return false ;
		
		  nYUVPos = 0;
		  nYPos = 0;
		  nUPos = 0;
		  nVPos = 0;
		  
		  for (i = 0; i<m_nHeight; i++)
		  {
			  memcpy(pOutYUVData + nYUVPos, filterFrame->data[0] + nYPos, m_nWidth);
			  nYPos += filterFrame->linesize[0];
			  nYUVPos += m_nWidth;
		  } 

		  // fill U data
		  for (i = 0; i<m_nHeight / 2; i++)
		  {
			  memcpy(pOutYUVData + nYUVPos, filterFrame->data[1] + nUPos, m_nWidth / 2);
			  nUPos += filterFrame->linesize[1];
			  nYUVPos += m_nWidth / 2;
		  }

		  // fill V data
		  for (i = 0; i<m_nHeight / 2; i++)
		  {
			  memcpy(pOutYUVData + nYUVPos, filterFrame->data[2] + nVPos, m_nWidth / 2);
			  nVPos += filterFrame->linesize[2];
			  nYUVPos += m_nWidth / 2;
		  }	
	}

2、增加Linux 平台由gb2312 转换为 utf-8 字符串 
	int GB2312ToUTF8(char* szSrc, size_t iSrcLen, char* szDst, size_t iDstLen)
	{
		  iconv_t cd = iconv_open("utf-8//IGNORE", "gb2312//IGNORE");
		  if(0 == cd)
			 return -2;
		  memset(szDst, 0, iDstLen);
		  char **src = &szSrc;
		  char **dst = &szDst;
		  if(-1 == (int)iconv(cd, src, &iSrcLen, dst, &iDstLen))
		  {
			 iconv_close(cd);
			 return -1;
		  }
		  iconv_close(cd);
		  return 0;
	}
	
3、增加Linux 平台硬解模式的的视频水印 	
	if(ABL_MediaServerPort.H265ConvertH264_enable == 1 && ABL_MediaServerPort.filterVideo_enable == 1)
	{
	  if(pFFVideoFilter == NULL)
	  {
		  pFFVideoFilter = new CFFVideoFilter();
		  if(pFFVideoFilter)
			pFFVideoFilter->StartFilter(AV_PIX_FMT_YUV420P, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, 25, ABL_MediaServerPort.nFilterFontSize, ABL_MediaServerPort.nFilterFontColor, ABL_MediaServerPort.nFilterFontAlpha, ABL_MediaServerPort.nFilterFontLeft, ABL_MediaServerPort.nFilterFontTop);
	  }
	  if(pFFVideoFilter)
	  {//打印水印
		  if(pFFVideoFilter->FilteringFrame(avFrameSWS.pFrameDest))
			pFFVideoFilter->CopyYUVData(avFrameSWS.szDestData);  
	  }
	}

ABLMediaServer-2022-11-14【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、Linux平台开启cuda硬解码，cuda硬编码
	#else
			if (nCudaDecodeChan == 0)
			{
				if (CheckVideoIsIFrame(szVideoCodec, szVideo, nLength))
				{
					if (GetVideoWidthHeight(szVideoCodec, szVideo, nLength))
					{
						if (strcmp(szVideoCodec, "H264") == 0)
							cudaCodec_CreateVideoDecode(cudaCodecVideo_H264, cudaCodecVideo_NV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, nCudaDecodeChan);
						else if (strcmp(szVideoCodec, "H265") == 0)
							cudaCodec_CreateVideoDecode(cudaCodecVideo_HEVC, cudaCodecVideo_NV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, nCudaDecodeChan);
					}
				}
			}
			 
			if (nCudaDecodeChan > 0)
			{
				pCudaDecodeYUVFrame = cudaCodec_CudaVideoDecode(nCudaDecodeChan, szVideo, nLength, nCudaDecodeFrameCount, nCudeDecodeOutLength);
				if (nCudeDecodeOutLength > 0)
				{
					if (!avFrameSWS.bInitFlag && ABL_MediaServerPort.convertOutWidth > 0 && ABL_MediaServerPort.convertOutHeight > 0 )
					{
						avFrameSWS.CreateAVFrameSws(true,(AVPixelFormat)AV_PIX_FMT_NV12, m_mediaCodecInfo.nWidth, m_mediaCodecInfo.nHeight, AV_PIX_FMT_YUV420P, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, SWS_BICUBIC);
					}

					if (avFrameSWS.bInitFlag)
					{
						if (nEncodeCudaChan == 0)
						{
							pOutEncodeBuffer = new unsigned char[((ABL_MediaServerPort.convertOutWidth * ABL_MediaServerPort.convertOutHeight) * 3) / 2];
							if (cudaEncode_CreateVideoEncode((cudaEncodeVideo_enum)cudaEncodeVideo_H264,(cudaEncodeVideo_enum)cudaEncodeVideo_YUV420, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, nEncodeCudaChan))
							{//libopenh264
								nConvertObjectCount++;
								H265ConvertH264_enable = true;
								WriteLog(Log_Debug, " CMediaStreamSource  = %X ,当前媒体流 /%s/%s 执行转码 ，共有 %d 路进行转码 ", this, app, stream, nConvertObjectCount);
							}
						}
					}

				   for (int i = 0; i < nCudaDecodeFrameCount; i++)
				   {
					  if(pOutEncodeBuffer != NULL)
					  {					  
					   avFrameSWS.AVFrameSWSYUV(pCudaDecodeYUVFrame, nCudeDecodeOutLength);
					   nOutLength = cudaEncode_CudaVideoEncode(nEncodeCudaChan,(unsigned char*)avFrameSWS.szDestData, avFrameSWS.numBytes2,(char*) pOutEncodeBuffer);
					   if(nOutLength > 0 )
					   {
	#ifdef WriteEncodeDataFlag 
						   if(writeEncodeFile)
						   {
							 fwrite(pOutEncodeBuffer,1,nOutLength,writeEncodeFile) ;
							 fflush(writeEncodeFile);
						   }
	#endif					   
						  return true ;
					   }else 
						  return false ;
					  }
					  //return videoEncode.EncodecYUV(avFrameSWS.szDestData, avFrameSWS.numBytes2, pOutEncodeBuffer, &nOutLength);
				   }
				}
			}	

2、程序退出后再执行销毁cuda资源
	 
	#ifdef OS_System_Windows
		if(ABL_bInitCudaSDKFlag)
		   cudaVideoDecodeUnInit();
	#else
		if(pCudaDecodeHandle != NULL && pCudaEncodeHandle != NULL)
		{
		 cudaCodec_UnInit();
		 cudaEncode_UnInit();
		 
		 dlclose(pCudaDecodeHandle);
		 dlclose(pCudaEncodeHandle);
		}
	#endif
	
3、window 平台 cuda 资源保证只 启动 1次，增加条件 && ABL_bInitCudaSDKFlag == false   	
	if (ABL_MediaServerPort.H265ConvertH264_enable == 1  && ABL_MediaServerPort.H265DecodeCpuGpuType == 1 && ABL_bInitCudaSDKFlag == false )
	{///英伟达

ABLMediaServer-2022-11-10【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、增加保存hls切片路径 
	else if (strcmp("wwwPath", szKey) == 0)
	{
 		if(strlen(szValue) == 0)
		  strcpy(ABL_wwwMediaPath,ABL_MediaSeverRunPath);
		else
		{
		  strcpy(ABL_MediaServerPort.wwwPath, szValue);
		}

#ifdef OS_System_Windows
		if (ABL_MediaServerPort.wwwPath[strlen(ABL_MediaServerPort.wwwPath) - 1] != '\\')
			strcat(ABL_MediaServerPort.wwwPath, "\\");
		sprintf(ABL_wwwMediaPath, "%swww", ABL_MediaServerPort.wwwPath);
		::CreateDirectory(ABL_wwwMediaPath, NULL);
#else
		if (ABL_MediaServerPort.wwwPath[strlen(ABL_MediaServerPort.wwwPath) - 1] != '/')
			strcat(ABL_MediaServerPort.wwwPath, "/");
		sprintf(ABL_wwwMediaPath, "%swww", ABL_MediaServerPort.wwwPath);
		umask(0);
		mkdir(ABL_wwwMediaPath, 777);
#endif
	}

ABLMediaServer-2022-11-09【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、增加国标收流，保存底层的rtp数据，为了详细分析，防止rtp解包失败时使用 
	int CNetGB28181RtpServer::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength, void* address)
	{
		if (!bRunFlag)
			return -1;
		std::lock_guard<std::mutex> lock(netDataLock);
	 
		//增加保存原始的rtp数据，进行底层分析
		if (ABL_MediaServerPort.nSaveGB28181Rtp == 1 && pWriteRtpFile != NULL && (GetTickCount64() - nCreateDateTime) < 1000 * 300)
		{
			fwrite(pData, 1, nDataLength, pWriteRtpFile);
			fflush(pWriteRtpFile);
		}
	
ABLMediaServer-2022-11-07【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、hls切片路径支持可以修改 
	//设置切片路径
	if (strlen(ABL_MediaServerPort.wwwPath) == 0)
		strcpy(ABL_MediaServerPort.wwwPath, ABL_MediaSeverRunPath);
	else
	{//用户设置的路径,防止用户没有创建好路径
		int nPos = 0;
		char szTempPath[512] = { 0 };
		string strPath = ABL_MediaServerPort.wwwPath;
		while (true)
		{
			nPos = strPath.find("\\", nPos + 3);
			if (nPos > 0)
			{
				memcpy(szTempPath, ABL_MediaServerPort.wwwPath, nPos);
				::CreateDirectory(szTempPath, NULL);
			}
			else
			{
				::CreateDirectory(ABL_MediaServerPort.wwwPath, NULL);
				break;
			}
		}
	}

2、服务器上线通知移动到 main 主函数处	
		//服务器上线通知 
		if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nServerStarted > 0 && (GetCurrentSecond() - ABL_MediaServerPort.nServerStartTime) > 6 && (GetCurrentSecond() - ABL_MediaServerPort.nServerStartTime) <= 15  && ABL_MediaServerPort.bNoticeStartEvent == false)
		{
			ABL_MediaServerPort.bNoticeStartEvent = true;
			MessageNoticeStruct msgNotice;
			msgNotice.nClient = ABL_MediaServerPort.nServerStarted;

#ifdef OS_System_Windows
			SYSTEMTIME st;
			GetLocalTime(&st);
			sprintf(msgNotice.szMsg, "{\"localipAddress\":\"%s\",\"mediaServerId\":\"%s\",\"datetime\":\"%04d-%02d-%02d %02d:%02d:%02d\"}", ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
#else
			time_t now;
			time(&now);
			struct tm *local;
			local = localtime(&now);
			sprintf(msgNotice.szMsg, "{{\"localipAddress\":\"%s\",\"mediaServerId\":\"%s\",\"datetime\":\"%04d-%02d-%02d %02d:%02d:%02d\"}", ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, local->tm_year + 1900, local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);
#endif
			pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
		}
		
3、查询录像时间段的时间不再限制多少秒之前 		
	//检测结束时间必须小于当前时间的
	/*if (GetCurrentSecondByTime(m_queryRecordListStruct.endtime) > (GetCurrentSecond() - ABL_MediaServerPort.fileSecond))
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"endtime must current time %llu second before \"}", IndexApiCode_secretError, ABL_MediaServerPort.fileSecond);
		ResponseSuccess(szResponseBody);
		return false;
	}*/
	
4、hls 切片保留文件个数可以配置 	
	while (tsFileNameFifo.GetSize() > ABL_MediaServerPort.nMaxTsFileCount)
	{
		memset(szOutputName, 0x00, sizeof(szOutputName));
		pData = tsFileNameFifo.pop(&nLength);
		if (pData != NULL)
		{
			memcpy(szOutputName, pData, nLength);
			ABLDeleteFile(szOutputName);

			tsFileNameFifo.pop_front();
		}
	}
	
5、linux平台的 ini.cpp 文件支持可以修改 key 的值 
	INI_RES CIni::WriteKeyString(char* szSection, char* szKey, char* szValue)
	{
		std::lock_guard<std::mutex> lock(writeFileMutex);
		if (nIniFileSize <= 0)
			return INI_OPENFILE_ERROR;

		string  strIniBuffer = pFileBuffer;
		nKeyPos = -1;
		nReturnPos = -1;

		sprintf(szFindKey, "%s=", szKey);
		nKeyPos = strIniBuffer.find(szFindKey, 0);
		if (nKeyPos < 0)
			return INI_NO_ATTR;
		nKeyPos += strlen(szFindKey);
		nReturnPos = strIniBuffer.find(szReturn, nKeyPos);
		if (nReturnPos < 0)
			return INI_NO_ATTR;

		//原来长度
		oldLenth = nReturnPos - nKeyPos;
		newLength = strlen(szValue);
		if (newLength == oldLenth)
		{//总长度不变
			memcpy(pFileBuffer + nKeyPos, szValue, newLength);
		}
		else if (newLength > oldLenth)
		{//总长度变长
			nAddLenth = newLength - oldLenth;
			nMoveLenth = nIniFileSize - nKeyPos;
			memmove(pFileBuffer + (nKeyPos + nAddLenth), pFileBuffer + nKeyPos, nMoveLenth);

			memcpy(pFileBuffer + nKeyPos, szValue, newLength);
			nIniFileSize += (newLength - oldLenth);
		}
		else if (newLength < oldLenth)
		{//总长度变短
			nAddLenth = oldLenth - newLength;
			nMoveLenth = nIniFileSize - nKeyPos - nAddLenth;
			memmove(pFileBuffer + nKeyPos , pFileBuffer + (nKeyPos + nAddLenth), nMoveLenth);

			if(newLength > 0)
			  memcpy(pFileBuffer + nKeyPos, szValue, newLength);
			nIniFileSize -= (oldLenth - newLength);
		}

		m_fpWrite = fopen(szIniFileName, "wb");
		if (m_fpWrite)
		{
			fwrite(pFileBuffer, 1, nIniFileSize, m_fpWrite);
			fflush(m_fpWrite);
			fclose(m_fpWrite);
			m_fpWrite = NULL;
			return INI_SUCCESS;
		}
		else
			return INI_ERROR;
	}

ABLMediaServer-2022-11-04【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、把抓拍图片质量设置为 1 
	pCodecCtx->qcompress = 1 ; //图片压缩质量 范围（ 0.1 ~ 1 ）

2、如果抓拍失败，释放一些句柄
	pCodec = avcodec_find_encoder(pCodecCtx->codec_id);
	if (!pCodec)
	{
		avformat_free_context(pFormatCtx);		
		WriteLog(Log_Debug, "CVideoDecode = %X avcodec_find_encoder() Failed line= %d,", this, __LINE__);
		return false;
	}

	if ((ret1 = avcodec_open2(pCodecCtx, pCodec, NULL)) < 0)
	{
		avcodec_free_context(&pCodecCtx);
		avformat_close_input(&pFormatCtx);		
		avformat_free_context(pFormatCtx);		
		WriteLog(Log_Debug, "CVideoDecode = %X avcodec_open2() Failed line= %d,", this, __LINE__);
		return false;
	}

3、修正判断I帧的函数 ，加快判断 	
	/*
	检测视频是否是I帧
	*/
	bool  CMediaStreamSource::CheckVideoIsIFrame(char* szVideoCodecName, unsigned char* szPVideoData, int nPVideoLength)
	{
		int nPos = 0;
		bool bVideoIsIFrameFlag = false;
		unsigned char  nFrameType = 0x00;

		for (int i = 0; i < nPVideoLength; i++)
		{
			if (memcmp(szPVideoData+i, szVideoFrameHead, 4) == 0)
			{//找到帧片段
				if (strcmp(szVideoCodecName, "H264") == 0)
				{
					nFrameType = (szPVideoData[i+4] & 0x1F);
					if (nFrameType == 7 || nFrameType == 8 || nFrameType == 5)
					{//SPS   PPS   IDR 
						bVideoIsIFrameFlag = true;
						break;
					}
				}
				else if (strcmp(szVideoCodecName, "H265") == 0)
				{
					nFrameType = (szPVideoData[i+4] & 0x7E) >> 1;
					if ((nFrameType >= 16 && nFrameType <= 21) || (nFrameType >= 32 && nFrameType <= 34))
					{//SPS   PPS   IDR 
						bVideoIsIFrameFlag = true;
						break;
					}
				}
			}
		
			//不需要全部检查完毕，就可以判断一帧类型
			if (i >= 256)
				return false;
		}
		return bVideoIsIFrameFlag;
	}
	
ABLMediaServer-2022-11-03【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、新增函数Hls切片资源分配函数，由于 hls_enable 变量可以动态改变，所有需要新增函数，当视频接入后再开启 hls_enable 
	void  CMediaStreamSource::InitHlsResoure()
	{
		if (ABL_MediaServerPort.nHlsEnable == 1 && nMediaSourceType == MediaSourceType_LiveMedia && !bInitHlsResoureFlag)
		{
			bInitHlsResoureFlag = true;
			//获取TS文件的二级补充路径
			string strURL = m_szURL;
			int    nPos = 0;
			nPos = strURL.rfind("/", strlen(m_szURL));
			if (nPos > 0)
			{
				memset(szTSFileSubPath, 0x00, sizeof(szTSFileSubPath));
				memcpy(szTSFileSubPath, m_szURL + nPos + 1, strlen(m_szURL) - nPos - 1);
			}

			//创建HLS目录
			memset(szM3u8Name, 0x00, sizeof(szM3u8Name));
			if (ABL_MediaServerPort.nHLSCutType == 1)
			{
				CreateSubPathByURL(m_szURL);
				sprintf(szM3u8Name, "%shls.m3u8", szHLSPath);
			}

			if (ABL_MediaServerPort.nHLSCutType == 2)
			{//切片到内存
				pTsFileCacheBuffer = new unsigned char[Default_TS_MediaFileByteCount];
				for (int i = 0; i < MaxStoreTsFileCount; i++)
					mediaFileBuffer[i].InitFifo(Default_TS_MediaFileByteCount);
			}
		}
	}

2、媒体源增加一个变量，记录是否开启hls ,这样可以精确到每一路是否开启hls 
    volatile  bool         enable_hls;
	CMediaStreamSource::CMediaStreamSource(char* szURL, uint64_t nClientTemp, MediaSourceType nSourceType, uint32_t nDuration)
	{
		memset((char*)&hevc, 0x00, sizeof(hevc));
		enable_hls = ABL_MediaServerPort.nHlsEnable;
	
	代理拉流 
	GetKeyValue("enable_hls", m_openRtpServerStruct.enable_hls);

	国标接入 
	strcpy(m_addStreamProxyStruct.enable_hls, m_openRtpServerStruct.enable_hls);//是否开启hls
	
3、可用媒体源里面增加 是否开启 enable_hls 字段值 	
	sprintf(szTemp2, "{\"key\":%llu,\"app\":\"%s\",\"stream\":\"%s\",\"status\":%s,\"enable_hls\":%s,\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"noneReaderDuration\":%llu,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"videoBitrate\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"audioBitrate\":%d,\"url\":{\"rtsp\":\"rtsp://%s:%d/%s/%s\",\"rtmp\":\"rtmp://%s:%d/%s/%s\",\"http-flv\":\"http://%s:%d/%s/%s.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s.flv\",\"http-mp4\":\"http://%s:%d/%s/%s.mp4\",\"http-hls\":\"http://%s:%d/%s/%s.m3u8\"}},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, tmpMediaSource->enable_mp4 == true ? "true" : "false",tmpMediaSource->enable_hls == true ? "true" : "false", pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(), nNoneReadDuration,
	
4、图片抓拍的质量参数为 qcompress ，范围 0.1 ~ 1 
	pCodecCtx->qcompress = 0.8 ; //图片压缩质量 范围（ 0.1 ~ 1 ）


ABLMediaServer-2022-11-02【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、在录像类析构时，需要通知已经切片完成的MP4文件 
	bool CStreamRecordMP4::CloseMp4File()
	{
		std::lock_guard<std::mutex> lock(writeMp4Lock);
		nVideoFrameCount = 0;
		if (m_bOpenFlag)
		{
			if(ctx.mov != NULL )
			   mov_writer_destroy(ctx.mov);
			if(fWriteMP4)
			  fclose(fWriteMP4);

			fWriteMP4 = NULL;
			ctx.mov = NULL;
			WriteLog(Log_Debug, "CStreamRecordMP4 关闭mp4文件 m_szMp4FileName = %s ", szFileName);

			//完成一个mp4切片文件通知 
			if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientRecordMp4 > 0)
			{
				MessageNoticeStruct msgNotice;
				msgNotice.nClient = ABL_MediaServerPort.nClientRecordMp4;
				sprintf(msgNotice.szMsg, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"fileName\":\"%s\",\"currentFileDuration\":%llu}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType, szFileNameOrder, (nCurrentVideoFrames / mediaCodecInfo.nVideoFrameRate));
				pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
			}
			m_bOpenFlag = false;
		}
		return true;
	}

2、增加设置服务器任意一个参数
	//写配置文件
	bool CNetServerHTTP::WriteParamValue(char* szSection, char* szKey, char* szValue)
	{
		if (strcmp("secret", szKey) == 0)
			strcpy(ABL_MediaServerPort.secret, szValue);
		else if(strcmp("mediaServerID",szKey) == 0 )
			strcpy(ABL_MediaServerPort.mediaServerID, szValue); 
		else if (strcmp("localipAddress", szKey) == 0)
			strcpy(ABL_MediaServerPort.ABL_szLocalIP, szValue);
		else if (strcmp("maxTimeNoOneWatch", szKey) == 0)
			ABL_MediaServerPort.maxTimeNoOneWatch = atoi(szValue);
		else if (strcmp("recordPath", szKey) == 0)
			strcpy(ABL_MediaServerPort.recordPath, szValue);
		else if (strcmp("picturePath", szKey) == 0)
			strcpy(ABL_MediaServerPort.picturePath, szValue);
		else if (strcmp("maxSameTimeSnap", szKey) == 0)
			ABL_MediaServerPort.maxSameTimeSnap=atoi(szValue);
		else if (strcmp("snapOutPictureWidth", szKey) == 0)
			ABL_MediaServerPort.snapOutPictureWidth = atoi(szValue);
		else if (strcmp("snapOutPictureHeight", szKey) == 0)
			ABL_MediaServerPort.snapOutPictureHeight = atoi(szValue);
		else if (strcmp("snapObjectDestroy", szKey) == 0)
			ABL_MediaServerPort.snapObjectDestroy = atoi(szValue);
		else if (strcmp("snapObjectDuration", szKey) == 0)
			ABL_MediaServerPort.snapObjectDuration = atoi(szValue);
		else if (strcmp("captureReplayType", szKey) == 0)
			ABL_MediaServerPort.captureReplayType = atoi(szValue);
		else if (strcmp("pictureMaxCount", szKey) == 0)
			ABL_MediaServerPort.pictureMaxCount = atoi(szValue);
		else if (strcmp("pushEnable_mp4", szKey) == 0)
			ABL_MediaServerPort.pushEnable_mp4 = atoi(szValue);
		else if (strcmp("fileSecond", szKey) == 0)
			ABL_MediaServerPort.fileSecond = atoi(szValue);
		else if (strcmp("videoFileFormat", szKey) == 0)
			ABL_MediaServerPort.videoFileFormat = atoi(szValue);
		else if (strcmp("fileKeepMaxTime", szKey) == 0)
			ABL_MediaServerPort.fileKeepMaxTime = atoi(szValue);
		else if (strcmp("httpDownloadSpeed", szKey) == 0)
			ABL_MediaServerPort.httpDownloadSpeed = atoi(szValue);
		else if (strcmp("fileRepeat", szKey) == 0)
			ABL_MediaServerPort.fileRepeat = atoi(szValue);
		else if (strcmp("hook_enable", szKey) == 0)
			ABL_MediaServerPort.hook_enable = atoi(szValue);
		else if (strcmp("noneReaderDuration", szKey) == 0)
			ABL_MediaServerPort.noneReaderDuration = atoi(szValue);
		else if (strcmp("on_server_started", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_server_started, szValue);
		else if (strcmp("on_server_keepalive", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_server_keepalive, szValue);
		else if (strcmp("on_stream_arrive", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_stream_arrive, szValue);
		else if (strcmp("on_stream_not_arrive", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_stream_not_arrive, szValue);
		else if (strcmp("on_stream_none_reader", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_stream_none_reader, szValue);
		else if (strcmp("on_stream_disconnect", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_stream_disconnect, szValue);
		else if (strcmp("on_stream_not_found", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_stream_not_found, szValue);
		else if (strcmp("on_record_mp4", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_record_mp4, szValue);
		else if (strcmp("on_delete_record_mp4", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_delete_record_mp4, szValue);
		else if (strcmp("on_record_progress", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_record_progress, szValue);
		else if (strcmp("on_record_ts", szKey) == 0)
			strcpy(ABL_MediaServerPort.on_record_ts, szValue);
		else if (strcmp("httpServerPort", szKey) == 0)
			ABL_MediaServerPort.nHttpServerPort = atoi(szValue);
		else if (strcmp("rtspPort", szKey) == 0)
			ABL_MediaServerPort.nRtspPort = atoi(szValue);
		else if (strcmp("rtmpPort", szKey) == 0)
			ABL_MediaServerPort.nRtmpPort = atoi(szValue);
		else if (strcmp("httpMp4Port", szKey) == 0)
			ABL_MediaServerPort.nHttpMp4Port = atoi(szValue);
		else if (strcmp("wsFlvPort", szKey) == 0)
			ABL_MediaServerPort.nWSFlvPort = atoi(szValue);
		else if (strcmp("httpFlvPort", szKey) == 0)
			ABL_MediaServerPort.nHttpFlvPort = atoi(szValue);
		else if (strcmp("ps_tsRecvPort", szKey) == 0)
			ABL_MediaServerPort.ps_tsRecvPort = atoi(szValue);
		else if (strcmp("hls_enable", szKey) == 0)
			ABL_MediaServerPort.nHlsEnable = atoi(szValue);
		else if (strcmp("hlsPort", szKey) == 0)
			ABL_MediaServerPort.nHlsPort = atoi(szValue);
		else if (strcmp("hlsCutTime", szKey) == 0)
			ABL_MediaServerPort.hlsCutTime = atoi(szValue);
		else if (strcmp("hlsCutType", szKey) == 0)
			ABL_MediaServerPort.nHLSCutType = atoi(szValue);
		else if (strcmp("h265CutType", szKey) == 0)
			ABL_MediaServerPort.nH265CutType = atoi(szValue);
		else if (strcmp("enable_audio", szKey) == 0)
			ABL_MediaServerPort.nEnableAudio = atoi(szValue);
		else if (strcmp("G711ConvertAAC", szKey) == 0)
			ABL_MediaServerPort.nEnableAudio = atoi(szValue);
		else if (strcmp("IOContentNumber", szKey) == 0)
			ABL_MediaServerPort.nIOContentNumber = atoi(szValue);
		else if (strcmp("ThreadCountOfIOContent", szKey) == 0)
			ABL_MediaServerPort.nThreadCountOfIOContent = atoi(szValue);
		else if (strcmp("RecvThreadCount", szKey) == 0)
			ABL_MediaServerPort.nRecvThreadCount = atoi(szValue);
		else if (strcmp("SendThreadCount", szKey) == 0)
			ABL_MediaServerPort.nSendThreadCount = atoi(szValue);
		else if (strcmp("RecordReplayThread", szKey) == 0)
			ABL_MediaServerPort.nRecordReplayThread = atoi(szValue);
		else if (strcmp("GB28181RtpTCPHeadType", szKey) == 0)
			ABL_MediaServerPort.nGBRtpTCPHeadType = atoi(szValue);
		else if (strcmp("ReConnectingCount", szKey) == 0)
			ABL_MediaServerPort.nReConnectingCount = atoi(szValue);
		else if (strcmp("MaxDiconnectTimeoutSecond", szKey) == 0)
			ABL_MediaServerPort.MaxDiconnectTimeoutSecond = atoi(szValue);
		else if (strcmp("ForceSendingIFrame", szKey) == 0)
			ABL_MediaServerPort.ForceSendingIFrame = atoi(szValue);
		else
			return false;
		
		
	#ifdef OS_System_Windows
		ABL_ConfigFile.WriteConfigString(szSection, szKey, szValue);
	#else

	#endif

		return true;
	}

ABLMediaServer-2022-11-01【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、录像查询中返回http-mp4录像回放的速度修改为3 ，否则回放会卡顿 
   http://44.35.33.249:5088/Media/Camera_00001__ReplayFMP4RecordFile__20221031152622.mp4?download_speed=3

2、增加3个消息通知类
	else if (netClientType == NetBaseNetType_HttpClient_ServerStarted)
	{//事件通知9
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
	else if (netClientType == NetBaseNetType_HttpClient_ServerKeepalive)
	{//事件通知10
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
	else if (netClientType == NetBaseNetType_HttpClient_DeleteRecordMp4)
	{//事件通知11
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
   
3、增加服务器上线通知 

	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nServerStarted > 0)
	{
		MessageNoticeStruct msgNotice;
		msgNotice.nClient = ABL_MediaServerPort.nServerStarted;

#ifdef OS_System_Windows
		SYSTEMTIME st;
		GetLocalTime(&st);
		sprintf(msgNotice.szMsg, "{\"localipAddress\":\"%s\",\"mediaServerId\":\"%s\",\"datetime\":\"%04d-%02d-%02d %02d:%02d:%02d\"}", ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
#else
		time_t now;
		time(&now);
		struct tm *local;
		local = localtime(&now);
		sprintf(msgNotice.szMsg, "{{\"localipAddress\":\"%s\",\"mediaServerId\":\"%s\",\"datetime\":\"%04d-%02d-%02d %02d:%02d:%02d\"}", ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, local->tm_year + 1900, local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);
#endif
		pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
	}
	
3、服务器心跳通知 
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nServerKeepalive > 0 && (GetTickCount64() - nServerKeepaliveTime) >= 1000 * 10 )
	{
		nServerKeepaliveTime = GetTickCount64();

		MessageNoticeStruct msgNotice;
		msgNotice.nClient = ABL_MediaServerPort.nServerKeepalive;

#ifdef OS_System_Windows
		SYSTEMTIME st;
		GetLocalTime(&st);
		sprintf(msgNotice.szMsg, "{\"localipAddress\":\"%s\",\"mediaServerId\":\"%s\",\"datetime\":\"%04d-%02d-%02d %02d:%02d:%02d\"}", ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
#else
		time_t now;
		time(&now);
		struct tm *local;
		local = localtime(&now);
		sprintf(msgNotice.szMsg, "{{\"localipAddress\":\"%s\",\"mediaServerId\":\"%s\",\"datetime\":\"%04d-%02d-%02d %02d:%02d:%02d\"}", ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, local->tm_year + 1900, local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);
#endif
		pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
	}
		

4、完成一个覆盖一个mp4文件通知 
  if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientDeleteRecordMp4 > 0)
  {
	  MessageNoticeStruct msgNotice;
	  msgNotice.nClient = ABL_MediaServerPort.nClientDeleteRecordMp4;
	  sprintf(msgNotice.szMsg, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"fileName\":\"%s.mp4\"}", m_app, m_stream, ABL_MediaServerPort.mediaServerID, szDateTime);
	  pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
  }		
  
5、退出流媒体服务器
	bool   CNetServerHTTP::index_api_shutdownServer()
	{
		char  szSecret[256] = { 0 };
		GetKeyValue("secret", szSecret);
	 
		if (strlen(szSecret) == 0 )
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[ secret ] parameter need .\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strcmp(ABL_MediaServerPort.secret, szSecret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"ABLMediaServer shutdown Successed ! \"}", IndexApiCode_OK);
		ResponseSuccess(szResponseBody);

		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu index_api_shutdownServer() , %s  ", this, nClient, szResponseBody);

		ABL_bMediaServerRunFlag = false;

		return true;
	}

6、重启流媒体服务器
	bool   CNetServerHTTP::index_api_restartServer()
	{
		char  szSecret[256] = { 0 };
		GetKeyValue("secret", szSecret);

		if (strlen(szSecret) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[ secret ] parameter need .\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strcmp(ABL_MediaServerPort.secret, szSecret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"ABLMediaServer restartServer Successed ! \"}", IndexApiCode_OK);
		ResponseSuccess(szResponseBody);

		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu index_api_restartServer() , %s  ", this, nClient, szResponseBody);

		ABL_bMediaServerRunFlag = false;
		ABL_bRestartServerFlag = true;

		return true;
	}
  
ABLMediaServer-2022-10-28【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、倍速播放修改为字符串，也不再检测速度的值 （0.125、0.25、0.5、1、2、4、8、16）
 	bool  CNetClientRecvRtsp::RtspSpeed(char* nSpeed)
	{
		if (nRtspProcessStep != RtspProcessStep_PLAYSucess || nClient <= 0 || m_nXHRtspURLType != XHRtspURLType_RecordPlay)
			return false;

		if (m_wwwType == WWW_Authenticate_None)
		{
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nScale: %s\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSpeed, CSeq, MediaServerVerson, szSessionID);
		}
		else if (m_wwwType == WWW_Authenticate_MD5)
		{
			Authenticator author;
			char*         szResponse;

			author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
			author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
			szResponse = (char*)author.computeDigestResponse("PLAY", m_rtspStruct.szSrcRtspPullUrl); //要注意 uri ,有时候没有最后的 斜杠 /

			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nScale: %s\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSpeed, CSeq, MediaServerVerson, szSessionID, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szSrcRtspPullUrl, szResponse);

			author.reclaimDigestResponse(szResponse);
		}
		else if (m_wwwType == WWW_Authenticate_Basic)
		{
			UserPasswordBase64(szBasic);
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nScale: %s\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Basic %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSpeed, CSeq, MediaServerVerson, szSessionID, szBasic);
		}

		XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		CSeq++;
		m_bPauseFlag = false;
		WriteLog(Log_Debug, "CNetClientRecvRtsp = %X,nClient = %d ,RtspSpeed() \r\n%s", this, nClient, szResponseBuffer);
		return true;
	}

2、支持 hls 拉流接入 	
	if (memcmp(szIP, "http://", 7) == 0 && strstr(szIP,".m3u8") != NULL )
	{//hls 暂时不支持 hls 拉流 
		pXHClient = boost::make_shared<CNetClientRecvHttpHLS>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
	}	
	
3、在发送线程池增加一个功能，即使 video,audio 的fifo 没有数据都支持 SendVideo() SendAudio() 虚函数 
   if (pClient->netBaseNetType == NetBaseNetType_HttpHLSClientRecv)
   {//用于HLS视频，音频均匀塞入媒体源、以后还可以支持别的没有视频、音频发送的类
	   pClient->SendVideo();
	   pClient->SendAudio();
	   Sleep(5);
   }
   else
   {

	
ABLMediaServer-2022-10-24【彻底解决 http-mp4 码流输出奔溃问题、完美解决录像回放（录像点播流畅性问题） 】 
1、完美解决录像回放（录像点播流畅性问题）
   int CReadRecordFileInput::ProcessNetData() 
   {
	 std::lock_guard<std::mutex> lock(readRecordFileInputLock);
	 nRecvDataTimerBySecond = 0;

	 if (mov == NULL || m_bPauseFlag == true )
	 {
		Sleep(2);
		mov_readerTime = GetTickCount64();
		RecordReplayThreadPool->InsertIntoTask(nClient);
		return -1;
	 }

	 //视频，音频都调用这函数读取，在后面判断视频、音频进行延时 ，音频数据不用延时，
	 nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);

	 if (nAVType == AVType_Video)
	 {//读取视频
		mov_readerTime = GetTickCount64();

		if ((abs(m_dScaleValue - 8.0) <= 0.01 || abs(m_dScaleValue - 16.0) <= 0.01))
		{//8、16倍速不需要等待 

			if (nReadVideoFrameCount % 25 == 0)
			{
				if (abs(m_dScaleValue - 8.0) <= 0.01)
					Sleep(60);
				else
					Sleep(30);
			}
		}
		else if (abs(m_dScaleValue - 255.0) <= 0.01 )
		{//rtsp录像下载
			Sleep(2);
		}
		else if (abs(m_dScaleValue - 1.0) <= 0.01)
		{//普通的点播回放
		   if (((1000 / mediaCodecInfo.nVideoFrameRate) - 10) > 0)
			 Sleep((1000 / mediaCodecInfo.nVideoFrameRate) - 10);
			else
			  Sleep(10);
		}
		else 
		{//读取视频的时间尚未到，需要Sleep(2) ,否则CPU会狂跑
			if ( !(abs(m_dScaleValue - 8.0) <= 0.01 || abs(m_dScaleValue - 16.0) <= 0.01) )
			   Sleep(2); //8倍速、16倍速，不需要Sleeep
		}
	 }
	 else if (nAVType == AVType_Audio)  
	 {//音频直接读取,音频数据不需要延时

	 }

ABLMediaServer-2022-10-23【彻底解决 http-mp4 码流输出奔溃问题 】 
1、Linux平台设置最大连接数量
	struct rlimit rlim, rlim_new;
	if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
		rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
		if (setrlimit(RLIMIT_CORE, &rlim_new) != 0) {
			rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
			setrlimit(RLIMIT_CORE, &rlim_new);
		}
	 WriteLog(Log_Debug,"core文件大小设置为: %llu " , rlim_new.rlim_cur);
	}

	if (getrlimit(RLIMIT_NOFILE, &rlim) == 0) {
		rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
		if (setrlimit(RLIMIT_NOFILE, &rlim_new) != 0) {
			rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
			setrlimit(RLIMIT_NOFILE, &rlim_new);
		}
	  WriteLog(Log_Debug, "文件最大描述符个数设置为: %llu " , rlim_new.rlim_cur);
	}
	
2、彻底解决 http-mp4 码流输出奔溃问题，需要清空 avc\hevc 这两个结构 ，否则压力轮询会奔溃，可能在linux平台结构的值不会初始化 
	memset((char*)&avc, 0x00, sizeof(avc));
	memset((char*)&hevc, 0x00, sizeof(hevc));

	
3、优化 CNetServerHTTP_MP4 类
	int CNetServerHTTP_MP4::PushVideo(uint8_t* pVideoData, uint32_t nDataLength, char* szVideoCodec)
	{
		if (!bRunFlag)
			return -1;
			
	CNetServerHTTP_MP4::~CNetServerHTTP_MP4()
	{
		bCheckHttpMP4Flag = bRunFlag = false ;
		std::lock_guard<std::mutex> lock(mediaMP4MapLock);

		XHNetSDK_Disconnect(nClient);

ABLMediaServer-2022-10-21【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、增加mp4格式的录像功能StreamRecordMP4.cpp 、StreamRecordMP4.h 

2、mp4录像时，不能固定时间戳增量，因为视频帧速度不是固定的
	//加入视频
	bool CStreamRecordMP4::AddVideo(char* szVideoName, unsigned char* pVideoData, int nVideoDataLength)
	{		
 		//计算真实的时间戳，不能固定25帧每秒
  		ctx.pts += (1000 / mediaCodecInfo.nVideoFrameRate);
		ctx.dts += (1000 / mediaCodecInfo.nVideoFrameRate);
		
3、完成一个mp4切片文件通知 
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientRecordMp4 > 0)
	{
		MessageNoticeStruct msgNotice;
		msgNotice.nClient = ABL_MediaServerPort.nClientRecordMp4;
		sprintf(msgNotice.szMsg, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"fileName\":\"%s\",\"currentFileDuration\":%llu}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType, szFileNameOrder, (nCurrentVideoFrames / mediaCodecInfo.nVideoFrameRate));
		pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
	}
	
4、如果连接失败，采用急速删除函数 DeleteNetRevcBaseClient 替换加入断裂链表  
	void LIBNET_CALLMETHOD	onconnect(NETHANDLE clihandle,
		uint8_t result)
	{
		if (result == 0)
		{
			CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
			if (pClient)
			{
				WriteLog(Log_Debug, "clihandle = %llu ,URL: %s ,连接失败 result: %d ", clihandle,pClient->m_rtspStruct.szSrcRtspPullUrl,result);
				if (pClient->netBaseNetType == NetBaseNetType_RtspClientRecv || pClient->netBaseNetType ==  NetBaseNetType_RtmpClientRecv || pClient->netBaseNetType == NetBaseNetType_HttpFlvClientRecv || 
					pClient->netBaseNetType ==  NetBaseNetType_HttpHLSClientRecv || pClient->netBaseNetType ==  NetBaseNetType_RtspClientPush || pClient->netBaseNetType == NetBaseNetType_RtmpClientPush ||
					pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect )
				{//rtsp 代理拉流失败
					sprintf(pClient->szResponseBody, "{\"code\":%d,\"memo\":\"Network Connect [%s : %s] Failed .\",\"key\":%llu}", IndexApiCode_ConnectFail,pClient->m_rtspStruct.szIP,pClient->m_rtspStruct.szPort, pClient->hParent);
					pClient->ResponseHttp(pClient->nClient_http, pClient->szResponseBody, false);

					//判断是否成功过，如果尚未成功，则立即删除 ，如果成功过则无限次重连
					CNetRevcBase_ptr pParent = GetNetRevcBaseClient(pClient->hParent);
					if (pParent != NULL)
					{
					  if (pParent->bProxySuccessFlag == false)
						pDisconnectBaseNetFifo.push((unsigned char*)&pClient->hParent, sizeof(pClient->hParent));
					}
				}
			}
			 
			//测试
			DeleteNetRevcBaseClient(clihandle);
		    // pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));
		}
		
ABLMediaServer-2022-10-18【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、增加更加完善的检测app,stream 是否被占用函数 ，用于检测代理拉流接入、国标接入的/app/stream 是否占用 
	bool CheckAppStreamExisting(char* szAppStreamURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		CNetRevcBase_ptr   pClient = NULL;
		bool   bAppStreamExisting = false ;
		char   szTemp2[512] = { 0 };

		if (xh_ABLNetRevcBaseMap.size() <= 0)
		{
			return false;
		}

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); ++iterator1)
		{
			pClient = (*iterator1).second;
			if (pClient != NULL && pClient->netBaseNetType != NetBaseNetType_NetServerHTTP)
			{
				sprintf(szTemp2, "/%s/%s", pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
				if (strcmp(szTemp2, szAppStreamURL) == 0)
				{
					bAppStreamExisting = true ;
					WriteLog(Log_Debug, "CheckAppStreamExisting(), url = %s  已经存在 ,正在接入 !", szAppStreamURL);
					break;
				}
			}
		}
		return bAppStreamExisting ;
	}

2、创建媒体源失败，则删除对象本身 	
	pMediaSource = CreateMediaStreamSource(m_szShareMediaURL, hParent, MediaSourceType_LiveMedia, 0);
	if (pMediaSource)
		pMediaSource->enable_mp4 = (strcmp(m_addStreamProxyStruct.enable_mp4, "1") == 0) ? true : false;
	else 
	{
		DeleteNetRevcBaseClient(nClient);
		return -1;
	}

ABLMediaServer-2022-10-14【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、在rtmp拉流时，创建rtmp对象，需要去掉第2级路径名称 

	//rtmp客户端连接，需要去掉第2级路径 
	string strRtmpURL = szClientIP;
	int nPos = strRtmpURL.rfind("/", strlen(szClientIP));
	if (nPos <= 0)
	{
		WriteLog(Log_Debug, "CNetClientRecvRtmp = %X rtmp中的url有误 ,url = %s, nClient = %llu \r\n", this, szClientIP, nClient);
		pDisconnectBaseNetFifo.push((unsigned char*)&hParent, sizeof(hParent));

		DeleteNetRevcBaseClient(nClient);
		return -1;
 	}
	szClientIP[nPos] = 0x00;
	
	// szStream 已经有第2级名称 
	rtmp = rtmp_client_create(szApp, szStream,szClientIP, this, &handler);

ABLMediaServer-2022-10-13【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、所有客户端连接超时设置为12秒，定义了一个12秒的宏 
   #define  MaxClientConnectTimerout           12*1000       //连接服务器最大超时时长 12 秒 

   if (ParseRtspRtmpHttpURL(szIP) == true)
	 uint32_t ret = XHNetSDK_Connect((int8_t*)m_rtspStruct.szIP, atoi(m_rtspStruct.szPort), (int8_t*)(NULL), 0, (uint64_t*)&nClient, onread, onclose, onconnect, 0, MaxClientConnectTimerout, 1);

ABLMediaServer-2022-10-02【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、rmp推流 rtmp 对象要设置为NULL，否则析构可能崩溃 
	CNetClientSendRtmp::CNetClientSendRtmp(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
	{
		rtmp = NULL ;
		
2、在flv拉流时，创建flv解析器失败时，需要销毁flv对象 

    //创建flv解析器 
	if (reader == NULL)
	  reader = flv_reader_create2(http_flv_netRead, this);

    //创建失败 
	if (reader == NULL)
	{
		bRunFlag = false;
		WriteLog(Log_Debug, "CNetClientRecvFLV = %X nClient = %llu flv_reader_create2 创建失败 ,执行删除 ", this,nClient);
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient,sizeof(nClient));
		return -1;
	}
	
ABLMediaServer-2022-09-29【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、rtmp 拉流构造函数，一定要 rtmp 设置为空 ，否则在析构操作时会奔溃 
	CNetClientRecvRtmp::CNetClientRecvRtmp(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
	{
		rtmp = NULL ;
	
	数据处理时也加上判断 
	int CNetClientRecvRtmp::ProcessNetData()
	{
		unsigned char* pData = NULL;
		int            nLength;

		pData = NetDataFifo.pop(&nLength);
		if(pData != NULL && rtmp != NULL )
		{
			if (nLength > 0)
				rtmp_client_input(rtmp, pData, nLength);
	 
			NetDataFifo.pop_front();
		}
		return 0;
	}

ABLMediaServer-2022-09-28【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、增加网络异常断开回复函数
	//回复成功信息
	bool  CNetRevcBase::ResponseHttp2(uint64_t nHttpClient, char* szSuccessInfo, bool bClose)
	{
		if (bResponseHttpFlag)
			return false;

		//功能实现类已经回复
		bResponseHttpFlag = true;

		//回复http请求
		string strReponseError = szSuccessInfo;
		replace_all(strReponseError, "\r\n", " ");
		strcpy(szSuccessInfo, strReponseError.c_str());

		int nLength = strlen(szSuccessInfo);
		if (bClose == true)
			sprintf(szResponseHttpHead, "HTTP/1.1 200 OK\r\nServer: %s\r\nContent-Type: application/json;charset=utf-8\r\nAccess-Control-Allow-Origin: *\r\nConnection: close\r\nContent-Length: %d\r\n\r\n", MediaServerVerson, nLength);
		else
			sprintf(szResponseHttpHead, "HTTP/1.1 200 OK\r\nServer: %s\r\nContent-Type: application/json;charset=utf-8\r\nAccess-Control-Allow-Origin: *\r\nConnection: %s\r\nContent-Length: %d\r\n\r\n", MediaServerVerson, "keep-alive", nLength);

		XHNetSDK_Write(nHttpClient, (unsigned char*)szResponseHttpHead, strlen(szResponseHttpHead), 1);
		XHNetSDK_Write(nHttpClient, (unsigned char*)szSuccessInfo, nLength, 1);

		WriteLog(Log_Debug, szSuccessInfo);
		return true;
	}

ABLMediaServer-2022-09-27【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、在代理拉起 rtsp,rtmp,flv 流接入时，由于服务器突然断开，需要在析构函数回复代理拉流请求失败 
	//服务器异常断开
	if (bUpdateVideoFrameSpeedFlag == false)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"faied. Abnormal didconnection \",\"key\":%llu}", IndexApiCode_RecvRtmpFailed, 0);
		ResponseHttp(nClient_http, szResponseBody, false);
	}

ABLMediaServer-2022-09-25【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、增加服务指定配置文件启动
    if(argc >= 3)
      WriteLog(Log_Debug, "argc = %d, argv[0] = %s ,argv[1] = %s ,argv[2] = %s ", argc,argv[0],argv[1],argv[2]);
	
	if(argc >=3 && strcmp(argv[1],"-c") == 0)
	{//带配置文件启动
	   strcpy(szConfigFileName,argv[2]) ;	
	}else
	  sprintf(szConfigFileName, "%s/%s", ABL_MediaSeverRunPath, "ABLMediaServer.ini");


ABLMediaServer-2022-09-17【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、增加录像下载进度通知
	else if (netClientType == NetBaseNetType_HttpClient_Record_Progress)
	{//事件通知8
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}

	#录像进度:当前录像文件已经录制了多少秒，总录像时长已经到多少秒：如果不需要通知该事件，就把 http://10.0.0.238:7088/index/hook/on_record_progress删除掉 
	on_record_progress=http://10.0.0.238:4088/index/hook/on_record_progress

2、增加录像下载进度通知消息发送 
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientRecordProgress > 0 && (GetTickCount64() - nCreateDateTime ) >= 1000 )
	{
		MessageNoticeStruct msgNotice;
		msgNotice.nClient = ABL_MediaServerPort.nClientRecordProgress;
		sprintf(msgNotice.szMsg, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%d,\"fileName\":\"%s\",\"currentFileDuration\":%d,\"TotalVideoDuration\":%d}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType,key, szFileNameOrder, (nCurrentVideoFrames / 25), (nTotalVideoFrames / 25));
		pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
		nCreateDateTime = GetTickCount64();
	}

3、录像文件切片采用写入了多少视频帧为计算基准，而不是写了多长时间 
   if ((nCurrentVideoFrames / mediaCodecInfo.nVideoFrameRate ) >= ABL_MediaServerPort.fileSecond)


ABLMediaServer-2022-09-14【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、把码流达到不需要等待I帧，只要有流到达就通知，这样视频出画面的速度会更快 
	bool  CMediaStreamSource::GetVideoWidthHeight(char* szVideoCodeName, unsigned char* pVideoData, int nDataLength)
	{
		//码流达到通知
		if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientArrive > 0 && m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0 && bNoticeClientArriveFlag == false)
		{//检测出宽、高再通知 
			MessageNoticeStruct msgNotice;
			msgNotice.nClient = ABL_MediaServerPort.nClientArrive;
			sprintf(msgNotice.szMsg, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%llu}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType, nClient);
			pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));
			bNoticeClientArriveFlag = true;
		}

ABLMediaServer-2022-09-11【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、删除代理拉流、代理推送时判是否成功过，如果从未成功过则删除。
	//删除掉代理拉流、推流
	CNetRevcBase_ptr pParentPtr = GetNetRevcBaseClientNoLock(((*iterator1).second)->hParent);
	if (pParentPtr)
	{
		if (((*iterator1).second)->bProxySuccessFlag == false)
		   pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->hParent, sizeof(((*iterator1).second)->hParent));
	}

2、	如果从未成功过则删除代理对象句柄
 	WriteLog(Log_Debug, "nClient = %llu , nMediaClient = %llu 检测到网络异常断开2 , %s ，现在执行第 %llu 次重连  ", ((*iterator1).second)->nClient, ((*iterator1).second)->nMediaClient,((*iterator1).second)->m_addStreamProxyStruct.url, ((*iterator1).second)->nReConnectingCount);
	if (((*iterator1).second)->bProxySuccessFlag == true)
	  pReConnectStreamProxyFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof(((*iterator1).second)->nClient));
	else
	  pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof(((*iterator1).second)->nClient));
			
ABLMediaServer-2022-09-10【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、修正rtsp、rtmp 推送失败后，能够反复推流 。

ABLMediaServer-2022-08-26【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、修改判断7088Http请求非法连接条件 
	//响应http请求
	bool CNetServerHTTP::ResponseHttpRequest(char* szModem, char* httpURL, char* requestParam)
	{
		if (!bRunFlag)
			return false;
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu  , szModem = %s ，httpURL = %s", this, nClient, szModem, httpURL);

		//url 请求合法性简单判断,发现有一些乱七八糟的请求发过来  .php .asp .html .htm .jars .zip .rar .exe .tar .tar.gz .7z .dll .bat
		if (! ((strcmp(httpURL, "/index/api/addStreamProxy") == 0) || (strcmp(httpURL, "/index/api/delStreamProxy") == 0) || (strcmp(httpURL, "/index/api/delMediaStream") == 0) ||
			(strcmp(httpURL, "/index/api/addPushProxy") == 0) || (strcmp(httpURL, "/index/api/delPushProxy") == 0) || (strcmp(httpURL, "/index/api/openRtpServer") == 0) ||
			(strcmp(httpURL, "/index/api/closeRtpServer") == 0) || (strcmp(httpURL, "/index/api/startSendRtp") == 0) || (strcmp(httpURL, "/index/api/stopSendRtp") == 0) ||
			(strcmp(httpURL, "/index/api/getMediaList") == 0) || (strcmp(httpURL, "/index/api/getOutList") == 0) || (strcmp(httpURL, "/index/api/delOutList") == 0) ||
			(strcmp(httpURL, "/index/api/getServerConfig") == 0) || (strcmp(httpURL, "/index/api/close_streams") == 0) || (strcmp(httpURL, "/index/api/startRecord") == 0) ||
			(strcmp(httpURL, "/index/api/stopRecord") == 0) || (strcmp(httpURL, "/index/api/queryRecordList") == 0) || (strcmp(httpURL, "/index/api/getSnap") == 0) || (strstr(httpURL, ".jpg") != 0)  || //jpg 下载需要
			(strcmp(httpURL, "/index/hook/on_stream_none_reader") == 0 || strcmp(httpURL, "/index/hook/on_stream_not_found") == 0 || strcmp(httpURL, "/index/hook/on_record_mp4") == 0) || //测试事件回复
			(strcmp(httpURL, "/index/api/queryPictureList") == 0) || (strcmp(httpURL, "/index/api/controlStreamProxy") == 0) || (strcmp(httpURL, "/index/api/setTransFilter") == 0) ||
			(strcmp(httpURL, "/index/api/setConfigParamValue") == 0)) )
		{
			bRunFlag = false;
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http 请求非法的文件 ，httpURL = %s", this, nClient, httpURL);
			DeleteNetRevcBaseClient(nClient);
			return false ;
		}


ABLMediaServer-2022-08-25【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 

1、增加快速删除资源线程、快速删除对象
	void*  ABLMedisServerFastDeleteThread(void* lpVoid)
	{
		unsigned char* pData = NULL;
		int            nLength;
		uint64_t       nClient;

		while (ABL_bMediaServerRunFlag)
		{
 			while ((pData = pDisconnectBaseNetFifo.pop(&nLength)) != NULL)
			{
				if (nLength == sizeof(nClient))
				{
					memcpy((char*)&nClient, pData, sizeof(nClient));
					if (nClient >= 0)
					{
						DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
						pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
						DeleteNetRevcBaseClient(nClient);//执行删除 
					}
				}

				pDisconnectBaseNetFifo.pop_front();
			}

			Sleep(20);
		}
		return 0;
	}

2、删除掉  CMediaFifo   pRemoveBaseNetFromThreadFifo ，发送线程，拷贝线程会自动删除，不需要额外删除 
	

ABLMediaServer-2022-08-24【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、在onclose 函数把 移除拷贝线程，移除发送线程的两行代码删除 
	void LIBNET_CALLMETHOD	onclose(NETHANDLE srvhandle,
		NETHANDLE clihandle)
	{  
		WriteLog(Log_Debug, "onclose() nClient = %llu 客户端断开 srvhandle = %llu", clihandle, srvhandle);

		//pMediaSendThreadPool->DeleteClientToThreadPool(clihandle);//移除发送线程 
		//DeleteClientMediaStreamSource(clihandle);//移除媒体拷贝
		
		DeleteNetRevcBaseClient(clihandle);
	}

2、不再创建 国标RTCP类，删除掉以下一行 
   boost::shared_ptr<CNetRevcBase> pClientRtcp = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerRTCP, 0, nMediaClient2, "", ABL_nGB28181Port + 1, szTemp);
	
3、在国标UDP 接收类释放时，直接关闭rtcp的Socket即可，
	CNetGB28181RtpServer::~CNetGB28181RtpServer()
	{
		bRunFlag = false;
		std::lock_guard<std::mutex> lock(netDataLock);

	  //清理rtcp 
	 if (nClientRtcp > 0)
		 XHNetSDK_DestoryUdp(nClientRtcp); 
	
ABLMediaServer-2022-08-23【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、把国标代理类删除掉，把绑定国标端口移动到 CNetServerHTTP 
	//绑定国标接收端口
	int   CNetServerHTTP::bindRtpServerPort()
	{
		nTcp_Switch = atoi(m_openRtpServerStruct.enable_tcp);
		int nRet = 2, nRet2 = 2;
		char szTemp[256] = { 0 };
		char szTemp2[128] = { 0 };
		sprintf(szTemp, "/%s/%s", m_openRtpServerStruct.app, m_openRtpServerStruct.stream_id);
		sprintf(m_szShareMediaURL, "/%s/%s", m_openRtpServerStruct.app, m_openRtpServerStruct.stream_id);

		//给代理拉流结构拷贝app,stream ,查找媒体源流输入时需要
		strcpy(m_addStreamProxyStruct.app, m_openRtpServerStruct.app);
		strcpy(m_addStreamProxyStruct.stream, m_openRtpServerStruct.stream_id);
		sprintf(m_addStreamProxyStruct.url, "rtp://127.0.0.1:%s/%s/%s", m_openRtpServerStruct.port, m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);
		strcpy(m_addStreamProxyStruct.enable_mp4, m_openRtpServerStruct.enable_mp4);//是否录像

		if (nTcp_Switch == 0)
		{//udp方式
			if (atoi(m_openRtpServerStruct.port) == 0)
			{
				do
				{
					nRet = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);//rtp
					nRet2 = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port + 1, NULL, &nMediaClient2, onread, 1);//rtcp
					if (nRet != 0 || nRet2 != 0)
						ABL_nGB28181Port += 2;
				} while (nRet != 0 || nRet2 != 0);
			}
			else
			{
				nRet = XHNetSDK_BuildUdp(NULL, atoi(m_openRtpServerStruct.port), NULL, &nMediaClient, onread, 1);
				nRet2 = XHNetSDK_BuildUdp(NULL, atoi(m_openRtpServerStruct.port) + 1, NULL, &nMediaClient2, onread, 1);
			}

			//自动产生端口
			if (atoi(m_openRtpServerStruct.port) == 0)
				sprintf(m_openRtpServerStruct.port, "%d", ABL_nGB28181Port); //记下真实端口 

			if (nRet == 0 && nRet2 == 0)
			{//rtp ,rtcp 都绑定成功
				boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerUDP, 0, nMediaClient, "", ABL_nGB28181Port, szTemp);
				boost::shared_ptr<CNetRevcBase> pClientRtcp = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerRTCP, 0, nMediaClient2, "", ABL_nGB28181Port + 1, szTemp);
				if (pClient != NULL)
				{
					pClient->m_gbPayload = atoi(m_openRtpServerStruct.payload);//更新为正确的paylad
					pClient->nClientRtcp = nMediaClient2;//rtcp 连接
					memcpy((unsigned char*)&pClient->m_addStreamProxyStruct, (unsigned char*)&m_addStreamProxyStruct, sizeof(m_addStreamProxyStruct));
					sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"port\":\"%s\",\"key\":%llu}", m_openRtpServerStruct.port, nMediaClient);
				}
			}
			else
			{//期中有一个端口绑定失败 
				XHNetSDK_DestoryUdp(nMediaClient);//关闭 rtp 
				XHNetSDK_DestoryUdp(nMediaClient2);//关闭 rtcp 
				nRet = 2;//标识为不成功 
			}
		}
		else if (nTcp_Switch == 1)
		{//如果是TCP
			if (atoi(m_openRtpServerStruct.port) == 0)
			{
				do
				{
					nRet = XHNetSDK_Listen((int8_t*)("0.0.0.0"), ABL_nGB28181Port, &nMediaClient, onaccept, onread, onclose, true);
					if (nRet != 0)
						ABL_nGB28181Port += 2;
				} while (nRet != 0);
			}
			else
			{
				nRet = XHNetSDK_Listen((int8_t*)("0.0.0.0"), atoi(m_openRtpServerStruct.port), &nMediaClient, onaccept, onread, onclose, true);
			}

			//自动产生端口
			if (atoi(m_openRtpServerStruct.port) == 0)
				sprintf(m_openRtpServerStruct.port, "%d", ABL_nGB28181Port); //记下真实端口 

			if (nRet == 0)
			{
				boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerListen, 0, nMediaClient, "", ABL_nGB28181Port, szTemp);
				if (pClient != NULL)
				{
					memcpy((char*)&pClient->m_addStreamProxyStruct,(char*)&m_addStreamProxyStruct,sizeof(m_addStreamProxyStruct));
					memcpy((char*)&pClient->m_openRtpServerStruct,(char*)&m_openRtpServerStruct,sizeof(m_openRtpServerStruct));

					sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"port\":\"%s\",\"key\":%llu}", m_openRtpServerStruct.port, nMediaClient);
				}
			}
		}
	 
		 //回复Http 请求
		if (nRet != 0)
		   sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"bind port %s failed .\",\"port\":\"%s\",\"key\":%llu}", IndexApiCode_BindPortError, m_openRtpServerStruct.port, m_openRtpServerStruct.port, 0);
		
		ResponseSuccess(szResponseBody);

		ABL_nGB28181Port += 2;//需要优化端口 
		if (ABL_nGB28181Port >= 65520)
			ABL_nGB28181Port = 10002;  //端口重新反转

		//绑定端口失败，需要删除
		if (nRet != 0)
			return -1;
		else
			return 0;
	}
	
2、优化TCP方式的国标接入连接 	
	CNetRevcBase_ptr gb28181Listen = GetNetRevcBaseClientNoLock(serverHandle);
	if (gb28181Listen && gb28181Listen->nMediaClient == 0 )
	{
		CNetGB28181RtpServer* gb28181TCP = NULL;
		pXHClient = boost::make_shared<CNetGB28181RtpServer>(serverHandle, CltHandle, szIP, nPort, gb28181Listen->m_szShareMediaURL);
		pXHClient->netBaseNetType = NetBaseNetType_NetGB28181RtpServerTCP_Server;//国标28181 tcp 方式接收码流 

		gb28181Listen->nMediaClient = CltHandle; //已经有人连接进来

		gb28181TCP = (CNetGB28181RtpServer*)pXHClient.get();
		if (gb28181TCP)
			gb28181TCP->netDataCache = new unsigned char[MaxNetDataCacheBufferLength]; //在使用前先准备好内存 

		pXHClient->hParent = gb28181Listen->nClient;//记录国标代理句柄号
		pXHClient->m_gbPayload = atoi(gb28181Listen->m_openRtpServerStruct.payload);//更新paylad 
		memcpy((char*)&pXHClient->m_addStreamProxyStruct, (char*)&gb28181Listen->m_addStreamProxyStruct, sizeof(gb28181Listen->m_addStreamProxyStruct));
	}
	else
		return NULL;

ABLMediaServer-2022-08-21【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、所有消息通知 都修改为先加入链表，在任务处理线程统一发送出去 
    1) 无人观看消息,30秒中通知一次
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNoneReader > 0  && GetCurrentSecond() - nLastWatchTime >= ABL_MediaServerPort.noneReaderDuration)
	{
		MessageNoticeStruct msgNotice;
		msgNotice.nClient = ABL_MediaServerPort.nClientNoneReader;
		sprintf(msgNotice.szMsg, "{\"app\":\"%s\",\"stream\":\"%s\",\"noneReaderDuration\":%d,\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%llu}", app, stream, GetCurrentSecond() - nLastWatchTimeDisconect, ABL_MediaServerPort.mediaServerID, netBaseNetType, nClient);
		pMessageNoticeFifo.push((unsigned char*)&msgNotice, sizeof(MessageNoticeStruct));

		nLastWatchTime = GetCurrentSecond();
	}
	
	2) 统一发送 处理消息通知
	while ((pData = pMessageNoticeFifo.pop(&nLength)) != NULL)
	{
		if (nLength > 0)
		{
			memset((char*)&msgNotice, 0x00, sizeof(msgNotice));
			memcpy((char*)&msgNotice, pData, nLength);

			boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(msgNotice.nClient);
			if (pHttpClient != NULL)
				pHttpClient->PushVideo((unsigned char*)msgNotice.szMsg, strlen(msgNotice.szMsg), "JSON");
		}
		pMessageNoticeFifo.pop_front();
	}
	
2、调整国标清理资源的位置
   1) 
	 if (hParent > 0)
	 {
		 WriteLog(Log_Debug, "CNetGB28181RtpServer = %X 加入清理国标代理句柄号 hParent = %llu, nClient = %llu ,nMediaClient = %llu", this, hParent, nClient, nMediaClient);
		 pDisconnectBaseNetFifo.push((unsigned char*)&hParent, sizeof(hParent));
	 }

	 //清理rtcp 
	 if (nClientRtcp > 0)
		 pDisconnectBaseNetFifo.push((unsigned char*)&nClientRtcp, sizeof(nClientRtcp));
		
    2) 		
	CNetGB28181Proxy::~CNetGB28181Proxy()
	{
		//最后才删除媒体源
		if (strlen(m_szShareMediaURL) > 0)
			pDeleteMediaSourceFifo.push((unsigned char*)m_szShareMediaURL, strlen(m_szShareMediaURL));
		
ABLMediaServer-2022-08-20【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、在各个媒体输入类的析构处，不直接删除媒体源，先加入链表，在任务线程中进行删除
    1） 比如，先加入 pDeleteMediaSourceFifo
	CRtpTSStreamInput::~CRtpTSStreamInput()
	{
		std::lock_guard<std::mutex> lock(tsRecvLock);

		if (ts)
		{
			ts_demuxer_flush(ts);
			ts_demuxer_destroy(ts);
			ts = NULL;
		 }
		 m_videoFifo.FreeFifo();

		//删除分发源
		if (strlen(m_szShareMediaURL) > 0)
			pDeleteMediaSourceFifo.push((unsigned char*)m_szShareMediaURL,strlen(m_szShareMediaURL));
			
			
	//在任务线程中执行清理媒体源
	while ((pData = pDeleteMediaSourceFifo.pop(&nLength)) != NULL)
	{
		if (nLength > 0)
		{
			memset(szDeleteMediaSource, 0x00, sizeof(szDeleteMediaSource));
			memcpy(szDeleteMediaSource, pData, nLength);
			DeleteMediaStreamSource(szDeleteMediaSource);//删除媒体源
		}

		pDeleteMediaSourceFifo.pop_front();
	}

2、CNetServerHLS 的析构函数加锁 
	CNetServerHLS::~CNetServerHLS()
	{
		bRunFlag = false;
		std::lock_guard<std::mutex> lock(netDataLock);


ABLMediaServer-2022-08-19【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、CNetServerHTTP 也像rtsp类那样处理，在析构时锁住 

ABLMediaServer-2022-08-18【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】 
1、国标推流、rtsp推流、rtmp推流、rtmp拉流 在塞入视频、音频 都加锁  

	CNetGB28181RtpClient::~CNetGB28181RtpClient()
	{
		bRunFlag = false;
		std::lock_guard<std::mutex> lock(businessProcMutex);

		if (netBaseNetType == NetBaseNetType_NetGB28181SendRtpUDP)
		{
			XHNetSDK_DestoryUdp(nClient);
		}
		else if (netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect)
		{
			XHNetSDK_Disconnect(nClient);
		}
		
		WriteLog(Log_Debug, "CNetGB28181RtpClient 析构 = %X  nClient = %llu ,nMediaClient = %llu\r\n", this, nClient, nMediaClient);
		malloc_trim(0);
	}

	int CNetGB28181RtpClient::PushVideo(uint8_t* pVideoData, uint32_t nDataLength, char* szVideoCodec)
	{
		if (!bRunFlag)
			return -1;
		std::lock_guard<std::mutex> lock(businessProcMutex);
		
		nRecvDataTimerBySecond = 0 ;

		if (strlen(mediaCodecInfo.szVideoName) == 0)
			strcpy(mediaCodecInfo.szVideoName, szVideoCodec);

		m_videoFifo.push(pVideoData, nDataLength);
		return 0;
	}

	int CNetGB28181RtpClient::PushAudio(uint8_t* pVideoData, uint32_t nDataLength, char* szAudioCodec, int nChannels, int SampleRate)
	{
		if (!bRunFlag)
			return -1;
		std::lock_guard<std::mutex> lock(businessProcMutex);

2、在基类函数 ResponseHttp	中去掉两把锁，否则会卡住 
	//回复成功信息
	bool  CNetRevcBase::ResponseHttp(uint64_t nHttpClient,char* szSuccessInfo,bool bClose)
	{
		//功能实现类已经回复
		bResponseHttpFlag = true;

		boost::shared_ptr<CNetRevcBase>  pClient = GetNetRevcBaseClientNoLock(nHttpClient);
		if (pClient == NULL)
			return true;
		if (pClient->bResponseHttpFlag)
			return true;
			
ABLMediaServer-2022-08-17【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、国标TCP方式，必须删除掉这行 gb28181RecvProxy->nMediaClient = CltHandle;//国标代理TCP接收句柄号
	CNetRevcBase_ptr gb28181RecvProxy = GetNetRevcBaseClientNoLock(hParent);
	if (gb28181RecvProxy != NULL)
	{//把国标代理的信息拷贝个国标TCP
		//gb28181RecvProxy->nMediaClient = CltHandle;//国标代理TCP接收句柄号
		pXHClient->m_gbPayload = atoi(gb28181RecvProxy->m_openRtpServerStruct.payload);//更新paylad 
		memcpy((char*)&pXHClient->m_addStreamProxyStruct, (char*)&gb28181RecvProxy->m_addStreamProxyStruct, sizeof(pXHClient->m_addStreamProxyStruct));
		memcpy((unsigned char*)&pXHClient->m_addStreamProxyStruct, (unsigned char*)&gb28181RecvProxy->m_addStreamProxyStruct, sizeof(gb28181RecvProxy->m_addStreamProxyStruct));
	}
	
2、更新是新视频帧速度不需要锁
	void   CMediaStreamSource::UpdateVideoFrameSpeed(int nVideoSpeed,int netType)
	{
		//std::lock_guard<std::mutex> lock(mediaSendMapLock); 尝试注释，出现过卡住
		
3、rtmp代理拉流断开时，需要删除掉代理对象 		
   CNetClientRecvRtmp::~CNetClientRecvRtmp()
   {
	pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nClient, sizeof(nClient)); //从媒体拷贝线程、媒体发送线程移除掉Client  
	
	//直接把代理拉流删除
	pDisconnectBaseNetFifo.push((unsigned char*)&hParent, sizeof(hParent));
	malloc_trim(0);
  }
 
4、关闭国标收流时，需要先删除接收对象，再删除代理对象  
	if (pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy)
	{//国标代理
		if (pClient->nTcp_Switch == 0)//udp方式  删除国标接收对象即可
		   DeleteNetRevcBaseClient(pClient->nMediaClient); 
		else if (pClient->nTcp_Switch == 1)
		{//TCP方式 
			CNetGB28181Proxy* pNetGB28181Proxy = (CNetGB28181Proxy*)pClient.get();
			if (pNetGB28181Proxy != NULL)
				pNetGB28181Proxy->DeleteGBRecvClient();
		}
	}else

ABLMediaServer-2022-08-13【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、增加无人观看时间时长 noneReaderDuration 、getMediaList 函数也返回该字段 noneReaderDuration
	//无人观看消息,30秒中通知一次
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNoneReader > 0  && GetCurrentSecond() - nLastWatchTime >= ABL_MediaServerPort.noneReaderDuration)
	{
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientNoneReader);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"noneReaderDuration\":%d,\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%llu}", app,  stream, GetCurrentSecond() - nLastWatchTimeDisconect,ABL_MediaServerPort.mediaServerID, netBaseNetType,nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}

		nLastWatchTime = GetCurrentSecond();
	}
	
	if (tmpMediaSource->mediaSendMap.size() > 0)
		nNoneReadDuration = 0;
	else
		nNoneReadDuration = GetCurrentSecond() - tmpMediaSource->nLastWatchTimeDisconect;

ABLMediaServer-2022-08-10【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、尽量使用 GetNetRevcBaseClient 这个函数
   boost::shared_ptr<CNetRevcBase>  rtpClientPtr = GetNetRevcBaseClient(rtpClient);
   
2、在getMediaList 函数中 采用有锁的 GetMediaStreamSource(szShareMediaURL) 函数 
	//获取媒体源
	int GetAllMediaStreamSource(char* szMediaSourceInfo, getMediaListStruct mediaListStruct)
	{
	    boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);
		
3、Http请求合法性检测，抓拍成功后，请求jpg图片是合法的

	//响应http请求
	bool CNetServerHTTP::ResponseHttpRequest(char* szModem, char* httpURL, char* requestParam)
	{
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu  , szModem = %s ，httpURL = %s", this, nClient, szModem, httpURL);

		//url 请求合法性简单判断,发现有一些乱七八糟的请求发过来  .php .asp .html .htm .jars .zip .rar .exe .tar .tar.gz .7z .dll .bat
		if (strstr(httpURL, ".php") != NULL  || strstr(httpURL, ".asp") != NULL || strstr(httpURL, ".html") != NULL || strstr(httpURL, ".htm") != NULL ||
			strstr(httpURL, ".jars") != NULL || strstr(httpURL, ".zip") != NULL || strstr(httpURL, ".rar") != NULL || strstr(httpURL, ".exe") != NULL ||
			strstr(httpURL, ".tar") != NULL  || strstr(httpURL, ".tar.gz") != NULL || strstr(httpURL, ".7z") != NULL || strstr(httpURL, ".dll") != NULL ||
			strstr(httpURL, ".bat") != NULL  || strstr(httpURL, ".txt") != NULL || strstr(httpURL, ".ico") != NULL  )
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http 请求非法的文件 ，httpURL = %s", this, nClient, httpURL);
			DeleteNetRevcBaseClient(nClient);
			return false ;
		}
		
4、事件通知增加一个变量，从fifo拷贝给这个变量，再回复 	
	int CNetClientHttp::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(NetClientHTTPLock);

		netDataCache[netDataCacheLength] = 0x00;
		nNetStart = nNetEnd = netDataCacheLength = 0;

		unsigned char* pData = NULL;
		int            nLength = 0;

		if ((pData = m_videoFifo.pop(&nLength)) != NULL && strlen(szResponseURL) > 0 )
		{
			memset(szResponseData, 0x00, sizeof(szResponseData));
			memcpy(szResponseData, pData, nLength);

			if (netBaseNetType == NetBaseNetType_HttpClient_None_reader)
				HttpRequest(szResponseURL, szResponseData, nLength);
	 
			else
				HttpRequest(szResponseURL, (char*)pData, nLength);

			m_videoFifo.pop_front();
		}

		return 0;
	}
	
ABLMediaServer-2022-08-08【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、在 closeRtpServer 函数中 采用无锁查找对象 GetNetRevcBaseClientNoLock，先关闭国标收流对象，在释放代理对象 

	boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClientNoLock(atoi(m_delRequestStruct.key));
	if (pClient == NULL)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key %s Not Found .\"}", IndexApiCode_KeyNotFound, m_delRequestStruct.key, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}
	else
	{
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 删除Key %s 成功 ", this, nClient, m_delRequestStruct.key);
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"success\"}", IndexApiCode_OK);

		nDelKey = atoi(m_delRequestStruct.key);
		pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nDelKey, sizeof(nDelKey));

		if (pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy)
		{//国标代理
			DeleteNetRevcBaseClient(pClient->nMediaClient);//删除国标接收对象即可，
		}else
 		    DeleteNetRevcBaseClient(nDelKey);//以最快速度删除

		ResponseSuccess(szResponseBody);
		return true;
	}


ABLMediaServer-2022-08-06【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、closeRtpServer 函数，先关闭接收对象，在关闭代理对象 
    1）、在代理对象中，记下国标接收对象 
		if (gb28181RecvProxy != NULL)
		{//把国标代理的信息拷贝个国标TCP
			gb28181RecvProxy->nMediaClient = CltHandle;//国标代理TCP接收句柄号

	2）、先关闭接收对象 
		if (pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy)
		{//国标代理
			DeleteNetRevcBaseClient(pClient->nMediaClient);//删除国标接收对象即可，
		}else
			DeleteNetRevcBaseClient(nDelKey);//以最快速度删除

ABLMediaServer-2022-08-05【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、CNetServerHTTP_FLV、CNetServerWS_FLV 的 删除 pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient)); 全部更换为
   DeleteNetRevcBaseClient(nClient);

2、发送媒体数据之前 ，确保先更新视频帧速度 
   if (!bUpdateVideoSpeed)
	  return -1;
	  
3、在国标代理拉流析构，注释掉 XHNetSDK_DestoryUdp(nMediaClient);	  
	CNetGB28181Proxy::~CNetGB28181Proxy()
	{
		if (nNetGB28181ProxyType == NetGB28181ProxyType_RecvStream)
		{
			int nTcp_Switch = atoi(m_openRtpServerStruct.enable_tcp);

			if (nTcp_Switch == 0)
			{
				XHNetSDK_DestoryUdp(nMediaClient);
				pDisconnectBaseNetFifo.push((unsigned char*)&nMediaClient,sizeof(nMediaClient));

ABLMediaServer-2022-08-03【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、H265的fmp4切片，创建切片条件 if (H265Params.width == 0 && H265Params.height == 0) 修改为 if (track_265 < 0 )
   否则切片句柄资源无法创建，不知道啥时候修改了H265Params 这个结构的宽、高 
	bool  CMediaStreamSource::H265FrameToFMP4File(unsigned char* szVideoData, int nLength)
	{
		if (track_265 < 0 )
		{

2、在单端口10000 的TS、PS 流接入时指定码流接入的网络类型 
	pMediaSource->netBaseNetType = NetBaseNetType_NetGB28181UDPPSStreamInput;//指定为PS流接入
	pMediaSource->netBaseNetType = NetBaseNetType_NetGB28181UDPTSStreamInput;//指定为TS流接入

ABLMediaServer-2022-08-02【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、删除掉国标接入增加的一个条件限制，造成TCP方式接收码流，可能会丢失一包数据帧，造成rtp解包失败 
	int CNetGB28181RtpServer::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength, void* address)
	{
		std::lock_guard<std::mutex> lock(netDataLock);
		if (pData == NULL || nDataLength <= 12)
			return -1;


ABLMediaServer-2022-07-29【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、国标单端口接入，rtp包头不在拷贝，只赋值，提高效率  rtpHeadPtr = (_rtp_header*)pData; 
	int CNetServerRecvRtpTS_PS::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength, void* address)
	{
		if (nDataLength <= 12 || pData == NULL  )
			return -1;//非法数据

		rtpHeadPtr = (_rtp_header*)pData;
		rtpClient = BaseRecvRtpSSRCNumber + rtpHeadPtr->ssrc;
		if (rtpHeadPtr->v != 2)
			return -1;//不是rtp包

		if (rtpClientPtr != NULL)
		{
			if (rtpClientPtr->nSSRC == 0)
				rtpClientPtr->nSSRC = rtpHeadPtr->ssrc; //默认第一个ssrc 
			if (rtpClientPtr->nSSRC == rtpHeadPtr->ssrc)
				rtpClientPtr->InputNetData(nServerHandle, nClientHandle, pData, nDataLength,address);
		}

		return 0;
	}

2、国标TCP方式接收，增加rtp包头判断，防止rtcp码流数据进行rtp解包，故需要增加条件判断 rtpHeadPtr->v == 2
	//获取rtp包的包头
	rtpHeadPtr = (_rtp_header*)(netDataCache + nNetStart);

	nRtpLength = ntohs(nRtpLength);
	if (nRtpLength > 65536 )
	{
		WriteLog(Log_Debug, "CNetGB28181RtpServer = %X rtp包头长度有误  nClient = %llu ,nRtpLength = %llu", this, nClient, nRtpLength);
		DeleteNetRevcBaseClient(nClient);
		return -1;
	}

	//长度合法 并且是rtp包 （rtpHeadPtr->v == 2) ,防止rtcp数据执行rtp解包
	if(nRtpLength > 0 && rtpHeadPtr->v == 2)
		RtpDepacket(netDataCache + nNetStart, nRtpLength);


3、国标tcp方式回复rtcp包，根据接收的方式进行回复rtcp包，有2个字节，4个字节方式
	void  CNetGB28181RtpServer::ProcessRtcpData(unsigned char* szRtcpData, int nDataLength, int nChan)
	{
		if (netBaseNetType != NetBaseNetType_NetGB28181RtpServerTCP_Server)
			return;

		if (nRtpRtcpPacketType == 1)
		{//2字节方式
			unsigned short nRtpLen = htons(nDataLength);
			memcpy(szRtcpDataOverTCP, (unsigned char*)&nRtpLen, sizeof(nRtpLen));

			memcpy(szRtcpDataOverTCP + 2, szRtcpData, nDataLength);
			XHNetSDK_Write(nClient, szRtcpDataOverTCP, nDataLength + 2 , 1);
		}
		else if (nRtpRtcpPacketType == 2)
		{//4
		  szRtcpDataOverTCP[0] = '$';
		  szRtcpDataOverTCP[1] = nChan;
		  unsigned short nRtpLen = htons(nDataLength);
		  memcpy(szRtcpDataOverTCP + 2, (unsigned char*)&nRtpLen, sizeof(nRtpLen));

		  memcpy(szRtcpDataOverTCP + 4, szRtcpData, nDataLength);
		  XHNetSDK_Write(nClient, szRtcpDataOverTCP, nDataLength + 4, 1);
		}
	}

4、代理拉流打印出Describe 的回复信息
	  
	if (nDataLength < 1024)
		WriteLog(Log_Debug, "Describe Response nClient = %llu \r\n%s \r\n",nClient, pRecvData);

	
ABLMediaServer-2022-07-27【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、url 请求合法性简单判断,发现有一些乱七八糟的请求发过来，需要立即断开连接，不处理 
	if (strstr(httpURL, ".php") != NULL  || strstr(httpURL, ".asp") != NULL || strstr(httpURL, ".html") != NULL || strstr(httpURL, ".htm") != NULL ||
		strstr(httpURL, ".jars") != NULL || strstr(httpURL, ".zip") != NULL || strstr(httpURL, ".rar") != NULL || strstr(httpURL, ".exe") != NULL ||
		strstr(httpURL, ".tar") != NULL  || strstr(httpURL, ".tar.gz") != NULL || strstr(httpURL, ".7z") != NULL || strstr(httpURL, ".dll") != NULL ||
		strstr(httpURL, ".bat") != NULL  || strstr(httpURL, ".txt") != NULL )
	{
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http 请求非法的文件 ，httpURL = %s", this, nClient, httpURL);
  		DeleteNetRevcBaseClient(nClient);
		return false ;
	}

ABLMediaServer-2022-07-25【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、合并山东-周小哥 支持单路视频水印功能 
	bool CFFVideoEncode::ChangeVideoFilter(char *filterText, int fontSize, char *fontColor, float fontAlpha, int fontLeft, int fontTop)
	{
		std::lock_guard<std::mutex> lock(enable_Lock);

		enableFilter = false;
		std::string tmpText(filterText);

		//此时不考虑全局水印是否启用
		if (tmpText.empty())
			return false;

		if (videoFilter)
			SAFE_DELETE(videoFilter);

		videoFilter = new CFFVideoFilter;
		videoFilter->waterMarkText = tmpText;
		videoFilter->nFilterFontSize = fontSize;
		strncpy(videoFilter->nFilterFontColor, fontColor, 64);
		videoFilter->nFilterFontAlpha = fontAlpha;
		videoFilter->nFilterFontLeft = fontLeft;
		videoFilter->nFilterFontTop = fontTop;

		videoFilter->StartFilter(m_nAVPixel, m_nWidth, m_nHeight, m_nFrameRate, videoFilter->nFilterFontSize, videoFilter->nFilterFontColor, videoFilter->nFilterFontAlpha, videoFilter->nFilterFontLeft, videoFilter->nFilterFontTop);
		enableFilter = true;
		WriteLog(Log_Debug, "HttpRequest ChangeVideoFilter");

		return true;
	}

2、增加对应流水印以及转码设置
	/*  add by ZXT 对应流水印以及转码设置
	url:http://127.0.0.1:7088/index/api/setTransFilter
	parm:
		{
		"secret":"035c73f7-bb6b-4889-a715-d9eb2d1925cc",
		"app" : "live",
		"stream" : "test",
		"text" : "ABL",
		"size" : 60,
		"color" : "red",
		"alpha" : 0.8,
		"left" : 40,
		"top" : 40,
		"trans" : 1
		}
	*/
	bool CNetServerHTTP::index_api_setTransFilter()
	{
		char secret[128] = { 0 };
		char app[128] = { 0 };
		char stream[128] = { 0 };
		char text[128] = { 0 };
		char size[32] = { 0 };
		char color[32] = { 0 };
		char alpha[32] = { 0 };
		char left[32] = { 0 };
		char top[32] = { 0 };
		char trans[32] = { 0 };

		GetKeyValue("secret", secret);
		GetKeyValue("app", app);
		GetKeyValue("stream", stream);
		GetKeyValue("text", text);
		GetKeyValue("size", size);
		GetKeyValue("color", color);
		GetKeyValue("alpha", alpha);
		GetKeyValue("left", left);
		GetKeyValue("top", top);
		GetKeyValue("trans", trans);

		if (strlen(secret) == 0 || strlen(app) == 0 || strlen(stream) == 0 || strlen(size) == 0 || strlen(color) == 0
			|| strlen(alpha) == 0 || strlen(left) == 0 || strlen(top) == 0 || strlen(trans) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\" parameter is not complete .\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strcmp(secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//检测 app stream 是否存在
		char szShareMediaURL[256] = { 0 };
		sprintf(szShareMediaURL, "/%s/%s", app, stream);
		boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);
		if (tmpMediaSource == NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s Not Found \"}", IndexApiCode_ParamError, szShareMediaURL);
			ResponseSuccess(szResponseBody);
			return false;
		}
		
		//检测是否开启转码功能 
		if (!(ABL_MediaServerPort.H265ConvertH264_enable == 1 && ABL_MediaServerPort.H264DecodeEncode_enable == 1 && ABL_MediaServerPort.filterVideo_enable == 1))
		{ 
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Transcoding 、VideoFilter has not been enabled . params [ H265ConvertH264_enable 、H264DecodeEncode_enable 、filterVideo_enable ] must be set 1 \"}", IndexApiCode_TranscodingVideoFilterNotEnable);
			ResponseSuccess(szResponseBody);
			return false;
		}
		
		//检测是转码功能是否已经生效
		if (!(tmpMediaSource->videoEncode.m_bInitFlag == true && tmpMediaSource->videoEncode.enableFilter == true))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Transcoding 、VideoFilter has not take effect . \"}", IndexApiCode_TranscodingVideoFilterTakeEffect);
			ResponseSuccess(szResponseBody);
			return false;
		}	

		//设置参数
		bool transFlag = atoi(trans);
		tmpMediaSource->H265ConvertH264_enable = transFlag;
		tmpMediaSource->globalH265ConvertH264_enable = transFlag;
		//转码优先级高，如果关闭转码则水印失效; 转码打开，水印文本为空也水印失效
		if (transFlag)
		{
			if(text[0] != '\0')
				tmpMediaSource->globalH264DecodeEncode_enable = 1;

			tmpMediaSource->videoEncode.ChangeVideoFilter(text, atoi(size), color, atof(alpha), atoi(left), atoi(top));
		}
	 
		sprintf(szResponseBody, "{\"code\":0,\"memo\":\"sucess\"}");
		ResponseSuccess(szResponseBody);
		return true;
	}

3、计算视频码率
	if (GetTickCount64() - nCalcBitrateTimestamp >= 10000)
	{
		nCalcBitrateTimestamp = GetTickCount64();
		m_mediaCodecInfo.nVideoBitrate = nVideoBitrate / 1000;
		m_mediaCodecInfo.nAudioBitrate = nAudioBitrate / 1000;
		nVideoBitrate = 0;
		nAudioBitrate = 0;
	}
	nVideoBitrate += nLength;

4、在获取http请求的json参数时，优化对数字类型的获取，否则会奔溃 
	else if (nType == kNumberType)
	{
		//Mod by ZXT
		if(jValue.IsDouble())
			sprintf(szValue, "%.2f", jValue.GetFloat());
		else
			sprintf(szValue, "%llu", jValue.GetInt64());
	}

5、国标tcp方式接收时，增加主动回复rtcp包
	//TCP方式发送rtcp包
	void  CNetGB28181RtpServer::ProcessRtcpData(unsigned char* szRtcpData, int nDataLength, int nChan)
	{
		if (netBaseNetType != NetBaseNetType_NetGB28181RtpServerTCP_Server)
			return;

		szRtcpDataOverTCP[0] = '$';
		szRtcpDataOverTCP[1] = nChan;
		unsigned short nRtpLen = htons(nDataLength);
		memcpy(szRtcpDataOverTCP + 2, (unsigned char*)&nRtpLen, sizeof(nRtpLen));

		memcpy(szRtcpDataOverTCP + 4, szRtcpData, nDataLength);
		XHNetSDK_Write(nClient, szRtcpDataOverTCP, nDataLength + 4, 1);
	}
	
	//主动发送rtcp 包
	if (GetTickCount64() - nSendRtcpTime >= 5 * 1000)
	{
		nSendRtcpTime = ::GetTickCount64();

		memset(szRtcpSRBuffer, 0x00, sizeof(szRtcpSRBuffer));
		rtcpSRBufferLength = sizeof(szRtcpSRBuffer);
		rtcpRR.BuildRtcpPacket(szRtcpSRBuffer, rtcpSRBufferLength, nSSRC);

		ProcessRtcpData(szRtcpSRBuffer, rtcpSRBufferLength, 1);
	}	
	
ABLMediaServer-2022-07-24【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、 媒体断线时通知，需要视频媒体达到才会通知 加上条件 strlen((*iterator1).second->m_mediaCodecInfo.szVideoName) > 0 
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientDisconnect > 0 && strlen((*iterator1).second->m_mediaCodecInfo.szVideoName) > 0 )
	{
		char szJson[512] = { 0 };
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClientNoLock(ABL_MediaServerPort.nClientDisconnect);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%llu}",(*iterator1).second->app, (*iterator1).second->stream, ABL_MediaServerPort.mediaServerID, (*iterator1).second->netBaseNetType, (*iterator1).second->nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}
	
2、代理拉流失败时 ，返回代理拉流父句柄号 ，请求方可以通过这个父句柄彻底删除代理拉流	
	sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"%s\",\"key\":%llu}", IndexApiCode_ConnectFail," [app、stream] Error", hParent);
	ResponseHttp(nClient_http, szResponseBody, false);


ABLMediaServer-2022-07-23【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、支持自定义事件通知的response 的 url on_stream_arrive=http://192.168.1.168:7188/index/hook/on_stream_arrive32
	string strResponeURL = szClientIP;
	int nPos = 0;
	nPos = strResponeURL.find("/", 10);
	if (nPos > 0)
	{
		memset(szResponseURL, 0x00, sizeof(szResponseURL));
		memcpy(szResponseURL, szClientIP + nPos, strlen(szClientIP) - nPos);
	}
	
2、读取配置文件去掉空格
	char* CConfigFile::ReadConfigString(LPCTSTR lpSection, LPCTSTR lpKey, LPCTSTR lpDefault)
	{
	   memset(lpBuff,0x00,sizeof(lpBuff)) ;

	   ::GetPrivateProfileString(lpSection,lpKey,"@#$%^*&",lpBuff,sizeof(lpBuff),m_ConfigFileName) ;
	   if(memcmp(lpBuff,szKey,7) == 0)
	   {
		  return (char*)lpDefault  ;
	   }
	   else
	   {
		   string strConfig = lpBuff ;
		   boost::trim(strConfig);
		   memset(lpBuff, 0x00, sizeof(lpBuff));
		   strcpy(lpBuff, strConfig.c_str());
		   return  (char*)lpBuff ;
		}
	}
	
	INI_RES CIni::GetKey(const char* mAttr, const char* cAttr, char* pValue)
	{
	 
	   KEYMAP mKey = m_Map[ mAttr ];
	 
	  string sTemp = mKey[ cAttr ];
	 
	  //去掉空格 
	  boost::trim(sTemp);

	  strcpy( pValue,sTemp.c_str() );
	 
	  return INI_SUCCESS;
	}


ABLMediaServer-2022-07-22【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、强制发送I帧，当有许多摄像头的gop设置为50，或者需要点播视频时快速的出画面，可以开启强制发送i帧。（默认关闭 ）
   ForceSendingIFrame=0

ABLMediaServer-2022-07-21【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、在主线程增加国标代理的码流是否到达的检测，如果在超时范围内码流没有到达，则进行关闭
	else if (((*iterator1).second)->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy && ((*iterator1).second)->bUpdateVideoFrameSpeedFlag == false )
	{//检测国标代理拉流 TCP、UDP 码流是否到达 
		if ((GetTickCount64() - ((*iterator1).second)->nCreateDateTime) >= (1000 * (ABL_MediaServerPort.MaxDiconnectTimeoutSecond / 2)))
		{//在超时的时间范围内，码流尚未到达 
			WriteLog(Log_Debug, "国标接收超时 nClient = %llu , app = %s ,stream = %s , port = %s ", ((*iterator1).second)->nClient, ((*iterator1).second)->m_openRtpServerStruct.app, ((*iterator1).second)->m_openRtpServerStruct.stream_id, ((*iterator1).second)->m_openRtpServerStruct.port);
			pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof((unsigned char*)&((*iterator1).second)->nClient));
		}
	}

2、在国标TCP、UDP接收中，把代理对象的 bUpdateVideoFrameSpeedFlag 设置为 true  
	//不管UDP、TCP都设置为码流已经到达 
	boost::shared_ptr<CNetRevcBase>  pGB28181Proxy = GetNetRevcBaseClient(pThis->hParent);
	if (pGB28181Proxy != NULL)
		pGB28181Proxy->bUpdateVideoFrameSpeedFlag = true;
		
3、新增加一个代理拉流、国标接收码流没有达到的消息通知对象 
   if (ABL_MediaServerPort.nClientNotArrive == 0 && strlen(ABL_MediaServerPort.on_stream_not_arrive) > 0)
	  CreateNetRevcBaseClient(NetBaseNetType_HttpClient_on_stream_not_arrive, 0, 0, ABL_MediaServerPort.on_stream_not_arrive, 0, "");

4、在代理拉流、国标接收码流没有达到时，发送通知消息 
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNotArrive > 0 && bUpdateVideoFrameSpeedFlag == false )
	{ 
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClientNoLock(ABL_MediaServerPort.nClientNotArrive);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%llu}", m_openRtpServerStruct.app, m_openRtpServerStruct.stream_id, ABL_MediaServerPort.mediaServerID, netBaseNetType, nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}
		
ABLMediaServer-2022-07-20【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1 把断线检测时间长缩短至8 ~ 10 秒 
  #define  MaxRecvDataTimerBySecondDiconnect  4             //最大10秒没数据，即执行删除

2、如果码流到达，找出国标代理拉流对象，把 bUpdateVideoFrameSpeedFlag 赋值为 true ,证明国标下级码流到达 

	boost::shared_ptr<CNetRevcBase>  pParent = GetNetRevcBaseClient(pThis->hParent); 
	if (pParent != NULL)
		pParent->bUpdateVideoFrameSpeedFlag = true; //证明码流达到过 
 
3、 简单、快速检测 flv ws-flv ,mp4 请求时的扩展名一定要对，否则立即删除该连接对象。 因为发送有些网络
    环境中有胡乱的网络请求发过来 
	
	//根据FLV文件，进行简单判断是否合法
	if (!(strstr(szFlvName, ".flv") != NULL || strstr(szFlvName, ".FLV") != NULL))
	{
		WriteLog(Log_Debug, "CNetServerHTTP_FLV = %X,  nClient = %llu , 请求的名字非法 %s ", this, nClient, szFlvName);
		DeleteNetRevcBaseClient(nClient);
		return -1;
	}
	
	//根据FLV文件，进行简单判断是否合法
	if (!(strstr(szFlvName, ".flv") != NULL || strstr(szFlvName, ".FLV") != NULL))
	{
		WriteLog(Log_Debug, "CNetServerWS_FLV = %X,  nClient = %llu , 请求的名字非法 %s ", this, nClient, szFlvName);
		DeleteNetRevcBaseClient(nClient);
		return -1;
	}
	
	//根据mp4文件，进行简单判断是否合法
	if (!(strstr(szMP4Name, ".mp4") != NULL || strstr(szMP4Name, ".MP4") != NULL))
	{
		WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X,  nClient = %llu , 请求的名字非法 %s ", this, nClient, szMP4Name);
		DeleteNetRevcBaseClient(nClient);
		return -1;
	}
	


ABLMediaServer-2022-07-19【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、获取系统配置，增加服务器IP地址，增加国标单端口 
	bool CNetServerHTTP::index_api_getServerConfig()
	{
		memset((char*)&m_getServerConfigStruct, 0x00, sizeof(m_getServerConfigStruct));

		GetKeyValue("secret", m_getServerConfigStruct.secret);
	 
		if (strcmp(m_getServerConfigStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, MaxMediaSourceInfoLength);
		sprintf(szMediaSourceInfoBuffer, "{\"code\":0,\"params\":[{\"secret\":\"%s\",\"memo\":\"server password\"},{\"ServerIP\":\"%s\",\"memo\":\"ABLMediaServer ip address\"},{\"mediaServerID\":\"%s\",\"memo\":\"media Server ID \"},{\"hook_enable\":%d,\"memo\":\"hook_enable = 1 open notice , hook_enable = 0 close notice \"},{\"enable_audio\":%d,\"memo\":\"enable_audio = 1 open Audio , enable_audio = 0 Close Audio \"},{\"httpServerPort\":%d,\"memo\":\"http api port \"},{\"rtspPort\":%d,\"memo\":\"rtsp port \"},{\"rtmpPort\":%d,\"memo\":\"rtmp port \"},{\"httpFlvPort\":%d,\"memo\":\"http-flv port \"},{\"hls_enable\":%d,\"memo\":\"hls whether enable \"},{\"hlsPort\":%d,\"memo\":\"hls port\"},{\"wsPort\":%d,\"memo\":\"websocket flv port\"},{\"mp4Port\":%d,\"memo\":\"http mp4 port\"},{\"ps_tsRecvPort\":%d,\"memo\":\"recv ts , ps Stream port \"},{\"hlsCutType\":%d,\"memo\":\"hlsCutType = 1 hls cut to Harddisk,hlsCutType = 2  hls cut Media to memory\"},{\"h265CutType\":%d,\"memo\":\" 1 h265 cut TS , 2 cut fmp4 \"},{\"RecvThreadCount\":%d,\"memo\":\" RecvThreadCount \"},{\"SendThreadCount\":%d,\"memo\":\"SendThreadCount\"},{\"GB28181RtpTCPHeadType\":%d,\"memo\":\"rtp Length Type\"},{\"ReConnectingCount\":%d,\"memo\":\"Try reconnections times .\"},{\"maxTimeNoOneWatch\":%d,\"memo\":\"maxTimeNoOneWatch .\"},{\"pushEnable_mp4\":%d,\"memo\":\"pushEnable_mp4 .\"},{\"fileSecond\":%d,\"memo\":\"fileSecond .\"},{\"fileKeepMaxTime\":%d,\"memo\":\"fileKeepMaxTime .\"},{\"httpDownloadSpeed\":%d,\"memo\":\"httpDownloadSpeed .\"},{\"RecordReplayThread\":%d,\"memo\":\"Total number of video playback threads .\"}]}", 
			ABL_MediaServerPort.secret, ABL_MediaServerPort.ABL_szLocalIP, ABL_MediaServerPort.mediaServerID, ABL_MediaServerPort.hook_enable,ABL_MediaServerPort.nEnableAudio,ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nRtspPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nWSFlvPort, ABL_MediaServerPort.nHttpMp4Port, ABL_MediaServerPort.ps_tsRecvPort, ABL_MediaServerPort.nHLSCutType, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nGBRtpTCPHeadType, ABL_MediaServerPort.nReConnectingCount,
			ABL_MediaServerPort.maxTimeNoOneWatch, ABL_MediaServerPort.pushEnable_mp4,ABL_MediaServerPort.fileSecond,ABL_MediaServerPort.fileKeepMaxTime,ABL_MediaServerPort.httpDownloadSpeed, ABL_MediaServerPort.nRecordReplayThread);
		ResponseSuccess(szMediaSourceInfoBuffer);

		return true;
	}
	
2、国标rtp接收时，确保只认第一个ssrc 	
	//获取第一个ssrc 
	if (nSSRC == 0 && pData != NULL &&  nDataLength > sizeof(rtpHeader) )
	{
		rtpHeaderPtr = (_rtp_header*)pData;
		nSSRC = rtpHeaderPtr->ssrc;
	}else 
		rtpHeaderPtr = (_rtp_header*)pData;
		
	if (strcmp(inet_ntoa(pRtpAddress->sin_addr), inet_ntoa(((sockaddr_in*)address)->sin_addr)) == 0 &&  //IP 相同
		ntohs(pRtpAddress->sin_port) - 1 == ntohs(((sockaddr_in*)address)->sin_port)  &&  //端口相同
		nSSRC == rtpHeaderPtr->ssrc  // ssrc 相同 
	)
	 NetDataFifo.push((unsigned char*)pData, nDataLength);		
			 
ABLMediaServer-2022-07-17【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、水印filter 对象需要在 CFFVideoEncode 的构造函数赋值为NULL，否则在析构时删除空指针
	CFFVideoEncode::CFFVideoEncode()
	{
		m_bInitFlag = false;
		videoFilter = NULL;
		WriteLog(Log_Debug, "CFFVideoEncode 构造函数 = %X 创建编码器成功 line= %d ", this, __LINE__);
	}
	
	//停止，在析构函数中调用 
	bool  CFFVideoEncode::StopEncode()
	{
		std::lock_guard<std::mutex> lock(enable_Lock);
		if (m_bInitFlag)
		 {
		   av_packet_unref(&pkt);
		   av_frame_free(&pFrame);
		   av_free(picture_buf);
		   avcodec_free_context(&pCodecCtx);

		   SAFE_DELETE(videoFilter);
		   m_bInitFlag = false ;
		 }

		return true;
	}

2、在代理拉流，收到 404 回复时，不能删除 代理拉流对象，只需要删除 rtsp拉流对象即可。 nClient
		//从SDP中获取视频、音频格式信息 
		if (!GetMediaInfoFromRtspSDP())
		{
			sprintf(szResponseBuffer, "RTSP/1.0 415 Unsupport Media Type\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
			nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
            
			WriteLog(Log_Debug, "RtspProcessStep_DESCRIBE 返回 \r\n%s", pRecvData);
			WriteLog(Log_Debug, "ANNOUNCE SDP 信息中没有合法的媒体数据 %s ", szRtspContentSDP);
			
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"%s\",\"key\":%d}",IndexApiCode_ConnectFail,pRecvData, 0);
		    ResponseHttp(nClient_http,szResponseBody,false );
	
			DeleteNetRevcBaseClient(nClient);
			return ;
		}

3、在收到 TEARDOWN 立即执行删除 		
	else if (memcmp(pRecvData, "TEARDOWN", 8) == 0 && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
	{
		WriteLog(Log_Debug, "收到断开 TEARDOWN 命令，立即执行删除 nClient = %llu ", nClient);
		bRunFlag = false;
		DeleteNetRevcBaseClient(nClient);
	}

4、在连接失败重连的地方 答复代理拉流 
	else
	{
		sprintf(((*iterator1).second)->szResponseBody, "{\"code\":%d,\"memo\":\"Network Connnect[ %s ] Timeout .\",\"key\":%d}", IndexApiCode_ConnectTimeout, ((*iterator1).second)->m_addStreamProxyStruct.url, 0);
		((*iterator1).second)->ResponseHttp(((*iterator1).second)->nClient_http, ((*iterator1).second)->szResponseBody, false);

		WriteLog(Log_Debug, "nClient = %llu , nMediaClient = %llu 检测到网络异常断开2 , %s ，现在执行第 %llu 次重连  ", ((*iterator1).second)->nClient, ((*iterator1).second)->nMediaClient,((*iterator1).second)->m_addStreamProxyStruct.url, ((*iterator1).second)->nReConnectingCount);
		pReConnectStreamProxyFifo.push((unsigned char*)&((*iterator1).second)->nClient,sizeof(((*iterator1).second)->nClient));
	}


ABLMediaServer-2022-07-16【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、更新liux版本的 rtpDecode
2、更新Linux版本的 Makefile 
3、在接收TS推流时，增加AAC声音，加入媒体源 
	if (PSI_STREAM_AAC == avtype || PSI_STREAM_AUDIO_OPUS == avtype)
	{
		len = mpeg4_aac_adts_frame_length((const uint8_t*)data, bytes);
		while (len > 7 && (size_t)len <= bytes)
		{
			if(pThis->aacInfo.channels == 0)
				mpeg4_aac_adts_load((unsigned char*)data, len, &pThis->aacInfo);

			count ++;
			if(pThis->aacInfo.channels > 0 && pThis->aacInfo.sampling_frequency_index >= 0 && pThis->aacInfo.sampling_frequency_index <= 12)
			  pThis->pMediaSource->PushAudio((unsigned char*)data, len, "AAC", pThis->aacInfo.channels, avpriv_mpeg4audio_sample_rates[pThis->aacInfo.sampling_frequency_index]);

			bytes -= len;
			data = (const uint8_t*)data + len;
			len = mpeg4_aac_adts_frame_length((const uint8_t*)data, bytes);
		}
	}else if (PSI_STREAM_AUDIO_G711A == avtype)
	
4、在许多复用、解复用的回调函数中 增加 如下的条件限制，解决各个类在销毁时 回调函数中造成的奔溃问题。
	if (!pThis->bRunFlag)
	  return -1;
	
ABLMediaServer-2022-07-13【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、增加检查SSRC是否已经使用
	bool  CheckSSRCAlreadyUsed(int nSSRC, bool bLockFlag)
	{
		if (bLockFlag)
			std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		bool                 bRet = false;
		CNetRevcBase_ptr     pClient = NULL;

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			if ((pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpUDP || pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect) &&
				atoi(pClient->m_startSendRtpStruct.ssrc) == nSSRC
				)
			{//已经占用了 nPort;
				bRet = true;
				break;
			}
		}
		WriteLog(Log_Debug, "CheckSSRCAlreadyUsed() bRet = %d  ", bRet);
		return bRet;
	}

	//检测ssrc 是否使用
	if ( CheckSSRCAlreadyUsed(atoi(m_startSendRtpStruct.ssrc), true) == true)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"ssrc error: %s Already used .\",\"key\":%d}", IndexApiCode_SSRClreadyUsed, m_startSendRtpStruct.ssrc, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}

ABLMediaServer-2022-07-12【合并 山东-周小哥 的水印功能、增加国标单端口10000 接入 】
1、增加CRtpTSStreamInput、CRtpPSStreamInput 两个类库
	else if (netClientType == NetBaseNetType_NetGB28181UDPTSStreamInput)
	{//TS 解包形成媒体源
		pXHClient = boost::make_shared<CRtpTSStreamInput>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient;
	}
	else if (netClientType == NetBaseNetType_NetGB28181UDPPSStreamInput)
	{//PS 解包形成媒体源
		pXHClient = boost::make_shared<CRtpPSStreamInput>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient;
	}

2、 在 10000 接收端口，根据 00 00 01 BA 的数据来区分创建TS解包、PS解包 
	int CNetServerRecvRtpTS_PS::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength, void* address)
	{
		if (nDataLength < 12  )
			return -1;//非法数据

		memcpy((unsigned char*)&rtpHead, (unsigned char*)pData, sizeof(_rtp_header));
		rtpClient = BaseRecvRtpSSRCNumber + rtpHead.ssrc;
		if (rtpHead.v != 2)
			return -1;//不是rtp包

		boost::shared_ptr<CNetRevcBase>  rtpClientPtr = GetNetRevcBaseClientNoLock(rtpClient);
		if (rtpClientPtr == NULL && address != NULL )
		{
			char szTemp[256] = { 0 };
			char szRtpSource[256] = { 0 };
			sprintf(szTemp, "/rtp/%X", rtpHead.ssrc);
			sprintf(szRtpSource, "rtp://%s:%d", inet_ntoa(((sockaddr_in*)address)->sin_addr), ntohs(((sockaddr_in*)address)->sin_port));
			strcat(szRtpSource, szTemp);

			if(memcmp(pData + sizeof(rtpHead), psHeadFlag, 4) == 0)
			{//PS 
			   rtpClientPtr = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181UDPPSStreamInput, 0, rtpClient, szRtpSource, 10000, szTemp);
			}
			else
			{//TS
				rtpClientPtr = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181UDPTSStreamInput, 0, rtpClient, szRtpSource, 10000, szTemp);
			}
		}
		if (rtpClientPtr != NULL)
			rtpClientPtr->InputNetData(nServerHandle, nClientHandle, pData, nDataLength,address);

		return 0;
	}
	
ABLMediaServer-2022-07-09【合并 山东-周小哥 的水印功能】
1、把山东-周小哥的水印功能合并到主线版本

2、 查找 /app/stream 是否执行 openRtpServer 
	bool  CheckOpenRtpServer(char* app,char* stream, bool bLockFlag)
	{
		if (bLockFlag)
			std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		bool                 bRet = false ;
		CNetRevcBase_ptr   pClient = NULL;

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			if (pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy   && 
				strcmp(pClient->m_openRtpServerStruct.app,app) == 0             && 
				strcmp(pClient->m_openRtpServerStruct.stream_id, stream) == 0
			 )
			{//已经占用了 /app/stream ;
				bRet = true ;
				break;
			}
		}
		WriteLog(Log_Debug, "CheckOpenRtpServer() bRet = %d  ", bRet);
		return bRet;
	}


3 检查端口是否已经使用 
  	bool  CheckPortAlreadyUsed(int nPort,int nPortType, bool bLockFlag)
	{
		if (bLockFlag)
			std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		bool                 bRet = false;
		CNetRevcBase_ptr     pClient = NULL;

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			if (nPortType == 1)
			{
				if (pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy   &&
					atoi(pClient->m_openRtpServerStruct.port) == nPort
					)
				{//已经占用了 nPort;
					bRet = true;
					break;
				}
			}
			else if (nPortType == 2)
			{
				if (( pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpUDP || pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect) &&
					atoi(pClient->m_startSendRtpStruct.src_port) == nPort
					)
				{//已经占用了 nPort;
					bRet = true;
					break;
				}
			}
		}
		WriteLog(Log_Debug, "CheckPortAlreadyUsed() bRet = %d  ", bRet);
		return bRet;
	}

4、检查端口是否使用
	if (atoi(m_openRtpServerStruct.port) != 0 && CheckPortAlreadyUsed(atoi(m_openRtpServerStruct.port),1, true) == true)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"port error: %s Already used .\",\"key\":%d}", IndexApiCode_PortAlreadyUsed, m_openRtpServerStruct.port, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}

	//检查 /app/stream 是否已经使用 
	if (CheckOpenRtpServer(m_openRtpServerStruct.app, m_openRtpServerStruct.stream_id,true) == true)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"parameter error: /%s/%s Already used .\",\"key\":%d}", IndexApiCode_AppStreamAlreadyUsed, m_openRtpServerStruct.app, m_openRtpServerStruct.stream_id, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}


ABLMediaServer-2022-07-08【兼容海康新版本NVR】
1、在国标UDP方式接收PS时，只保证第一个地址的UDP数据加入PS解包，后面的都要丢弃 
	if (address && pRtpAddress)
	{//保证只认第一个IP、端口进来的PS码流 
	  if(strcmp(inet_ntoa(pRtpAddress->sin_addr),inet_ntoa(((sockaddr_in*)address)->sin_addr)) == 0 && ntohs(pRtpAddress->sin_port) - 1  == ntohs(((sockaddr_in*)address)->sin_port) )
		 NetDataFifo.push((unsigned char*)pData, nDataLength);
	}

2、限制国标TCP方式，同一个端口只允许一个连接进来 
	int      nAcceptNumvber;
	if (GetNetServerTypeByHandle(serverHandle, szMediaSource,hParent, nAcceptNumvber) == NetServerHandleType_GB28181RecvStream)
	{//国标TCP方式接收码流
		if (nAcceptNumvber >= 3)
		{
			WriteLog(Log_Debug, "CreateNetRevcBaseClient() 该端口的国标接收已经有连接 szMediaSource = %s ,nAcceptNumvber = %d", szMediaSource, nAcceptNumvber);
			return NULL;
		}

	创建对象失败，理解删除网络连接 
	if(CreateNetRevcBaseClient(NetRevcBaseClient_ServerAccept,srvhandle, clihandle, temp,nPort,"") == NULL)
	   XHNetSDK_Disconnect(clihandle);

3、增加国标单端口接收
	else if (netClientType == NetBaseNetType_NetGB28181RecvRtpPS_TS)
	{//单端口接收国标 
		pXHClient = boost::make_shared<CNetServerRecvRtpTS_PS>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient; 
	}

ABLMediaServer-2022-06-29【兼容海康新版本NVR】
1、在处理任务线程完全退出前，执行销毁所有对象 
  	FillNetRevcBaseClientFifo();//把所有对象装入链表，准备删除

	while ((pData = pDisconnectBaseNetFifo.pop(&nLength)) != NULL)
	{
		if (nLength == sizeof(nClient))
		{
			memcpy((char*)&nClient, pData, sizeof(nClient));
			if (nClient >= 0)
			{
				DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
				pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
				XHNetSDK_Disconnect(nClient);
				DeleteNetRevcBaseClient(nClient);//执行删除 
			}
		}

		pDisconnectBaseNetFifo.pop_front();
		Sleep(5);
	}

ABLMediaServer-2022-06-2７【兼容海康新版本NVR】
１、代理推流，如果推流地址已经存在，有时候收不到错误信息客户端就断开了，所有需要在ｒｔｓｐ推流对象断开时检测是否推流成功，
　　如果推流失败，需要回复ｈｔｔｐ推流失败
	bool  DeleteNetRevcBaseClient(NETHANDLE CltHandle)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;

		iterator1 = xh_ABLNetRevcBaseMap.find(CltHandle);
		if (iterator1 != xh_ABLNetRevcBaseMap.end())
		{
			if ((*iterator1).second->netBaseNetType == NetBaseNetType_RtspClientPush && (*iterator1).second->nRtspProcessStep != RtspProcessStep_RECORD)
			{//rtsp代理推流失败
				sprintf((*iterator1).second->szResponseBody, "{\"code\":%d,\"memo\":\"rtsp push Failed . Possible session already exitsts .\",\"key\":%d}", IndexApiCode_RtspSDPError, (*iterator1).second->hParent);
				(*iterator1).second->ResponseHttp((*iterator1).second->nClient_http, (*iterator1).second->szResponseBody, false);

				pDisconnectBaseNetFifo.push((unsigned char*)&(*iterator1).second->hParent, sizeof((*iterator1).second->hParent));
			}

			xh_ABLNetRevcBaseMap.erase(iterator1);
			return true;
		}
		else
		{
			return false;
		}
	}

ABLMediaServer-2022-06-25【兼容海康新版本NVR】
1、onclose 核心函数处理代码恢复以前的代码 
	void LIBNET_CALLMETHOD	onclose(NETHANDLE srvhandle,
		NETHANDLE clihandle)
	{  
		WriteLog(Log_Debug, "onclose() nClient = %llu 客户端断开 srvhandle = %llu", clihandle, srvhandle);

		pMediaSendThreadPool->DeleteClientToThreadPool(clihandle);//移除发送线程 
		DeleteClientMediaStreamSource(clihandle);//移除媒体拷贝
		
		DeleteNetRevcBaseClient(clihandle);
	}
	
2、Http服务器返回的最大值 设置为6兆
   #define  MaxMediaSourceInfoLength    1024*1024*6   

3、Linux版本Makefile文件 链接的ffmppeg版本为 4.3.4 
	INCLUDES = -I../Linux/boost/include \
			   -I../Linux/ffmpeg-4.3.4/include \
			   -I../rapidjson-master/include \
			   -I../media-server-master/libflv/include \
			   -I../media-server-master/librtmp/include \
			   -I../media-server-master/libmpeg/include \
			   -I../media-server-master/libhls/include \
			   -I../media-server-master/librtp/include \
			   -I../media-server-master/libmov/include 
	LIBS = -L../bin \
		   -L../Linux/ffmpeg-4.3.4/lib \
		   -L../Linux/faac-1.29.9.2/lib/lib \
       -L../Linux/boost/lib -lboost_system -lboost_thread -lboost_log -lboost_regex -lboost_filesystem -lboost_date_time -lboost_chrono -lboost_atomic -lrtmp -lflv -lmpeg -lhls -lmov -lrtp -lfaac -lavcodec -lavutil -lavformat -lswscale -lavfilter -lswresample

ABLMediaServer-2022-06-24【兼容海康新版本NVR】
1、修改宽、高 还是要增加条件 (m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0) ,否则转码时候码流达到通知不了。 
	if (nConvertObjectCount < ABL_MediaServerPort.convertMaxObject && ABL_MediaServerPort.H265ConvertH264_enable == 1 )
	{//执行转码
 		if (!H265ConvertH264(szVideo, nLength, szVideoCodec))
			return false;
		if (H265ConvertH264_enable == true && (m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0) && !(m_mediaCodecInfo.nWidth == ABL_MediaServerPort.convertOutWidth && m_mediaCodecInfo.nHeight == ABL_MediaServerPort.convertOutHeight))
		{//更改宽，高 
			m_mediaCodecInfo.nWidth = ABL_MediaServerPort.convertOutWidth;
			m_mediaCodecInfo.nHeight = ABL_MediaServerPort.convertOutHeight;
		}
	}
	else if (H265ConvertH264_enable == true)
	{//已经成功分配到转码资源的
		if (!H265ConvertH264(szVideo, nLength, szVideoCodec))
			return false;
		if ((m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0) && !(m_mediaCodecInfo.nWidth == ABL_MediaServerPort.convertOutWidth && m_mediaCodecInfo.nHeight == ABL_MediaServerPort.convertOutHeight))
		{//更改宽，高 
			m_mediaCodecInfo.nWidth = ABL_MediaServerPort.convertOutWidth;
			m_mediaCodecInfo.nHeight = ABL_MediaServerPort.convertOutHeight;
		}
	}

 2、在服务退出前，销毁掉所有对象 
	1) 把所有对象装入链表，准备删除 
	int  FillNetRevcBaseClientFifo()
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		int                nCount = 0;
		CNetRevcBase_ptr   pClient = NULL;

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
		}
		return nCount;
	}
	
	2) 在任务退出前销毁掉所有对象 
	while ((pData = pDisconnectBaseNetFifo.pop(&nLength)) != NULL)
	{
		if (nLength == sizeof(nClient))
		{
			memcpy((char*)&nClient, pData, sizeof(nClient));
			if (nClient >= 0)
			{
				DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
				pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
				DeleteNetRevcBaseClient(nClient);//执行删除 
			}
		}

		pDisconnectBaseNetFifo.pop_front();
		Sleep(5);
	}

	任务处理完全退出 
	ABL_bExitMediaServerRunFlag = true;

3、切片时间可以自定义３　～　１０秒，自定义参数为　ABL_MediaServerPort.hlsCutTime　修正HLS切片时长的描述　
　　
　　ｍ３ｕ８文件头描述　
	if (tsPacketHandle != NULL && (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0 || (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 1)))
	  sprintf(szH264TempBuffer, "#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:%d\n#EXT-X-MEDIA-SEQUENCE:%d\n#EXT-X-ALLOW-CACHE:NO\n", ABL_MediaServerPort.hlsCutTime, m3u8FileOrder);
	else if (hlsFMP4 != NULL && strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 2)
	  sprintf(szH264TempBuffer, "#EXTM3U\n#EXT-X-VERSION:7\n#EXT-X-TARGETDURATION:%d\n#EXT-X-MEDIA-SEQUENCE:%d\n#EXT-X-ALLOW-CACHE:NO\n#EXT-X-MAP:URI=\"%s/0.mp4\",\n", ABL_MediaServerPort.hlsCutTime, m3u8FileOrder, szTSFileSubPath);
				
　　每个ｔｓ文件时间长度　				
　　sprintf(szH264TempBuffer, "#EXTINF:%d.000,\n%s/%s\n", ABL_MediaServerPort.hlsCutTime, szTSFileSubPath, szOutputName);
	
ABLMediaServer-2022-06-23【兼容海康新版本NVR】
1、修改转码后的宽、高需要增加个条件 H265ConvertH264_enable == true  
	if (nConvertObjectCount < ABL_MediaServerPort.convertMaxObject && ABL_MediaServerPort.H265ConvertH264_enable == 1 )
	{//执行转码
 		if (!H265ConvertH264(szVideo, nLength, szVideoCodec))
			return false;
		if (H265ConvertH264_enable == true && !(m_mediaCodecInfo.nWidth == ABL_MediaServerPort.convertOutWidth && m_mediaCodecInfo.nHeight == ABL_MediaServerPort.convertOutHeight))
		{//更改宽，高 
			m_mediaCodecInfo.nWidth = ABL_MediaServerPort.convertOutWidth;
			m_mediaCodecInfo.nHeight = ABL_MediaServerPort.convertOutHeight;
		}
	}

2、在有一些类的析构函数增加 malloc_trim(0); 比如 CNetClientHttp 类 
	CNetClientHttp::~CNetClientHttp()
	{
		std::lock_guard<std::mutex> lock(NetClientHTTPLock);

		switch (netBaseNetType)
		{
			case NetBaseNetType_HttpClient_None_reader:
				 ABL_MediaServerPort.nClientNoneReader = 0;
				break;
			case NetBaseNetType_HttpClient_Not_found:
				 ABL_MediaServerPort.nClientNotFound = 0;
				break;
			case NetBaseNetType_HttpClient_Record_mp4:
				 ABL_MediaServerPort.nClientRecordMp4 = 0;
				break;
			case NetBaseNetType_HttpClient_on_stream_arrive:
				ABL_MediaServerPort.nClientArrive = 0;
				break;
			case NetBaseNetType_HttpClient_on_stream_disconnect:
				ABL_MediaServerPort.nClientDisconnect = 0;
				break;
			case NetBaseNetType_HttpClient_on_record_ts:
				ABL_MediaServerPort.nClientRecordTS = 0;
				break;
		}

		m_videoFifo.FreeFifo();

		XHNetSDK_Disconnect(nClient);

		WriteLog(Log_Debug, "CNetClientHttp 析构 = %X nClient = %llu ,nMediaClient = %llu\r\n", this, nClient, nMediaClient);
		malloc_trim(0);
	}

ABLMediaServer-2022-06-22【兼容海康新版本NVR】
1、视频转码时，分配的内存不需要那么大，
   pOutEncodeBuffer = new unsigned char[((ABL_MediaServerPort.convertOutWidth * ABL_MediaServerPort.convertOutHeight) * 3)/2];
  
2、优化媒体转换的分配资源问题，当超过转码路数时，需要不改变媒体格式输出
	if (nConvertObjectCount < ABL_MediaServerPort.convertMaxObject && ABL_MediaServerPort.H265ConvertH264_enable == 1 )
	{//执行转码
 		if (!H265ConvertH264(szVideo, nLength, szVideoCodec))
			return false;
	}
	else if (H265ConvertH264_enable == true)
	{//已经成功分配到转码资源的
		if (!H265ConvertH264(szVideo, nLength, szVideoCodec))
			return false;
	}
	else if (H265ConvertH264_enable == false)
	{//没有分配到转码资源的，需要恢复原来的媒体格式 
		strcpy(m_mediaCodecInfo.szVideoName, szVideoCodec);
	}
3、修改宽高
	if (!(m_mediaCodecInfo.nWidth == ABL_MediaServerPort.convertOutWidth && m_mediaCodecInfo.nHeight == ABL_MediaServerPort.convertOutHeight))
	{//更改宽，高 
		m_mediaCodecInfo.nWidth = ABL_MediaServerPort.convertOutWidth;
		m_mediaCodecInfo.nHeight = ABL_MediaServerPort.convertOutHeight;
	}

4、TS切片完成通知
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientRecordTS > 0 )
	{//切片完毕一个TS文件通知
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClientNoLock(ABL_MediaServerPort.nClientRecordTS);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%d,\"fileName\":\"%s\"}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType, nClient, szHookTSFileName);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}


ABLMediaServer-2022-06-19【兼容海康新版本NVR】
1、给分发对象拷贝媒体数据时，需要等待I帧数据 
	if (H265ConvertH264_enable)
	{
		if (pClient->m_bSendMediaWaitForIFrame == false)
		{//尚未等待I帧
			if (CheckVideoIsIFrame(m_mediaCodecInfo.szVideoName, pOutEncodeBuffer, nOutLength))
				pClient->m_bSendMediaWaitForIFrame = true;
		}
		if(pClient->m_bSendMediaWaitForIFrame)
		  pClient->PushVideo(pOutEncodeBuffer, nOutLength,m_mediaCodecInfo.szVideoName);
	}
	else
	{
		if (pClient->m_bSendMediaWaitForIFrame == false)
		{//尚未等待I帧
			if (CheckVideoIsIFrame(m_mediaCodecInfo.szVideoName, szVideo, nLength))
				pClient->m_bSendMediaWaitForIFrame = true;
		}
		if (pClient->m_bSendMediaWaitForIFrame)
		  pClient->PushVideo(szVideo, nLength,m_mediaCodecInfo.szVideoName);
	}
ABLMediaServer-2022-06-18【兼容海康新版本NVR】
1、检测消息通知模块优化，修改为判断连接号是否为0 即可，如果等于0 证明已经已经断开  
	 
	void CreateHttpClientFunc()
	{
		if (ABL_MediaServerPort.nClientNoneReader == 0 && strlen(ABL_MediaServerPort.on_stream_none_reader) > 0 )
			 CreateNetRevcBaseClient(NetBaseNetType_HttpClient_None_reader, 0, 0, ABL_MediaServerPort.on_stream_none_reader, 0, "");
		
		if(ABL_MediaServerPort.nClientNotFound == 0 && strlen(ABL_MediaServerPort.on_stream_not_found) > 0 )
			CreateNetRevcBaseClient(NetBaseNetType_HttpClient_Not_found, 0, 0, ABL_MediaServerPort.on_stream_not_found, 0, "");

		if (ABL_MediaServerPort.nClientRecordMp4 == 0 && strlen(ABL_MediaServerPort.on_record_mp4) > 0 )
			CreateNetRevcBaseClient(NetBaseNetType_HttpClient_Record_mp4, 0, 0, ABL_MediaServerPort.on_record_mp4, 0, "");

		if (ABL_MediaServerPort.nClientArrive == 0 && strlen(ABL_MediaServerPort.on_stream_arrive) > 0 )
			CreateNetRevcBaseClient(NetBaseNetType_HttpClient_on_stream_arrive, 0, 0, ABL_MediaServerPort.on_stream_arrive, 0, "");

		if (ABL_MediaServerPort.nClientDisconnect == 0 && strlen(ABL_MediaServerPort.on_stream_disconnect) > 0 )
			CreateNetRevcBaseClient(NetBaseNetType_HttpClient_on_stream_disconnect, 0, 0, ABL_MediaServerPort.on_stream_disconnect, 0, "");

		if (ABL_MediaServerPort.nClientrRecconectMax == 0 && strlen(ABL_MediaServerPort.on_reconnect_maxcount) > 0 )
			CreateNetRevcBaseClient(NetBaseNetType_HttpClient_on_reconnect_maxcount, 0, 0, ABL_MediaServerPort.on_reconnect_maxcount, 0, "");
 	}

2、消息发送线程修改为投递方式，在 PutVideo 函数 加入通知消息后，再投递线程，请求执行 

    1)、加入通知消息后，再投递线程，请求执行 
	int CNetClientHttp::PushVideo(uint8_t* pVideoData, uint32_t nDataLength, char* szVideoCodec)
	{
		std::lock_guard<std::mutex> lock(NetClientHTTPLock);

		m_videoFifo.push(pVideoData, nDataLength);

		//加入线程池，请求执行
		MessageSendThreadPool->InsertIntoTask(nClient);

		return 0;
	}

    2、线程池执行
	int CNetClientHttp::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(NetClientHTTPLock);

		netDataCache[netDataCacheLength] = 0x00;
		WriteLog(Log_Debug, "CNetClientHttp = %X nClient = %llu 收到数据\r\n%s", this, nClient, netDataCache);

		nNetStart = nNetEnd = netDataCacheLength = 0;

		unsigned char* pData = NULL;
		int            nLength = 0;

		if ((pData = m_videoFifo.pop(&nLength)) != NULL)
		{
			if (netBaseNetType == NetBaseNetType_HttpClient_None_reader)
				HttpRequest("/index/hook/on_stream_none_reader", (char*)pData, nLength);
			else if (netBaseNetType == NetBaseNetType_HttpClient_Not_found)
				HttpRequest("/index/hook/on_stream_not_found", (char*)pData, nLength);
			else if (netBaseNetType == NetBaseNetType_HttpClient_Record_mp4)
				HttpRequest("/index/hook/on_record_mp4", (char*)pData, nLength);
			else if (netBaseNetType == NetBaseNetType_HttpClient_on_stream_arrive)
				HttpRequest("/index/hook/on_stream_arrive", (char*)pData, nLength);
			else if (netBaseNetType == NetBaseNetType_HttpClient_on_stream_disconnect)
				HttpRequest("/index/hook/on_stream_disconnect", (char*)pData, nLength);
			else if (netBaseNetType == NetBaseNetType_HttpClient_on_reconnect_maxcount)
				HttpRequest("/index/hook/on_reconnect_maxcount", (char*)pData, nLength);

			m_videoFifo.pop_front();
		}

		return 0;
	}

3、要删除掉 把转码输出的宽、高修改为媒体源的宽、高，否则码流达到通知不了，让 GetVideoWidthHeight 去调用获取，里面有码流达到通知功能 
	//修改媒体源的宽、高 
	if (nCudaDecodeChan > 0)
	{
		m_mediaCodecInfo.nWidth = ABL_MediaServerPort.convertOutWidth;
		m_mediaCodecInfo.nHeight = ABL_MediaServerPort.convertOutHeight;
	}

4、给分发对象拷贝媒体数据时，需要等待I帧数据 
	if (H265ConvertH264_enable)
	{
		if (pClient->m_bSendMediaWaitForIFrame == false)
		{//尚未等待I帧
			if (CheckVideoIsIFrame(m_mediaCodecInfo.szVideoName, pOutEncodeBuffer, nOutLength))
				pClient->m_bSendMediaWaitForIFrame = true;
		}
		if(pClient->m_bSendMediaWaitForIFrame)
		  pClient->PushVideo(pOutEncodeBuffer, nOutLength,m_mediaCodecInfo.szVideoName);
	}
	else
	{
		if (pClient->m_bSendMediaWaitForIFrame == false)
		{//尚未等待I帧
			if (CheckVideoIsIFrame(m_mediaCodecInfo.szVideoName, szVideo, nLength))
				pClient->m_bSendMediaWaitForIFrame = true;
		}
		if (pClient->m_bSendMediaWaitForIFrame)
		  pClient->PushVideo(szVideo, nLength,m_mediaCodecInfo.szVideoName);
	}

ABLMediaServer-2022-06-17【兼容海康新版本NVR】
1、端口绑定是否成功修改为多行方式
	WriteLog(Log_Debug, (nBindHttp == 0) ? "绑定端口 %d 成功(success) ":"绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nHttpServerPort);
	WriteLog(Log_Debug, (nBindRtsp == 0) ? "绑定端口 %d 成功(success)  " : "绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nRtspPort);
	WriteLog(Log_Debug, (nBindRtmp == 0) ? "绑定端口 %d 成功(success)  " : "绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nRtmpPort);
	WriteLog(Log_Debug, (nBindWsFlv == 0) ? "绑定端口 %d 成功(success)  " : "绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nWSFlvPort);
	WriteLog(Log_Debug, (nBindHttpFlv == 0) ? "绑定端口 %d 成功(success)  " : "绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nHttpFlvPort);
	WriteLog(Log_Debug, (nBindHls == 0) ? "绑定端口 %d 成功(success)  " : "绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nHlsPort);
	WriteLog(Log_Debug, (nBindMp4 == 0) ? "绑定端口 %d 成功(success)  " : "绑定端口 %d 失败(fail) ", ABL_MediaServerPort.nHttpMp4Port);

2 解码、编码都设置多线程 
   pCodecCtx->slice_count = 4;
   pCodecCtx->thread_count = 4;


ABLMediaServer-2022-06-16【兼容海康新版本NVR】
1、获取宽、高等等函数增加参数  char* szVideoCodecName
    bool  CMediaStreamSource::CheckVideoIsIFrame(char* szVideoCodecName, unsigned char* szPVideoData, int nPVideoLength)
    unsigned  int  CMediaStreamSource::FindSpsPosition(char* szVideoCodeName, unsigned char* szVideoBuffer, int nBufferLength, bool &bFind)
    bool  CMediaStreamSource::GetVideoWidthHeight(char* szVideoCodeName, unsigned char* pVideoData, int nDataLength)

2、 开启转码后，把输出的宽、高修改媒体源的宽、高 
	if (nCudaDecodeChan > 0)
	{
		m_mediaCodecInfo.nWidth = ABL_MediaServerPort.convertOutWidth;
		m_mediaCodecInfo.nHeight = ABL_MediaServerPort.convertOutHeight;
	}

ABLMediaServer-2022-06-15【兼容海康新版本NVR】
1、支持英伟达显卡硬件解码
	if (ABL_MediaServerPort.H265ConvertH264_enable == 1  && ABL_MediaServerPort.H256DecodeCpuGpuType == 1)
	{///英伟达
		if (strstr(pD3DName.Description, "GeForce") != NULL || strstr(pD3DName.Description, "NVIDIA") != NULL)
		{//英伟达显卡硬编码
			hCudaDecodeInstance = ::LoadLibrary("cudaCodecDLL.dll");
			if (hCudaDecodeInstance != NULL)
			{
				cudaEncode_Init = (ABL_cudaDecode_Init)::GetProcAddress(hCudaDecodeInstance, "cudaCodec_Init");
				cudaEncode_GetDeviceGetCount = (ABL_cudaDecode_GetDeviceGetCount) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_GetDeviceGetCount");
				cudaEncode_GetDeviceName = (ABL_cudaDecode_GetDeviceName) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_GetDeviceName");
				cudaDecode_GetDeviceUse = (ABL_cudaDecode_GetDeviceUse) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_GetDeviceUse");
				cudaCreateVideoDecode = (ABL_CreateVideoDecode) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_CreateVideoDecode");
				cudaVideoDecode = (ABL_CudaVideoDecode) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_CudaVideoDecode");

				cudaDeleteVideoDecode = (ABL_DeleteVideoDecode) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_DeleteVideoDecode");
				getCudaDecodeCount = (ABL_GetCudaDecodeCount) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_GetCudaDecodeCount");
				cudaVideoDecodeUnInit = (ABL_VideoDecodeUnInit) ::GetProcAddress(hCudaDecodeInstance, "cudaCodec_UnInit");

			}
			if (cudaEncode_Init)
				ABL_bCudaFlag = cudaEncode_Init();
			if (cudaEncode_GetDeviceGetCount)
				ABL_nCudaCount = cudaEncode_GetDeviceGetCount();

			if(ABL_bCudaFlag == false || ABL_nCudaCount <= 0)
				ABL_MediaServerPort.H256DecodeCpuGpuType = 0; //恢复cpu软解
			else
			    WriteLog(Log_Debug, "测试英伟达显卡 ABL_bCudaFlag = %d, 英伟达显卡总数 : %d  ", ABL_bCudaFlag, ABL_nCudaCount);
		}
		else
			ABL_MediaServerPort.H256DecodeCpuGpuType = 0; //恢复cpu软解
	}
	else if (ABL_MediaServerPort.H265ConvertH264_enable == 1 && ABL_MediaServerPort.H256DecodeCpuGpuType == 2 )
	{//amd 
		ABL_MediaServerPort.H256DecodeCpuGpuType = 0; //恢复cpu软解
	}

2、	英伟达显卡硬解码、转码 
	else if (ABL_MediaServerPort.H256DecodeCpuGpuType == 1)
	{//cuda硬解
#ifdef OS_System_Windows 
		if (nCudaDecodeChan == 0)
		{
			//if (CheckVideoIsIFrame(szVideo, nLength))
			{
			  if(strcmp(szVideoCodec,"H264") == 0 )
 		        cudaCreateVideoDecode(cudaCodecVideo_H264, cudaCodecVideo_YV12, 1920, 1080, nCudaDecodeChan);
			  else if (strcmp(szVideoCodec, "H265") == 0)
				cudaCreateVideoDecode(cudaCodecVideo_HEVC, cudaCodecVideo_YV12, 1920, 1080, nCudaDecodeChan);
 		    }
 		}
		 
		if (nCudaDecodeChan > 0)
		{
			pCudaDecodeYUVFrame = cudaVideoDecode(nCudaDecodeChan, szVideo, nLength, nCudaDecodeFrameCount, nCudeDecodeOutLength);
			if (nCudeDecodeOutLength > 0)
			{
				if (!avFrameSWS.bInitFlag && ABL_MediaServerPort.convertOutWidth > 0 && ABL_MediaServerPort.convertOutHeight > 0 )
				{
 					avFrameSWS.CreateAVFrameSws(true,(AVPixelFormat)AV_PIX_FMT_YUV420P, 1920, 1080, AV_PIX_FMT_YUV420P, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, SWS_BICUBIC);
 				}

				if (avFrameSWS.bInitFlag)
				{
					if (!videoEncode.m_bInitFlag)
					{
						pOutEncodeBuffer = new unsigned char[1024 * 1024 * 2];
						if (videoEncode.StartEncode("libx264", AV_PIX_FMT_YUV420P, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, 25))
						{//libopenh264
							nConvertObjectCount++;
							H265ConvertH264_enable = true;
							WriteLog(Log_Debug, " CMediaStreamSource  = %X ,当前媒体流 /%s/%s 执行转码 ，共有 %d 路进行转码 ", this, app, stream, nConvertObjectCount);
						}
					}
				}

			   for (int i = 0; i < nCudaDecodeFrameCount; i++)
			   {
				  avFrameSWS.AVFrameSWSYUV(pCudaDecodeYUVFrame[i], nCudeDecodeOutLength);
 				  return videoEncode.EncodecYUV(avFrameSWS.szDestData, avFrameSWS.numBytes2, pOutEncodeBuffer, &nOutLength);
 			   }
			}
		}
#endif
    }

ABLMediaServer-2022-06-14【兼容海康新版本NVR】
1、代理拉流采用老陈的rtp解包库，视频回调后需要拼接 
	static int rtp_decode_packet(void* param, const void *packet, int bytes, uint32_t timestamp, int flags)
	{
		CNetClientRecvRtsp* pRtsp = (CNetClientRecvRtsp*)param;
		if (pRtsp == NULL )
			return -1;

		//如果rtp负载PS ，需要PS解包 ，海康NVR录像回放采用这样方式 
		if (pRtsp->nRtspRtpPayloadType == RtspRtpPayloadType_PS && pRtsp->psHandle > 0)
		{
			ps_demux_input(pRtsp->psHandle,(unsigned char*)packet,bytes);
			return 0 ;
		}
	  
		if (0 == strcmp("H264", pRtsp->szVideoName) || 0 == strcmp("H265", pRtsp->szVideoName))
		{
			if (MaxNetDataCacheBufferLength - pRtsp->cbVideoLength > (bytes + 4))
			{
				if (pRtsp->cbVideoTimestamp != 0 && pRtsp->cbVideoTimestamp != timestamp)
				{
					pRtsp->pMediaSource->PushVideo(pRtsp->szCallBackVideo, pRtsp->cbVideoLength, pRtsp->szVideoName);
					pRtsp->cbVideoLength = 0;
				}

				memcpy(pRtsp->szCallBackVideo + pRtsp->cbVideoLength, start_code, sizeof(start_code));
				pRtsp->cbVideoLength += 4;
				memcpy(pRtsp->szCallBackVideo + pRtsp->cbVideoLength, packet, bytes);
				pRtsp->cbVideoLength += bytes;
			}
			else
			{
				pRtsp->cbVideoLength = 0;
			}
			pRtsp->cbVideoTimestamp = timestamp ;
		} 

		return  0;
	}

2、为了考虑兼容性，h264 采用libx264 编码 
  if (videoEncode.StartEncode("libx264", AV_PIX_FMT_YUV420P, ABL_MediaServerPort.convertOutWidth, ABL_MediaServerPort.convertOutHeight, 25))

ABLMediaServer-2022-06-12【兼容海康新版本NVR】
1、更改Makefile 文件 

2、增加其他功能 
	# 把linux播放控制库代码备份同步到windows 【解决】
	# 设置老陈rtp长度，国标ps rtp解包 【 已解决 】
	# 更新linux平台网络库udp发送usleep（20）的代码及
		 编译好的链接库 【 已解决 】
	# 增加代理拉流控制函数，暂停、继续、倍速（1、2、
		 4、8、16）、拖动播放（支持两种方式）【 解决 】
	# 原因代理拉流参数增加url类型 1、实况 2、录像 （默
		 认），只有录像才能控制 【 已解决 】
	# 同步华为3800录像回放兼容代码到ABL 【 已解决 】
	# 收到华为退出命令执行删除代理拉流 【 已解决 】
	# 代理拉流暂停时，不能检测超时无流断开【 解决 】
	# 代理拉流重连次数已达用户设置次数通知 【 已解决 】
	# 修改拖动播放函数的参数，改为字符串方式，如果是
		整型就走ntp，如果是年月日就走clock海康录像形式
		
ABLMediaServer-2022-06-10【兼容海康新版本NVR】
1、在国标接收类中，把构造函数中创建媒体源移动到PS解包回调函数中 
	void PS_DEMUX_CALL_METHOD GB28181_RtpRecv_demux_callback(_ps_demux_cb* cb)
	{
		CNetGB28181RtpServer* pThis = (CNetGB28181RtpServer*)cb->userdata;
	 
		if (pThis && cb->streamtype == e_rtpdepkt_st_h264 || cb->streamtype == e_rtpdepkt_st_h265 ||
			cb->streamtype == e_rtpdepkt_st_mpeg4 || cb->streamtype == e_rtpdepkt_st_mjpeg)
		{
			if(pThis->pMediaSource == NULL)
				pThis->pMediaSource = CreateMediaStreamSource(pThis->m_szShareMediaURL, pThis->nClient, MediaSourceType_LiveMedia, 0);
	 
		}
		else if (pThis)
		{
			if (pThis->pMediaSource == NULL)
				pThis->pMediaSource = CreateMediaStreamSource(pThis->m_szShareMediaURL, pThis->nClient, MediaSourceType_LiveMedia, 0);
	 
		}
	}

2、	码流达到通知移动到宽、高检测出来后再通知 
	 
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientArrive > 0 && m_mediaCodecInfo.nWidth > 0 && m_mediaCodecInfo.nHeight > 0 )
	{//检测出宽、高再通知 
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientArrive);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%d}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType, nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}

ABLMediaServer-2022-06-09【兼容海康新版本NVR】
1、GetPictureFileSource 这函数加个标志，是否锁住 
	CPictureFileSource_ptr GetPictureFileSource(char* szShareURL,bool bLock )
	{
		if(bLock)
		   std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptrMap::iterator iterator1;
		CPictureFileSource_ptr   pPicture = NULL;

		iterator1 = xh_ABLPictureFileSourceMap.find(szShareURL);
		if (iterator1 != xh_ABLPictureFileSourceMap.end())
		{
			pPicture = (*iterator1).second;
			return pPicture;
		}
		else
		{
			return NULL;
		}
	}

ABLMediaServer-2022-06-08【兼容海康新版本NVR】
1、采用老陈的rtp解包库进行rtp解包
	static void* rtp_alloc(void* param, int bytes)
	{
		CNetClientRecvRtsp* pRtsp = (CNetClientRecvRtsp*)param;
		WriteLog(Log_Debug, "rtp_alloc() 分配 rtp 视频资源  ");

		return pRtsp->szCallBackVideo;
	}

	static void* rtp_alloc2(void* param, int bytes)
	{
		CNetClientRecvRtsp* pRtsp = (CNetClientRecvRtsp*)param;

		WriteLog(Log_Debug, "rtp_alloc2() 分配 rtp 音频资源  ");

		return pRtsp->szCallBackAudio;
	}


	static void rtp_free(void* param, void * packet)
	{

	}

	static int rtp_decode_packet(void* param, const void *packet, int bytes, uint32_t timestamp, int flags)
	{
		CNetClientRecvRtsp* pRtsp = (CNetClientRecvRtsp*)param;
		if (pRtsp == NULL )
			return -1;

		//如果rtp负载PS ，需要PS解包 ，海康NVR录像回放采用这样方式 
		if (pRtsp->nRtspRtpPayloadType == RtspRtpPayloadType_PS && pRtsp->psHandle > 0)
		{
			ps_demux_input(pRtsp->psHandle,(unsigned char*)packet,bytes);
			return 0 ;
		}
	  
		size_t size = 0;
		if (0 == strcmp("H264", pRtsp->szVideoName) || 0 == strcmp("H265", pRtsp->szVideoName))
		{
			size = 4;
			memcpy(pRtsp->szCallBackVideo + size, packet, bytes);
			size += bytes;

			pRtsp->pMediaSource->PushVideo(pRtsp->szCallBackVideo, size, pRtsp->szVideoName);
		} 

		return  0;
	}

	static int rtp_decode_packetAudio(void* param, const void *packet, int bytes, uint32_t timestamp, int flags)
	{
		CNetClientRecvRtsp* pRtsp = (CNetClientRecvRtsp*)param;
		if (pRtsp == NULL )
			return -1;

		size_t size = 0;
		if (0 == strcmp("mpeg4-generic", pRtsp->szSdpAudioName))
		{
			int len = bytes + 7;
			uint8_t profile = 2;
			uint8_t sampling_frequency_index = pRtsp->sample_index;
			uint8_t channel_configuration = pRtsp->nChannels;
			pRtsp->szCallBackAudio[0] = 0xFF; /* 12-syncword */
			pRtsp->szCallBackAudio[1] = 0xF0 /* 12-syncword */ | (0 << 3)/*1-ID*/ | (0x00 << 2) /*2-layer*/ | 0x01 /*1-protection_absent*/;
			pRtsp->szCallBackAudio[2] = ((profile - 1) << 6) | ((sampling_frequency_index & 0x0F) << 2) | ((channel_configuration >> 2) & 0x01);
			pRtsp->szCallBackAudio[3] = ((channel_configuration & 0x03) << 6) | ((len >> 11) & 0x03); /*0-original_copy*/ /*0-home*/ /*0-copyright_identification_bit*/ /*0-copyright_identification_start*/
			pRtsp->szCallBackAudio[4] = (uint8_t)(len >> 3);
			pRtsp->szCallBackAudio[5] = ((len & 0x07) << 5) | 0x1F;
			pRtsp->szCallBackAudio[6] = 0xFC | ((len / 1024) & 0x03);
			size = 7;
			memcpy(pRtsp->szCallBackAudio + size, packet, bytes);
			size += bytes;

			pRtsp->pMediaSource->PushAudio(pRtsp->szCallBackAudio, size, pRtsp->szAudioName, pRtsp->nChannels, pRtsp->nSampleRate);
		}
		else // g711a,g711u 
			pRtsp->pMediaSource->PushAudio((unsigned char*)packet, bytes, pRtsp->szAudioName, pRtsp->nChannels, pRtsp->nSampleRate);

		return  0;
	}
	
2、代理拉流增加 暂停、继续、倍速播放、拖动播放 等等功能
	//暂停
	bool CNetClientRecvRtsp::RtspPause()
	{
		if (bPauseFlag || nRtspProcessStep != RtspProcessStep_PLAYSucess || nClient <= 0 || m_nXHRtspURLType != XHRtspURLType_RecordPlay)
			return false;

		if (m_wwwType == WWW_Authenticate_None)
		{
			sprintf(szResponseBuffer, "PAUSE %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, CSeq, MediaServerVerson, szSessionID);
		}
		else if (m_wwwType == WWW_Authenticate_MD5)
		{
			Authenticator author;
			char*         szResponse;

			author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
			author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
			szResponse = (char*)author.computeDigestResponse("PAUSE", m_rtspStruct.szSrcRtspPullUrl); //要注意 uri ,有时候没有最后的 斜杠 /

			sprintf(szResponseBuffer, "PAUSE %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n\r\n", m_rtspStruct.szRtspURLTrim, CSeq, MediaServerVerson, szSessionID, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szSrcRtspPullUrl, szResponse);

			author.reclaimDigestResponse(szResponse);
		}
		else if (m_wwwType == WWW_Authenticate_Basic)
		{
			UserPasswordBase64(szBasic);
			sprintf(szResponseBuffer, "PAUSE %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Basic %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, CSeq, MediaServerVerson, szSessionID, szBasic);
		}

		XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		CSeq++;
		bPauseFlag = true;
		WriteLog(Log_Debug, "CNetClientRecvRtsp = %X,nClient = %d ,RtspPause() \r\n%s", this, nClient, szResponseBuffer);
		return true;
	}

	//继续
	bool CNetClientRecvRtsp::RtspResume()
	{
		if (!bPauseFlag || nRtspProcessStep != RtspProcessStep_PLAYSucess || nClient <= 0 || m_nXHRtspURLType != XHRtspURLType_RecordPlay)
			return false;

		if (m_wwwType == WWW_Authenticate_None)
		{
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, CSeq, MediaServerVerson, szSessionID);
		}
		else if (m_wwwType == WWW_Authenticate_MD5)
		{
			Authenticator author;
			char*         szResponse;

			author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
			author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
			szResponse = (char*)author.computeDigestResponse("PLAY", m_rtspStruct.szSrcRtspPullUrl); //要注意 uri ,有时候没有最后的 斜杠 /

			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n\r\n", m_rtspStruct.szRtspURLTrim, CSeq, MediaServerVerson, szSessionID, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szSrcRtspPullUrl, szResponse);

			author.reclaimDigestResponse(szResponse);
		}
		else if (m_wwwType == WWW_Authenticate_Basic)
		{
			UserPasswordBase64(szBasic);
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Basic %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, CSeq, MediaServerVerson, szSessionID, szBasic);
		}

		XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		CSeq++;
		bPauseFlag = false;
		WriteLog(Log_Debug, "CNetClientRecvRtsp = %X,nClient = %d ,RtspResume() \r\n%s", this, nClient, szResponseBuffer);
		return true;
	}

	//倍速播放
	bool  CNetClientRecvRtsp::RtspSpeed(int nSpeed)
	{
		if (nRtspProcessStep != RtspProcessStep_PLAYSucess || nClient <= 0 || m_nXHRtspURLType != XHRtspURLType_RecordPlay)
			return false;

		if (m_wwwType == WWW_Authenticate_None)
		{
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nScale: %d\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSpeed, CSeq, MediaServerVerson, szSessionID);
		}
		else if (m_wwwType == WWW_Authenticate_MD5)
		{
			Authenticator author;
			char*         szResponse;

			author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
			author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
			szResponse = (char*)author.computeDigestResponse("PLAY", m_rtspStruct.szSrcRtspPullUrl); //要注意 uri ,有时候没有最后的 斜杠 /

			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nScale: %d\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSpeed, CSeq, MediaServerVerson, szSessionID, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szSrcRtspPullUrl, szResponse);

			author.reclaimDigestResponse(szResponse);
		}
		else if (m_wwwType == WWW_Authenticate_Basic)
		{
			UserPasswordBase64(szBasic);
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nScale: %d\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Basic %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSpeed, CSeq, MediaServerVerson, szSessionID, szBasic);
		}

		XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		CSeq++;
		bPauseFlag = false;
		WriteLog(Log_Debug, "CNetClientRecvRtsp = %X,nClient = %d ,RtspSpeed() \r\n%s", this, nClient, szResponseBuffer);
		return true;
	}

	//拖动播放
	bool CNetClientRecvRtsp::RtspSeek(int64_t nSeekTime)
	{
		if (nRtspProcessStep != RtspProcessStep_PLAYSucess || nClient <= 0 || m_nXHRtspURLType != XHRtspURLType_RecordPlay)
			return false;

		if (m_wwwType == WWW_Authenticate_None)
		{
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nRange: npt=%d-0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSeekTime, CSeq, MediaServerVerson, szSessionID);
		}
		else if (m_wwwType == WWW_Authenticate_MD5)
		{
			Authenticator author;
			char*         szResponse;

			author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
			author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
			szResponse = (char*)author.computeDigestResponse("PLAY", m_rtspStruct.szSrcRtspPullUrl); //要注意 uri ,有时候没有最后的 斜杠 /

			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nRange: npt=%d-0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSeekTime, CSeq, MediaServerVerson, szSessionID, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szSrcRtspPullUrl, szResponse);

			author.reclaimDigestResponse(szResponse);
		}
		else if (m_wwwType == WWW_Authenticate_Basic)
		{
			UserPasswordBase64(szBasic);
			sprintf(szResponseBuffer, "PLAY %s RTSP/1.0\r\nRange: npt=%d-0\r\nCSeq: %d\r\nUser-Agent: %s\r\nSession: %s\r\nAuthorization: Basic %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, nSeekTime, CSeq, MediaServerVerson, szSessionID, szBasic);
		}

		XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		CSeq++;
		bPauseFlag = false;
		WriteLog(Log_Debug, "CNetClientRecvRtsp = %X, nClient = %d ,RtspSeek() \r\n%s", this, nClient, szResponseBuffer);
		return true;
	}

ABLMediaServer-2022-06-07【兼容海康新版本NVR】
1、解决删除对象的一个BUG，这BUG造成服务器卡死 
	//删除所有HTTP请求 
	bool  CNetServerHTTP::index_api_delRequest()
	{
		char szShareMediaURL[256] = { 0 };
	 
		boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient(atoi(m_delRequestStruct.key));
		if (pClient == NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key %s Not Found .\"}", IndexApiCode_KeyNotFound, m_delRequestStruct.key, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		else
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 删除Key %s 成功 ", this, nClient, m_delRequestStruct.key);
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"success\"}", IndexApiCode_OK);

			nDelKey = atoi(m_delRequestStruct.key);
			
			//DeleteClientMediaStreamSource(nClient);//移除媒体拷贝 在这里调用会造成卡死 
			//pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
			
			//把上面2行更换为 这行 
			pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nDelKey, sizeof(nDelKey));

			DeleteNetRevcBaseClient(nDelKey);//以最快速度删除

			ResponseSuccess(szResponseBody);
			return true;
		}
	}

2、移除拷贝线程、发送线程 采用加入链表的方法，不在回调函数进行 	
	void LIBNET_CALLMETHOD	onclose(NETHANDLE srvhandle,
		NETHANDLE clihandle)
	{  
		WriteLog(Log_Debug, "onclose() nClient = %llu 客户端断开 srvhandle = %llu", clihandle, srvhandle);

		//pMediaSendThreadPool->DeleteClientToThreadPool(clihandle);//移除发送线程 
		//DeleteClientMediaStreamSource(clihandle);//移除媒体拷贝
		
		//更换为 
	    pRemoveBaseNetFromThreadFifo.push((unsigned char*)&clihandle, sizeof(clihandle));

		DeleteNetRevcBaseClient(clihandle);
	}

	
3 、把http-flv ,ws-flv 请求的url中，如果有？这字符，把这字符后面的所有字符串去掉，包括？  

	//把请求的FLV文件读取出来
	char    szTempName[512] = { 0 };
	string  strHttpHead = (char*)netDataCache;
	int     nPos1, nPos2;
	nPos1 = strHttpHead.find("GET ", 0);
	if (nPos1 >= 0)
	{
		nPos2 = strHttpHead.find(" HTTP/", 0);
		if (nPos2 > 0)
		{
			bFindFlvNameFlag = true;
			memset(szTempName, 0x00, sizeof(szTempName));
			memcpy(szTempName, netDataCache + nPos1 + 4, nPos2 - nPos1 - 4);

			string strFlvName = szTempName;
			nPos2 = strFlvName.find("?", 0);
			if (nPos2 > 0)
			{//有？，需要去掉？后面的字符串 
				memset(szFlvName, 0x00, sizeof(szFlvName));
				memcpy(szFlvName, szTempName, nPos2);
			}
			else//没有？，直接拷贝 
				strcpy(szFlvName, szTempName);
			WriteLog(Log_Debug, "CNetServerHTTP_FLV=%X ,nClient = %llu ,拷贝出FLV 文件名字 %s ", this, nClient, szFlvName);
		}
	}

ABLMediaServer-2022-05-25【兼容海康新版本NVR】
1、国标TCP接收，忽略rtp通道号 0 ~ 3
2、国标TCP接收，rtp包长度支持超过1500


ABLMediaServer-2022-05-07【增加硬件加速转码】
1、启用软解，软编码

ABLMediaServer-2022-05-03【增加硬件加速转码】
1、增加4个参数 
	ABL_MediaServerPort.H265ConvertH264_enable = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "H265ConvertH264_enable", "1"));
	ABL_MediaServerPort.convertOutWidth = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "convertOutWidth", "7210"));
	ABL_MediaServerPort.convertOutHeight = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "convertOutHeight", "1480"));
	ABL_MediaServerPort.convertMaxObject = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "convertMaxObject", "214"));

ABLMediaServer-2022-04-29【增加视频解码， 图片抓拍，图片查询，图片下载】
1、增加抓拍输出宽、高参数
	int  snapOutPictureWidth;//抓拍输出宽
	int  snapOutPictureHeight;//抓拍输出高
	
	ABL_MediaServerPort.snapOutPictureWidth = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "snapOutPictureWidth", "0"));
	ABL_MediaServerPort.snapOutPictureHeight = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "snapOutPictureHeight", "0"));

	//防止用户乱填写
	if ((ABL_MediaServerPort.snapOutPictureWidth == 0 && ABL_MediaServerPort.snapOutPictureHeight != 0) || (ABL_MediaServerPort.snapOutPictureWidth != 0 && ABL_MediaServerPort.snapOutPictureHeight == 0))
		ABL_MediaServerPort.snapOutPictureWidth = ABL_MediaServerPort.snapOutPictureHeight = 0;
	if (ABL_MediaServerPort.snapOutPictureWidth > 1920)
		ABL_MediaServerPort.snapOutPictureWidth = 1920;
	if (ABL_MediaServerPort.snapOutPictureHeight > 1080)
		ABL_MediaServerPort.snapOutPictureHeight = 1080;

2  要指定 format = AV_PIX_FMT_YUV420P; 否则对 pFrameDest 进行mjpeg编码失败 
	pFrameDest->format = AV_PIX_FMT_YUV420P;

3、根据用户设置宽、高输出图片
  if (ABL_MediaServerPort.snapOutPictureWidth == 0 && ABL_MediaServerPort.snapOutPictureHeight == 0)
	{
	  m_outWidth  = m_nWidth;
	  m_outHeight = m_nHeight;
	}
	else
	{
		m_outWidth = ABL_MediaServerPort.snapOutPictureWidth;
		m_outHeight = ABL_MediaServerPort.snapOutPictureHeight;
		if (frameSWS == NULL)
		{
			frameSWS = new CAVFrameSWS;
			frameSWS->CreateAVFrameSws(AV_PIX_FMT_YUV420P, m_nWidth, m_nHeight, AV_PIX_FMT_YUV420P, m_outWidth, m_outHeight, SWS_BICUBIC);
		}
	}
	
	if (ABL_MediaServerPort.snapOutPictureWidth == 0 && ABL_MediaServerPort.snapOutPictureHeight == 0)
	  ret = avcodec_send_frame(pCodecCtx, pDPicture);
	else
	{
		if (frameSWS)
		{
			if (frameSWS->AVFrameSWS(pDPicture))
			{
 			  ret = avcodec_send_frame(pCodecCtx, frameSWS->pFrameDest);
			}
 		}
	}


ABLMediaServer-2022-04-28【增加视频解码， 图片抓拍，图片查询，图片下载】
1、增加抓拍对象最大生存时长，单位秒 ，并检测超过生存时长即被销毁掉 

    //定义
	int  snapObjectDuration;//抓拍对象最长生存时长，单位秒

    //读取
	((*iterator1).second)->netBaseNetType == NetBaseNetType_SnapPicture_JPEG  //对某一路码流进行抓拍

	//抓拍对象超过生存时长检测
	if (((*iterator1).second)->netBaseNetType == NetBaseNetType_SnapPicture_JPEG && (GetTickCount64() - ((*iterator1).second)->nPrintTime) >= 1000 * ABL_MediaServerPort.snapObjectDuration )
	{
		WriteLog(Log_Debug, "抓拍对象已经超过最长的生存时长 %d 秒 ,加入删除链表等待销毁，nClient = %llu ", ABL_MediaServerPort.snapObjectDuration,((*iterator1).second)->nClient);
		pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof(((*iterator1).second)->nClient));
	}

ABLMediaServer-2022-04-27【增加视频解码， 图片抓拍，图片查询，图片下载】
1、在基类增加暂停标志 ，当国标录像回放、rtsp回放处于暂停状态，不能强行关闭网络连接 
   定义
   volatile bool          m_bPauseFlag;//在录像回放时，是否暂停状态
 
   在基类默认就不是暂停 
   CNetRevcBase::CNetRevcBase()
   {
	  m_bPauseFlag = false;

   //超时判断 
   if (((*iterator1).second)->m_bPauseFlag == false && ((*iterator1).second)->nRecvDataTimerBySecond >= MaxRecvDataTimerBySecondDiconnect )
   {//不是国标回放暂停、也不是rtsp回放暂停
	   nDiconnectCount ++;
	   WriteLog(Log_Debug, "CheckNetRevcBaseClientDisconnect() nClient = %llu 检测到网络异常断开1 ", ((*iterator1).second)->nClient );

	   pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof((unsigned char*)&((*iterator1).second)->nClient));
   }

2、增加录像回放，录像下载完毕通知 ABL_ANNOUNCE_QUIT:2021
   //快速检测录像下载完毕
   if (((*iterator1).second)->nRecvDataTimerBySecond >= 2 && ((*iterator1).second)->netBaseNetType == NetBaseNetType_RtspServerSendPush && ((*iterator1).second)->m_bPauseFlag == false  && ((*iterator1).second)->nReplayClient > 0)
   {
	   char szQuitText[128] = { 0 };
	   strcpy(szQuitText, "ABL_ANNOUNCE_QUIT:2021");
	   sprintf(((*iterator1).second)->szReponseTemp, "ANNOUNCE RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nContent-Type: text/parameters\r\nContent-Length: %d\r\n\r\n%s", 8, MediaServerVerson,strlen(szQuitText),szQuitText);
	   WriteLog(Log_Debug, "CheckNetRevcBaseClientDisconnect() nClient = %llu 录像发送完毕", ((*iterator1).second)->nClient);
	   XHNetSDK_Write(((*iterator1).second)->nClient,(unsigned char*)((*iterator1).second)->szReponseTemp, strlen(((*iterator1).second)->szReponseTemp), 1);

	   pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof((unsigned char*)&((*iterator1).second)->nClient));
   }

3、根据ShareMediaURL、NetBaseNetType 查找对象 
	CNetRevcBase_ptr  GetNetRevcBaseClientByNetTypeShareMediaURL(NetBaseNetType netType,char* ShareMediaURL, bool bLockFlag)
	{
		if(bLockFlag)
		  std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		CNetRevcBase_ptr   pClient = NULL;

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			if (pClient->netBaseNetType == netType && strcmp(ShareMediaURL,pClient->m_szShareMediaURL) == 0)
			{
				WriteLog(Log_Debug, "GetNetRevcBaseClientByNetTypeShareMediaURL() netType = %d , nClient = %llu ", netType, pClient->nClient);
				return pClient;
			}
		}
		return  NULL ;
	}

4、修正http回复完成的变量 bResponseHttpFlag 赋值

   boost::shared_ptr<CNetRevcBase>  pClient = GetNetRevcBaseClientNoLock(nHttpClient);
	if (pClient == NULL)
 		return true;
	if (pClient->bResponseHttpFlag)
		return true;

5、修改统计正在抓拍的对象总数 
	if (pClient->netBaseNetType == netType && pClient->bSnapSuccessFlag == false )
	{//是抓拍对象，并且尚未抓拍成功
		nCount ++;
	}
		
ABLMediaServer-2022-04-26【增加视频解码， 图片抓拍，图片查询，图片下载】
1、#图片抓拍最大并发数量限制，意思说服务器最大允许多少路在同时进行抓拍，因为抓拍很消耗硬件资源，需要解码视频为YUV，再把YUV编码为JPEG图片，用户调大maxSameTimeSnap这个参数，看看服务器能否支撑的住大量并发抓拍，服务器CPU性能不同，这个参数也不同
    maxSameTimeSnap=16

	ABL_MediaServerPort.maxSameTimeSnap = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "maxSameTimeSnap", "16"));

2、查找某一个网络类型的对象总数
	int  GetNetRevcBaseClientCountByNetType(NetBaseNetType netType,bool nLockFlag)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		int                nCount = 0 ;
		CNetRevcBase_ptr   pClient = NULL;

		for(iterator1 = xh_ABLNetRevcBaseMap.begin();iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			if (pClient->netBaseNetType == netType)
			{
				nCount ++;
			}
		}
		WriteLog(Log_Debug, "GetNetRevcBaseClientCountByNetType() netType = %d , nCount = %d  ", netType,nCount );
		return nCount;
	}

3、	检测抓拍数量是否超过设定的数量
	int nCount = GetNetRevcBaseClientCountByNetType(NetBaseNetType_SnapPicture_JPEG,true);
	if (nCount >= ABL_MediaServerPort.maxSameTimeSnap)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"current snap count over maxSameTimeSnap %d \"}", IndexApiCode_OverMaxSameTimeSnap, nCount);
		ResponseSuccess(szResponseBody);
		return false;
	}

ABLMediaServer-2022-04-21【增加视频解码， 图片抓拍，图片查询，图片下载】
1、在回复Http-mp4的Htt 头时，也增加跨域访问字段 
	Access-Control-Allow-Credentials: true
	Access-Control-Allow-Origin: http://44.35.33.39 （从request 获取 Origin ）
	
    //实况点播，录像点播 
	sprintf(httpResponseData, "HTTP/1.1 200 OK\r\nAccess-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Origin: %s\r\nConnection: keep-alive\r\nContent-Type: video/mp4; charset=utf-8\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nServer: %s\r\n\r\n", szOrigin, MediaServerVerson);
	
	//录像下载
	sprintf(httpResponseData, "HTTP/1.1 200 OK\r\nAccess-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Origin: %s\r\nConnection: keep-alive\r\nContent-Type: video/mp4; charset=utf-8\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nContent-Length: %d\r\nServer: %s\r\n\r\n",szOrigin,nRecordFileSize, MediaServerVerson);

ABLMediaServer-2022-04-20【增加视频解码， 图片抓拍，图片查询，图片下载】
1、在http-flv 回复中完全拷贝ZLM的回复,主要增加 Access-Control-Allow-Credentials: true \ Access-Control-Allow-Origin: %s
	 2、ZLM 回复 	
		HTTP/1.1 200 OK
		Access-Control-Allow-Credentials: true
		Access-Control-Allow-Origin: http://44.35.33.39
		Connection: keep-alive
		Content-Type: video/x-flv; charset=utf-8
		Date: Wed, Apr 20 2022 10:04:31 GMT
		Keep-Alive: timeout=30, max=100
		Server: ZLMediaKit-5.0(build in Apr 20 2021 10:39:44)

		char szOrigin[256] = { 0 };
		flvParse.ParseSipString((char*)netDataCache);
		flvParse.GetFieldValue("Origin", szOrigin);
		if (strlen(szOrigin) == 0)
			strcpy(szOrigin, "*");

		sprintf(httpResponseData, "HTTP/1.1 200 OK\r\nAccess-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Origin: %s\r\nConnection: keep-alive\r\nContent-Type: video/x-flv; charset=utf-8\r\nDate: Wed, Apr 20 2022 10:04:31 GMT\r\nKeep-Alive: timeout=30, max=100\r\nServer: %s\r\n\r\n", szOrigin, MediaServerVerson);

ABLMediaServer-2022-04-19【增加视频解码， 图片抓拍，图片查询，图片下载】
1、在代理对象中，判断是否连接成功，需要加上 if (pParent != NULL) ，否则会出现空指针

		//判断是否成功过，如果尚未成功，则立即删除 ，如果成功过则无限次重连
		CNetRevcBase_ptr pParent = GetNetRevcBaseClientNoLock(pClient->hParent);
		if (pParent != NULL)
		{
		  if (pParent->bProxySuccessFlag == false)
			 pDisconnectBaseNetFifo.push((unsigned char*)&pClient->hParent, sizeof(pClient->hParent));
		}

2、删除所有HTTP请求 函数中，由于轮询太快，造成删除 /app/stream 可能出现慢几十毫秒 ，需要最快速度删除对象 
	 
	bool  CNetServerHTTP::index_api_delRequest()
	{
	
			else
			{
				WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 删除Key %s 成功 ", this, nClient, m_delRequestStruct.key);
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"success\"}", IndexApiCode_OK);

                //删除成功后再返回结果 
				nDelKey = atoi(m_delRequestStruct.key);
				DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
				pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
				DeleteNetRevcBaseClient(nDelKey);//以最快速度删除

				ResponseSuccess(szResponseBody);
				return true;
			}

	}


ABLMediaServer-2022-04-04【增加视频解码， 图片抓拍，图片查询，图片下载】
1、获取系统配置中，增加mediaServerID、hook_enable 两个参数
	
	bool CNetServerHTTP::index_api_getServerConfig()
	{
		memset((char*)&m_getServerConfigStruct, 0x00, sizeof(m_getServerConfigStruct));

		GetKeyValue("secret", m_getServerConfigStruct.secret);
	 
		if (strcmp(m_getServerConfigStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, MaxMediaSourceInfoLength);
		sprintf(szMediaSourceInfoBuffer, "{\"code\":0,\"params\":[{\"secret\":\"%s\",\"memo\":\"server password\"},{\"mediaServerID\":\"%s\",\"memo\":\"media Server ID \"},{\"hook_enable\":%d,\"memo\":\"hook_enable = 1 open notice , hook_enable = 0 close notice \"},{\"enable_audio\":%d,\"memo\":\"enable_audio = 1 open Audio , enable_audio = 0 Close Audio \"},{\"httpServerPort\":%d,\"memo\":\"http api port \"},{\"rtspPort\":%d,\"memo\":\"rtsp port \"},{\"rtmpPort\":%d,\"memo\":\"rtmp port \"},{\"httpFlvPort\":%d,\"memo\":\"http-flv port \"},{\"hls_enable\":%d,\"memo\":\"hls whether enable \"},{\"hlsPort\":%d,\"memo\":\"hls port\"},{\"wsPort\":%d,\"memo\":\"websocket flv port\"},{\"mp4Port\":%d,\"memo\":\"http mp4 port\"},{\"hlsCutType\":%d,\"memo\":\"hlsCutType = 1 hls cut to Harddisk,hlsCutType = 2  hls cut Media to memory\"},{\"h265CutType\":%d,\"memo\":\" 1 h265 cut TS , 2 cut fmp4 \"},{\"RecvThreadCount\":%d,\"memo\":\" RecvThreadCount \"},{\"SendThreadCount\":%d,\"memo\":\"SendThreadCount\"},{\"GB28181RtpTCPHeadType\":%d,\"memo\":\"rtp Length Type\"},{\"ReConnectingCount\":%d,\"memo\":\"Try reconnections times .\"},{\"maxTimeNoOneWatch\":%d,\"memo\":\"maxTimeNoOneWatch .\"},{\"pushEnable_mp4\":%d,\"memo\":\"pushEnable_mp4 .\"},{\"fileSecond\":%d,\"memo\":\"fileSecond .\"},{\"fileKeepMaxTime\":%d,\"memo\":\"fileKeepMaxTime .\"},{\"httpDownloadSpeed\":%d,\"memo\":\"httpDownloadSpeed .\"},{\"RecordReplayThread\":%d,\"memo\":\"Total number of video playback threads .\"}]}", 
			ABL_MediaServerPort.secret, ABL_MediaServerPort.mediaServerID, ABL_MediaServerPort.hook_enable,ABL_MediaServerPort.nEnableAudio,ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nRtspPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nWSFlvPort, ABL_MediaServerPort.nHttpMp4Port, ABL_MediaServerPort.nHLSCutType, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nGBRtpTCPHeadType, ABL_MediaServerPort.nReConnectingCount,
			ABL_MediaServerPort.maxTimeNoOneWatch, ABL_MediaServerPort.pushEnable_mp4,ABL_MediaServerPort.fileSecond,ABL_MediaServerPort.fileKeepMaxTime,ABL_MediaServerPort.httpDownloadSpeed, ABL_MediaServerPort.nRecordReplayThread);
		ResponseSuccess(szMediaSourceInfoBuffer);

		return true;
	}

ABLMediaServer-2022-04-03 【增加视频解码， 图片抓拍，图片查询，图片下载】
1、Http请求操作get方式时候去掉空格 replace_all(strValue, "%20", "");//去掉空格
   1)、把key中所有的空格去掉
	 memset(szKey, 0x00, sizeof(szKey));
	 memcpy(szKey, szTextParam + nPos1, nFind1 - nPos1);
	 strKey = szKey;
	 replace_all(strKey, "%20", "");//去掉空格
	 strcpy(keyValue->key, strKey.c_str());

   2)、把value中所有的空格去掉
	if (nFind2 > 0)
	{
		memcpy(szValue, szTextParam + nFind1 + 1, nFind2 - nFind1 - 1);
		nPos1 = nFind2 + 1;

		strValue = szValue;
		replace_all(strValue, "%26", "&");
		replace_all(strValue, "%20", "");//去掉空格
		strcpy(keyValue->value, strValue.c_str());

		requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
		WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
	}
	else
	{
		memcpy(szValue, szTextParam + nFind1 + 1, strlen(szTextParam) - nFind1 - 1);
		strValue = szValue;
		replace_all(strValue, "%26", "&");
		replace_all(strValue, "%20", "");//去掉空格

		strcpy(keyValue->value, strValue.c_str());

		requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
		WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
		break;
	}
	
2、把域名转换为IP地址
 	bool   CNetRevcBase::ConvertDemainToIPAddress()
	{
		if (!ifConvertFlag)
			return true;

		hostent* host = gethostbyname(domainName);
		if (host == NULL)
			return false;

		char getIP[128] = { 0 };
		for (int i = 0; host->h_addr_list[i]; i++)
		{
			memset(getIP, 0x00, sizeof(getIP));
			strcpy(getIP,inet_ntoa(*(struct in_addr*)host->h_addr_list[i]));
			if (strlen(getIP) > 0)
			{
				strcpy(m_rtspStruct.szIP, getIP);
				WriteLog(Log_Debug, "CNetRevcBase = %X ,nClient = %llu ，domainName = %s ,转换IP为 %s ", this, nClient, domainName, m_rtspStruct.szIP);
				return true;
			}
		}

		return false ;
	}
	
   //定期更新动态域名的IP
   if (((*iterator1).second)->tUpdateIPTime - GetTickCount64() >= 1000 * 15)
   {
	   ((*iterator1).second)->tUpdateIPTime = GetTickCount64();
	   ((*iterator1).second)->ConvertDemainToIPAddress();
   }

3、在删除连接时 nClient == 0 也要销毁掉 【修正 nClient >= 0 的BUG 】
	nDeleteBreakTimer = 0;
	while ((pData = pDisconnectBaseNetFifo.pop(&nLength)) != NULL)
	{
		if (nLength == sizeof(nClient))
		{
			memcpy((char*)&nClient, pData, sizeof(nClient));
			if (nClient >= 0)
			{
				DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
				pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
				DeleteNetRevcBaseClient(nClient);//执行删除 
			}
		}

		pDisconnectBaseNetFifo.pop_front();
		Sleep(5);
	}

4、修改打印http请求参数的方式，
	WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 %s = %s", this, nClient, keyValue->key, keyValue->value);
	提示方式如下：
		2022-04-03_15:57:06:917 [14716] Log_Debug CNetServerHTTP =652E7090  nClient = 65 获取HTTP请求参数 secret = 035c73f7-bb6b-4889-a715-d9eb2d1925cc
		2022-04-03_15:57:06:920 [14716] Log_Debug CNetServerHTTP =652E7090  nClient = 65 获取HTTP请求参数 vhost = _defaultVhost_
		2022-04-03_15:57:06:920 [14716] Log_Debug CNetServerHTTP =652E7090  nClient = 65 获取HTTP请求参数 app = Media
		2022-04-03_15:57:06:922 [14716] Log_Debug CNetServerHTTP =652E7090  nClient = 65 获取HTTP请求参数 stream = Camera_00001
		2022-04-03_15:57:06:924 [14716] Log_Debug CNetServerHTTP =652E7090  nClient = 65 获取HTTP请求参数 url = rtsp://190.15.240.36:554/Media/Camera_00001
		2022-04-03_15:57:06:926 [14716] Log_Debug {"code":-300,"memo":"MediaSource: /Media/Camera_00001 Not Found ","key":0}
 
ABLMediaServer-2022-04-02 【增加视频解码， 图片抓拍，图片查询，图片下载】
1、增加码流达到、媒体断线http通知类
	else if (netClientType == NetBaseNetType_HttpClient_on_stream_arrive)
	{//事件通知4
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = ABL_MediaServerPort.nClientArrive = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
	else if (netClientType == NetBaseNetType_HttpClient_on_stream_disconnect)
	{//事件通知5
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = ABL_MediaServerPort.nClientDisconnect = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
	
2、增加码流达到、媒体断线的两个通知 
	//码流达到通知
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientArrive > 0)
	{
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientArrive);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%d}", app, stream, ABL_MediaServerPort.mediaServerID, netBaseNetType, nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}
	
	//媒体断线时通知
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientDisconnect > 0)
	{
		char szJson[512] = { 0 };
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClientNoLock(ABL_MediaServerPort.nClientDisconnect);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%d}",(*iterator1).second->app, (*iterator1).second->stream, ABL_MediaServerPort.mediaServerID, (*iterator1).second->netBaseNetType, (*iterator1).second->nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}
	
4、http post 方式 消息处理增加支持 application/x-www-form-urlencoded 这样类型的 body 数据
	else if (strcmp(szModem, "POST") == 0)
	{
		memset(szContentType, 0x00, sizeof(szContentType));
 		httpParse.GetFieldValue("Content-Type", szContentType);
		if (strcmp(szContentType, "application/json") == 0)
		{//json 格式
			if (!SplitterJsonParam(requestParam))
			{
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"json error\",\"key\":%d}", IndexApiCode_HttpJsonError,  0);
				ResponseSuccess(szResponseBody); 
				WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http json %s 错误 ，httpURL = %s", this, nClient, requestParam, httpURL);
				return false;
			}
		}
		else if (strcmp(szContentType, "application/x-www-form-urlencoded") == 0)
		{// application/x-www-form-urlencoded
 			if (!SplitterTextParam(requestParam))
			{
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"json error\",\"key\":%d}", IndexApiCode_HttpJsonError, 0);
				ResponseSuccess(szResponseBody);
				WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http x-www-form-urlencoded %s 错误 ，httpURL = %s", this, nClient, requestParam, httpURL);
				return false;
			}
		}
		else
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"IndexApiCode_ContentTypeNotSupported , ContentType: %s\"}", IndexApiCode_ContentTypeNotSupported, szContentType);
			ResponseSuccess(szResponseBody);
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu IndexApiCode_ContentTypeNotSupported , ContentType: %s ，httpURL = %s", this, nClient, szContentType, httpURL);
			return false;
		}
 	}

5、增加在windows平台只能运行一次的限制
	strcpy(szConfigFileName, "ABLMediaServer.exe_554");
	HANDLE hRunAsOne = ::CreateMutex(NULL, FALSE, szConfigFileName);
	if (::GetLastError() == ERROR_ALREADY_EXISTS)
	{
		return -1;
	}
	memset(szConfigFileName, 0x00, sizeof(szConfigFileName));

ABLMediaServer-2022-03-24 【增加视频解码， 图片抓拍，图片查询，图片下载】
1、增加代理rtsp，rtmp推流时连接超时的销毁 NetBaseNetType_RtspClientPush 、 NetBaseNetType_RtmpClientPush
	//单独处理各种代理拉流、推流时，连接超时回复http请求 
	if (((*iterator1).second)->netBaseNetType == NetBaseNetType_RtspClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpFlvClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSClientRecv ||
		((*iterator1).second)->netBaseNetType ==  NetBaseNetType_RtspClientPush || ((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpClientPush
		)
	{
		if (!((*iterator1).second)->bResponseHttpFlag && GetTickCount64() - ((*iterator1).second)->nCreateDateTime >= 8000 )
		{//连接超时9秒，尚未回复http请求，一律回复连接超时
			sprintf(((*iterator1).second)->szResponseBody, "{\"code\":%d,\"memo\":\"Network Connnect[ %s : %s ] Timeout .\",\"key\":%d}", IndexApiCode_ConnectTimeout, ((*iterator1).second)->m_rtspStruct.szIP, ((*iterator1).second)->m_rtspStruct.szPort, 0);
			((*iterator1).second)->ResponseHttp(((*iterator1).second)->nClient_http, ((*iterator1).second)->szResponseBody, false);

			//删除掉代理拉流、推流
			pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->hParent, sizeof(((*iterator1).second)->hParent));
		}
	}

ABLMediaServer-2022-03-23 【增加视频解码， 图片抓拍，图片查询，图片下载】
1、修正一个BUG，当代理拉流链接超时立即删除代理拉流对象
	 
	if (((*iterator1).second)->netBaseNetType == NetBaseNetType_RtspClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpFlvClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSClientRecv)
	{
		if (!((*iterator1).second)->bResponseHttpFlag && GetTickCount64() - ((*iterator1).second)->nCreateDateTime >= 9000 )
		{//连接超时9秒，尚未回复http请求，一律回复连接超时
			sprintf(((*iterator1).second)->szResponseBody, "{\"code\":%d,\"memo\":\"Network Connnect[ %s : %s ] Timeout .\",\"key\":%d}", IndexApiCode_ConnectTimeout, ((*iterator1).second)->m_rtspStruct.szIP, ((*iterator1).second)->m_rtspStruct.szPort, 0);
			((*iterator1).second)->ResponseHttp(((*iterator1).second)->nClient_http, ((*iterator1).second)->szResponseBody, false);

			//删除掉代理拉流 【修正BUG 】
			pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->hParent, sizeof(((*iterator1).second)->hParent));
		}
	}

ABLMediaServer-2022-03-21 【增加视频解码， 图片抓拍，图片查询，图片下载】
1、如果查询图片失败，返回错误码 1005 
	if (nMediaCount == 0)
	{
		sprintf(szMediaSourceInfo, "{\"code\":%d,\"memo\":\"MediaSource [app: %s , stream: %s] Not Found .\"}", IndexApiCode_RequestFileNotFound, mediaListStruct.app, mediaListStruct.stream);
	}

	if (nMediaCount == 0)
	{
		sprintf(szMediaSourceInfo, "{\"code\":%d,\"memo\":\"RecordList [app: %s , stream: %s] Record File Not Found .\"}", IndexApiCode_RequestFileNotFound, queryStruct.app, queryStruct.stream);
	}
	
	if (nMediaCount == 0)
	{
		sprintf(szMediaSourceInfo, "{\"code\":%d,\"memo\":\"PictureList [app: %s , stream: %s] Picture File Not Found .\"}", IndexApiCode_RequestFileNotFound, queryStruct.app, queryStruct.stream);
	}
	
2、	把抓拍客户端的查找流媒体，加入发送线程、加入拷贝线程的代码移植到 SendFirstRequst() 函数中，在http请求完成创建时再调用 SendFirstRequst() 函数 
    有可能在 CNetClientSnap 构造函数造成  CMediaStreamSource::AddClientToMap(nClient) 卡死  
	//发送第一个请求
	int CNetClientSnap::SendFirstRequst()
	{
		boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(m_szShareMediaURL);
		if (pMediaSource == NULL)
		{
			WriteLog(Log_Debug, "CNetClientSnap = %X nClient = %llu ,不存在媒体源 %s", this, nClient, m_szShareMediaURL);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1 ;
		}
		pMediaSendThreadPool->AddClientToThreadPool(nClient);
		pMediaSource->AddClientToMap(nClient);

		return 0;
	}
	
    //创建抓拍类，并调用 SendFirstRequst() 函数 
	boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_SnapPicture_JPEG, 0, 0, m_addStreamProxyStruct.url, 0, szShareMediaURL);
	if (pClient != NULL)
	{
		pClient->nClient_http = nClient; //赋值给http请求连接 
		pClient->timeout_sec = atoi(m_getSnapStruct.timeout_sec);//超时
		pClient->SendFirstRequst();
		WriteLog(Log_Debug, "请求抓拍 nClient_http = %llu, nClient = %llu ",nClient,pClient->nClient);
	}

ABLMediaServer-2022-03-20 【增加视频解码， 图片抓拍，图片查询，图片下载】
1、增加图片存储
	/* 图片文件存储 -------------------------------------------------------------------------------------*/
	CPictureFileSource_ptr GetPictureFileSource(char* szShareURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptrMap::iterator iterator1;
		CPictureFileSource_ptr   pPicture = NULL;

		iterator1 = xh_ABLPictureFileSourceMap.find(szShareURL);
		if (iterator1 != xh_ABLPictureFileSourceMap.end())
		{
			pPicture = (*iterator1).second;
			return pPicture;
		}
		else
		{
			return NULL;
		}
	}

	CPictureFileSource_ptr CreatePictureFileSource(char* app, char* stream)
	{
		char szShareURL[512] = { 0 };
		sprintf(szShareURL, "/%s/%s", app, stream);
		CPictureFileSource_ptr pReordFile = GetPictureFileSource(szShareURL);
		if (pReordFile != NULL)
		{
			WriteLog(Log_Debug, "CreatePictureFileSource 失败 , app = %s ,stream = %s 已经存在 ", app, stream);
			return NULL;
		}

		std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptr pPicture = NULL;

		try
		{
			do
			{
				pPicture = boost::make_shared<CPictureFileSource>(app, stream);
			} while (pPicture == NULL);
		}
		catch (const std::exception &e)
		{
			return NULL;
		}

		std::pair<boost::unordered_map<string, CPictureFileSource_ptr>::iterator, bool> ret =
			xh_ABLPictureFileSourceMap.insert(std::make_pair(pPicture->m_szShareURL, pPicture));
		if (!ret.second)
		{
			pPicture.reset();
			return NULL;
		}

		return pPicture;
	}

	bool  DeletePictureFileSource(char* szURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptrMap::iterator iterator1;

		iterator1 = xh_ABLPictureFileSourceMap.find(szURL);
		if (iterator1 != xh_ABLPictureFileSourceMap.end())
		{
			xh_ABLPictureFileSourceMap.erase(iterator1);
			return true;
		}
		else
		{
			return false;
		}
	}

	//增加一个录像文件到录像媒体源
	bool AddPictureFileToPictureSource(char* szShareURL, char* szFileName)
	{
		std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptrMap::iterator iterator1;

		iterator1 = xh_ABLPictureFileSourceMap.find(szShareURL);
		if (iterator1 != xh_ABLPictureFileSourceMap.end())
		{
			return (*iterator1).second->AddPictureFile(szFileName);
		}
		else
		{
			return false;
		}
	}

	//查询录像
	int queryPictureListByTime(char* szMediaSourceInfo, queryPictureListStruct queryStruct)
	{
		std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptrMap::iterator iterator1;
		CPictureFileSource_ptr   pPicture = NULL;
		list<uint64_t>::iterator it2;

		int   nMediaCount = 0;
		char  szTemp2[1024] = { 0 };
		char  szShareMediaURL[256] = { 0 };
		bool  bAddFlag = false;

		if (xh_ABLPictureFileSourceMap.size() > 0)
		{
			sprintf(szMediaSourceInfo, "{\"code\":0,\"app\":\"%s\",\"stream\":\"%s\",\"starttime\":\"%s\",\"endtime\":\"%s\",\"PictureFileList\":[", queryStruct.app, queryStruct.stream, queryStruct.starttime, queryStruct.endtime);
		}

		sprintf(szShareMediaURL, "/%s/%s", queryStruct.app, queryStruct.stream);
		iterator1 = xh_ABLPictureFileSourceMap.find(szShareMediaURL);
		if (iterator1 != xh_ABLPictureFileSourceMap.end())
		{
			pPicture = (*iterator1).second;

			for (it2 = pPicture->fileList.begin(); it2 != pPicture->fileList.end(); it2++)
			{
				if ( (*it2 / 100) >= atoll(queryStruct.starttime) && (*it2 / 100) <= atoll(queryStruct.endtime) )
				{
					memset(szTemp2, 0x00, sizeof(szTemp2));

					sprintf(szTemp2, "{\"file\":\"%llu.jpg\",\"url\":\"http://%s:%d/%s/%s/%llu.jpg\"},", *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nHttpServerPort, queryStruct.app, queryStruct.stream, *it2);

					strcat(szMediaSourceInfo, szTemp2);
					nMediaCount++;
				}
			}
		}
		else
		{
			return 0;
		}

		if (nMediaCount > 0)
		{
			szMediaSourceInfo[strlen(szMediaSourceInfo) - 1] = 0x00;
			strcat(szMediaSourceInfo, "]}");
		}

		if (nMediaCount == 0)
		{
			sprintf(szMediaSourceInfo, "{\"code\":%d,\"count\":0,\"memo\":\"PictureList [app: %s , stream: %s] Not Found .\"}", IndexApiCode_OK, queryStruct.app, queryStruct.stream);
		}

		return nMediaCount;
	}

	//查询一个图片文件是否存在
	bool QureyPictureFileFromPictureSource(char* szShareURL, char* szFileName)
	{
		std::lock_guard<std::mutex> lock(ABL_CPictureFileSourceMapLock);

		CPictureFileSource_ptrMap::iterator iterator1;

		iterator1 = xh_ABLPictureFileSourceMap.find(szShareURL);
		if (iterator1 != xh_ABLPictureFileSourceMap.end())
		{
			return (*iterator1).second->queryPictureFile(szFileName);
		}
		else
		{
			return false;
		}
	}
	/* 图片文件存储 -------------------------------------------------------------------------------------*/
	
2 查询图片列表
	bool  CNetServerHTTP::index_api_queryPictureList()
	{
		char szShareMediaURL[256] = { 0 };

		memset((char*)&m_queryPictureListStruct, 0x00, sizeof(m_queryPictureListStruct));
		GetKeyValue("secret", m_queryPictureListStruct.secret);
		GetKeyValue("vhost", m_queryPictureListStruct.vhost);
		GetKeyValue("app", m_queryPictureListStruct.app);
		GetKeyValue("stream", m_queryPictureListStruct.stream);
		GetKeyValue("starttime", m_queryPictureListStruct.starttime);
		GetKeyValue("endtime", m_queryPictureListStruct.endtime);

		if (strlen(m_queryPictureListStruct.secret) == 0 || strlen(m_queryPictureListStruct.app) == 0 || strlen(m_queryPictureListStruct.stream) == 0 ||
			strlen(m_queryPictureListStruct.starttime) == 0 || strlen(m_queryPictureListStruct.endtime) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[secret , app , stream , starttime , endtime] parameter need .\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strcmp(m_queryPictureListStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strlen(m_queryPictureListStruct.starttime) != 14 || strlen(m_queryPictureListStruct.endtime) != 14)
		{//开始时间、结束时间的长短检测 
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[starttime , endtime ] Length Error ,length must 14 \"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (boost::all(m_queryPictureListStruct.starttime, boost::is_digit()) == false || boost::all(m_queryPictureListStruct.endtime, boost::is_digit()) == false)
		{//检测开始时间、结束时间 是否是数字的字符串（0 ~ 9）
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[starttime , endtime ] error , must is number \"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (atoll(m_queryPictureListStruct.endtime) < atoll(m_queryPictureListStruct.starttime))
		{//结束时间必须大于开始时间
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"endtime must greater than starttime \"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//检测查询时间间隔不能超过3天
		if (GetCurrentSecondByTime(m_queryPictureListStruct.endtime) - GetCurrentSecondByTime(m_queryPictureListStruct.starttime)  >  (7 * 24 * 3600))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"query times No more than 7 days \"}", IndexApiCode_secretError, ABL_MediaServerPort.fileSecond);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//app ,stream 这两个字符串里面不能有 / 
		if (strstr(m_queryPictureListStruct.app, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"app parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}
		if (strstr(m_queryPictureListStruct.stream, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"stream parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//先简单判断是否存储图片
		sprintf(szShareMediaURL, "/%s/%s", m_queryPictureListStruct.app, m_queryPictureListStruct.stream);
		boost::shared_ptr<CPictureFileSource> pPicture = GetPictureFileSource(szShareMediaURL);
		if (pPicture == NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"count\":0,\"memo\":\"MediaSource [app: %s , stream: %s] PictureFile Not Found .\"}", IndexApiCode_OK, m_queryPictureListStruct.app, m_queryPictureListStruct.stream);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, MaxMediaSourceInfoLength);
		int nMediaCount = queryPictureListByTime(szMediaSourceInfoBuffer, m_queryPictureListStruct);
		if (nMediaCount >= 0)
		{
			ResponseSuccess(szMediaSourceInfoBuffer);
		}

		return true;
	}

3 下载图片jpg ,png ,bmp 等等 
 
	bool  CNetServerHTTP::index_api_downloadImage(char* szHttpURL)
	{  
		string strImageFile = szHttpURL;
		char   szMediaURL[256] = { 0 };
		char   szFileNumber[128] = { 0 };
		int    nPos = 0;
		char   szImageFileName[256] = { 0 };
		int    nImageFileSize = 0;
		bool   bSuccessFlag = false;
		string strHttpURL;

		nPos = strImageFile.rfind("/", strlen(szHttpURL));
		if (nPos > 0)
		{
			memcpy(szMediaURL, szHttpURL, nPos);
			boost::shared_ptr<CPictureFileSource> pPicture = GetPictureFileSource(szMediaURL);
			if (pPicture)
			{
				memcpy(szFileNumber, szHttpURL + nPos + 1, strlen(szHttpURL) - nPos - 5);
				if (pPicture->queryPictureFile(szFileNumber))
				{
					memmove(szHttpURL, szHttpURL + 1, strlen(szHttpURL) - 1);
					szHttpURL[strlen(szHttpURL) - 1] = 0x00;

	#ifdef OS_System_Windows
					strHttpURL = szHttpURL;
					replace_all(strHttpURL, "/", "\\");
					sprintf(szImageFileName, "%s%s", ABL_MediaServerPort.picturePath, strHttpURL.c_str());
					struct _stat64 fileBuf;
					int error = _stat64(szImageFileName, &fileBuf);
					if (error == 0)
						nImageFileSize = fileBuf.st_size;
	#else 
					sprintf(szImageFileName, "%s%s", ABL_MediaServerPort.picturePath, szHttpURL);

					struct stat fileBuf;
					int error = stat(szImageFileName, &fileBuf);
					if (error == 0)
						nImageFileSize = fileBuf.st_size;
	#endif			 
					if (nImageFileSize > 0)
					{
						FILE* fImage = fopen(szImageFileName, "rb");
						if (fImage)
						{
							fread(szMediaSourceInfoBuffer, 1, nImageFileSize, fImage);
							fclose(fImage);
							bSuccessFlag = true;
							ResponseImage(nClient, HttpImageType_jpeg, (unsigned char*)szMediaSourceInfoBuffer, nImageFileSize, false);
						}
					}
				}
			}
		}

		if (!bSuccessFlag)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Fille: %s Not Found \"}", IndexApiCode_RequestFileNotFound, szHttpURL);
			ResponseSuccess(szResponseBody);
		}

		return true;
	}

ABLMediaServer-2022-03-17 【增加录像保存、查询录像、录像下载功能】
1、增加解码类库 
	/*
	功能：
	   实现视频解码 

	日期    2022-03-17
	作者    罗家兄弟
	QQ      79941308
	E-Mail  79941308@qq.com
	*/

	#include "stdafx.h"
	#include "VideoDecode.h"

	CVideoDecode::CVideoDecode()
	{
	   m_bInitDecode = FALSE ;
	   pDCodecCtx = NULL ;
	   memset(m_szCodecName, 0x00, sizeof(m_szCodecName));
	   m_nWidth = m_nHeight = 0;
	   nFrameGopCount = 0;
	   pDPicture = NULL;
   }

2、增加视频解码抓拍功能
	if (bPutVideoFlag && (pData = m_videoFifo.pop(&nLength)) != NULL)
	{
		if (!videoDecode.m_bInitDecode)
			videoDecode.startDecode(mediaCodecInfo.szVideoName, 0, 0);
		if (videoDecode.m_bInitDecode)
		{
			if (videoDecode.DecodeYV12Image(pData, nLength) > 0)
			{
				char   szFileName[256] = { 0 };
				//sprintf(szFileName, "E:\\%X_%d.jpg", this, rand());
				strcpy(szFileName, "E:\\8957D820_5705.jpg");
				videoDecode.CaptureJpegFromAVFrame(szFileName, 98);
				bPutVideoFlag = false;
				sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success , Catpuring takes time %d millisecond .\",\"url\":\"%s\"}", GetTickCount64() - nPrintTime, "/Media/Camera_00001/20220317092653.jpg");
				ResponseHttp(nClient_http, szResponseBody, false);
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
 			}
		}

		m_videoFifo.pop_front();
	}

3、增加抓拍超时检测
 		 
	if (((*iterator1).second)->netBaseNetType == NetBaseNetType_SnapPicture_JPEG && ((*iterator1).second)->bSnapSuccessFlag == false )
	{
		if(GetTickCount64() - ((*iterator1).second)->nPrintTime >= 1000 * ((*iterator1).second)->timeout_sec)
		   pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof(((*iterator1).second)->nClient));
	}

ABLMediaServer-2022-03-16_2 【增加录像保存、查询录像、录像下载功能】
1、增加抓拍类
	CNetClientSnap::CNetClientSnap(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
	{
		strcpy(m_szShareMediaURL,szShareMediaURL);
		nClient = hClient;
		netBaseNetType = NetBaseNetType_SnapPicture_JPEG;
		nMediaClient = 0;
		nNetGB28181ProxyType = 0;

		boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(m_szShareMediaURL);
		if (pMediaSource == NULL)
		{
			WriteLog(Log_Debug, "CNetClientSnap = %X nClient = %llu ,不存在媒体源 %s", this, nClient, m_szShareMediaURL);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient,sizeof(nClient));
			return;
		}

		m_videoFifo.InitFifo(MaxLiveingVideoFifoBufferLength);
		pMediaSendThreadPool->AddClientToThreadPool(nClient);
		pMediaSource->AddClientToMap(nClient);

		WriteLog(Log_Debug, "CNetClientSnap 构造 = %X  nClient = %llu ", this, nClient);
	}
	
2、增加响应抓拍的http函数
	 
	bool  CNetServerHTTP::index_api_getSnap()
	{
		char szShareMediaURL[256] = { 0 };

		memset((char*)&m_getSnapStruct, 0x00, sizeof(m_getSnapStruct));
		GetKeyValue("secret", m_getSnapStruct.secret);
		GetKeyValue("vhost", m_getSnapStruct.vhost);
		GetKeyValue("app", m_getSnapStruct.app);
		GetKeyValue("stream", m_getSnapStruct.stream);
		GetKeyValue("timeout_sec", m_getSnapStruct.timeout_sec);

		if (strlen(m_getSnapStruct.secret) == 0 || strlen(m_getSnapStruct.app) == 0 || strlen(m_getSnapStruct.stream) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[secret , app , stream ] parameter need .\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strcmp(m_getSnapStruct.secret, m_getSnapStruct.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}


ABLMediaServer-2022-03-16 【增加录像保存、查询录像、录像下载功能】
1、把SDK检查 设置为 是 (/sdl) ，即可 开启SDK检查，否则老陈的mp4库会奔溃 
   http-mp4 播放会奔溃，
   fmp4切片的录像也会奔溃 
   解决办法 只有把 使用所以的ffmpeg 函数 。
   
2、使用所有的ffmepg函数 ，这样 SDL检查 就打开检查，老陈的库 需要 SDK检查的，这样不再冲突 

    //分配内存时填充内存 
  	int numBytes1 = av_image_get_buffer_size((enum AVPixelFormat)nSrcImage, nSrcWidth, nSrcHeight,1);
	pFrameRGB = av_frame_alloc();
	szRGBData = new unsigned char[numBytes1];
	av_image_fill_arrays(pFrameRGB->data, pFrameRGB->linesize, szRGBData, nSrcImage, nSrcWidth, nSrcHeight, 1);

    //分配内存时填充内存 
	int numBytes2 = av_image_get_buffer_size((enum AVPixelFormat)nDstImage, nDstWidth, nDestHeight,1);
	pFrameDest = av_frame_alloc();
 	szDestData = new unsigned char[numBytes2];
	av_image_fill_arrays(pFrameDest->data, pFrameDest->linesize, szDestData, nDstImage, nDstWidth, nDestHeight, 1);
 
    //修改视频编码的老函数 
	bool  CFFVideoEncode::EncodecYUV(unsigned char* pYUVData, int nLength, unsigned char* pEncodecData, int* nOutLength)
	{
		EnterCriticalSection(&Encode_CS);
		if (m_bInitFlag)
		{
			got_picture = 0;
			pFrame->pts = nFrameNumber * (pCodecCtx->time_base.den) / ((pCodecCtx->time_base.num) * 25);
			memcpy(picture_buf, pYUVData, nLength);

			ret = avcodec_send_frame(pCodecCtx, pFrame);
			if (ret < 0) {
				av_packet_unref(&pkt);
				LeaveCriticalSection(&Encode_CS);
				return false;
			}

			while (ret >= 0) {
				ret = avcodec_receive_packet(pCodecCtx, &pkt);
				if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF || ret < 0)
				{
					av_packet_unref(&pkt);
					LeaveCriticalSection(&Encode_CS);
					return false ;
				}
	 
				memcpy(pEncodecData, pkt.data, pkt.size);
				*nOutLength = pkt.size;
				av_packet_unref(&pkt);
			}

			LeaveCriticalSection(&Encode_CS);
			return true;
		}
		else
		{
			LeaveCriticalSection(&Encode_CS);
			return false;
		}
	}

ABLMediaServer-2022-03-15 【增加录像保存、查询录像、录像下载功能】
1、增加获取显卡名称
	//获取显卡名称 
	LPDIRECT3D9			        m_pD3D;
	D3DADAPTER_IDENTIFIER9      pD3DName;
 	m_pD3D = Direct3DCreate9(D3D_SDK_VERSION);
	m_pD3D->GetAdapterIdentifier(D3DADAPTER_DEFAULT, 0, &pD3DName);
	SAFE_RELEASE(m_pD3D);

	av_register_all();
	avcodec_register_all();

	if (strstr(pD3DName.Description, "GeForce") != NULL)
	{//英伟达显卡
      ABL_bCudaFlag = cudaEncode_Init();
	  ABL_nCudaCount = cudaEncode_GetDeviceGetCount();
 	}

2、增加动态加载dll里面的函数，这样能兼容英伟达的显卡 
	if (strstr(pD3DName.Description, "GeForce") != NULL)
	{//英伟达显卡硬编码
		hInstance = ::LoadLibrary("cudaEncodeDLL.dll");
		if (hInstance != NULL)
		{
			cudaEncode_Init = (ABL_cudaEncode_Init) ::GetProcAddress(hInstance, "cudaEncode_Init");
			cudaEncode_GetDeviceGetCount = (ABL_cudaEncode_GetDeviceGetCount) ::GetProcAddress(hInstance, "cudaEncode_GetDeviceGetCount");
			cudaEncode_GetDeviceName = (ABL_cudaEncode_GetDeviceName) ::GetProcAddress(hInstance, "cudaEncode_GetDeviceName");
			cudaEncode_CreateVideoEncode = (ABL_cudaEncode_CreateVideoEncode) ::GetProcAddress(hInstance, "cudaEncode_CreateVideoEncode");
			cudaEncode_DeleteVideoEncode = (ABL_cudaEncode_DeleteVideoEncode) ::GetProcAddress(hInstance, "cudaEncode_DeleteVideoEncode");
			cudaEncode_CudaVideoEncode = (ABL_cudaEncode_CudaVideoEncode) ::GetProcAddress(hInstance, "cudaEncode_CudaVideoEncode");
		}
      ABL_bCudaFlag = cudaEncode_Init();
	  ABL_nCudaCount = cudaEncode_GetDeviceGetCount();
 	}

ABLMediaServer-2022-03-11 【增加录像保存、查询录像、录像下载功能】
1、检测是否开启了屏幕摄像机
	bool GetScreenCameraClient()
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		CNetRevcBase_ptr   pClient = NULL;
		bool               bFind = false;
		 
		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1 ++ )
		{
			pClient = (*iterator1).second;
			if (pClient->netBaseNetType == NetBaseNetType_CaptureScreenStream)
			{
				bFind = true;
				WriteLog(Log_Debug, "GetScreenCameraClient() 已经启动了屏幕摄像机 nClient = %llu , m_szShareMediaURL = %s ", pClient->nClient,pClient->m_szShareMediaURL);
				break;
			}
		}
	 
		return bFind ;
	 }

2、支持裁剪屏幕某个区域
    if(m_ScreenCaptureStruct.bFullScreen) 
	 size = (m_ScreenCaptureStruct.nWidth * m_ScreenCaptureStruct.nHeight * 3) / 2;
	else
	 size = (m_ScreenCaptureStruct.nCutWidth * m_ScreenCaptureStruct.nCutHeight * 3) / 2;	

	pEncodeBuff = new unsigned char[MaxLiveingVideoFifoBufferLength];
	if (m_ScreenCaptureStruct.bFullScreen)
	{
		nEncodeWidth = m_ScreenCaptureStruct.nWidth;
		nEncodeHeight = m_ScreenCaptureStruct.nHeight;
	}
	else
	{
		nEncodeWidth = m_ScreenCaptureStruct.nCutWidth;
		nEncodeHeight = m_ScreenCaptureStruct.nCutHeight;
	}

    //支持编码全屏，局部屏幕 
	if (nEncodeVideoType == VideoEncodeType_Cuda && hCudaHandle > 0)
	{//cuda 编码
		if(m_ScreenCaptureStruct.bFullScreen)
		  nEncodeLength = cudaEncode_CudaVideoEncode(hCudaHandle, pFrameSws->szDestData, size,(char*)pEncodeBuff);
		else
		{
			get_yuv420p_crop_img(pFrameSws->szDestData, pCutYUVBuffer, m_ScreenCaptureStruct.x, m_ScreenCaptureStruct.y, m_ScreenCaptureStruct.nCutWidth, m_ScreenCaptureStruct.nCutHeight);
			nEncodeLength = cudaEncode_CudaVideoEncode(hCudaHandle, pCutYUVBuffer, size, (char*)pEncodeBuff);
		}
	}
	else if (pffVideoEncode->m_bInitFlag && pFrameSws->bInitFlag )
	{//h264_qsv 硬编码或者cpu软编码  
		if (m_ScreenCaptureStruct.bFullScreen)
		{
		  if (pffVideoEncode->EncodecYUV(pFrameSws->szDestData, size, pEncodeBuff, &nEncodeLength))
		   {
		   }
		}
		else
		{
			get_yuv420p_crop_img(pFrameSws->szDestData, pCutYUVBuffer, m_ScreenCaptureStruct.x, m_ScreenCaptureStruct.y, m_ScreenCaptureStruct.nCutWidth, m_ScreenCaptureStruct.nCutHeight);
			if (pffVideoEncode->EncodecYUV(pCutYUVBuffer, size, pEncodeBuff, &nEncodeLength))
			{
			}
		}
 	}

3、增加YUV420 扣取某一小块 
	void CNetClentScreen::get_yuv420p_crop_img(uint8_t *img_buffer, uint8_t *out_buffer,
		int x1, int y1, int crop_width, int crop_height)
	{
		int i, j, k = 0;

		int orig_y_size = m_ScreenCaptureStruct.nWidth * m_ScreenCaptureStruct.nHeight,
			orig_u_size = orig_y_size >> 2;

		int crop_x1, crop_y1, crop_x2, crop_y2;
		int h_s, h_e, w_s, w_e;

		int loop_y_s1, loop_y_e1, loop_uv_s1, loop_uv_e1;
		int loop_y_s2, loop_y_e2, loop_uv_s2, loop_uv_e2;

		crop_x1 = x1;
		crop_y1 = y1;
		crop_x2 = x1 + crop_width;
		crop_y2 = y1 + crop_height;

		loop_y_s1 = y1;
		loop_y_e1 = y1 + crop_height;
		loop_y_s2 = x1;
		loop_y_e2 = x1 + crop_width;

		loop_uv_s1 = loop_y_s1 / 2;
		loop_uv_e1 = loop_y_e1 / 2;
		loop_uv_s2 = loop_y_s2 / 2;
		loop_uv_e2 = loop_y_e2 / 2;

		/* copy Y section */
		for (i = loop_y_s1; i < loop_y_e1; i++) {
			for (j = loop_y_s2; j < loop_y_e2; j++) {
				out_buffer[k] = img_buffer[i * m_ScreenCaptureStruct.nWidth + j];
				k++;
			}
		}

		/* copy u section */
		for (i = loop_uv_s1; i < loop_uv_e1; i++) {
			for (j = loop_uv_s2; j < loop_uv_e2; j++) {
				out_buffer[k] = img_buffer[orig_y_size + i * (m_ScreenCaptureStruct.nWidth / 2) + j];
				k++;
			}
		}

		/* copy v section */
		for (i = loop_uv_s1; i < loop_uv_e1; i++) {
			for (j = loop_uv_s2; j < loop_uv_e2; j++) {
				out_buffer[k] = img_buffer[orig_y_size + orig_u_size + i * (m_ScreenCaptureStruct.nWidth / 2) + j];
				k++;
			}
		}
	}
	
ABLMediaServer-2022-03-09 【增加录像保存、查询录像、录像下载功能】
1、增加代理拉流接入屏幕摄像机
2、增加关闭屏幕摄像机
3、支持设置屏幕摄像机宽、高、视频帧速度

ABLMediaServer-2022-03-15 【增加录像保存、查询录像、录像下载功能】
1、更新非HLS播放的最后观看时间
	//每隔3秒更新最后观看时间
	if (GetTickCount64() - tCopyVideoTime >= 1000 * 3)
	{
		nLastWatchTime = nLastWatchTimeDisconect = GetCurrentSecond();
		tCopyVideoTime = GetTickCount64();
	}
	
2、在基类增加是否连接成功标志 
    bool                   bConnectSuccessFlag;
    在基类构造函数设置为 false 
	bConnectSuccessFlag = false ;
    
	//链接成功时，再设置为 true 
	else if (result == 1)
	{//如果链接成功，发送第一个请求
		CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
		if (pClient)
		{
			WriteLog(Log_Debug, "clihandle = %llu ,URL: %s , 连接成功 result: %d ", clihandle, pClient->m_rtspStruct.szSrcRtspPullUrl, result);
			pClient->bConnectSuccessFlag = true;
 			pClient->SendFirstRequst();
		}
	}

ABLMediaServer-2022-03-14 【增加录像保存、查询录像、录像下载功能】
1、增加无人观察时间长参数，默认30秒 ，当持续30秒无人观看则发送无人观看消息给http服务器
    #某一路码流持续多少秒无人观看就会发送 无人观看通知消息 ，单位秒 
     noneReaderDuration=30
 
	//无人观看消息,30秒中通知一次
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNoneReader > 0  && GetCurrentSecond() - nLastWatchTime >= ABL_MediaServerPort.noneReaderDuration)
	{

2、修复最大无人观看时，强制断开媒体源
    1）必须多定义个变量 nLastWatchTimeDisconect
	
	//无人观看最大时长，必须关闭
	if ((GetCurrentSecond() - nLastWatchTimeDisconect) >= (ABL_MediaServerPort.maxTimeNoOneWatch * 60))
	{
		WriteLog(Log_Debug, "app = %s ,stream = %s  无人观看已经达到 %llu 分钟 ，现在执行删除 ", app, stream, (GetCurrentSecond() - nLastWatchTimeDisconect) / 60 );
		nLastWatchTimeDisconect = GetCurrentSecond(); //防止2次删除 
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
	}

3、在基类增加是否连接成功标志 
    bool                   bConnectSuccessFlag;
    在基类构造函数设置为 false 
	bConnectSuccessFlag = false ;
    
	//链接成功时，再设置为 true 
	else if (result == 1)
	{//如果链接成功，发送第一个请求
		CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
		if (pClient)
		{
			WriteLog(Log_Debug, "clihandle = %llu ,URL: %s , 连接成功 result: %d ", clihandle, pClient->m_rtspStruct.szSrcRtspPullUrl, result);
			pClient->bConnectSuccessFlag = true;
 			pClient->SendFirstRequst();
		}
	}

4、在连接的类析构时，先判断 bConnectSuccessFlag == true 才关闭 
	CNetClientRecvRtsp::~CNetClientRecvRtsp()
	{

      if(bConnectSuccessFlag)
	    XHNetSDK_Disconnect(nClient);

5、修复最后观看视频  
	 
	if (mediaSendMap.size() <= 0)
	{
		if (ABL_MediaServerPort.hook_enable == 1)
		{//启用http post 通知 
			boost::shared_ptr<CNetRevcBase> pClient =  GetNetRevcBaseClient(nClient);
			if (pClient)
			{//这3个网络类型是http链接客户端，并没有观看视频。
				if(!(pClient->netBaseNetType >= NetBaseNetType_HttpClient_None_reader && pClient->netBaseNetType <= NetBaseNetType_HttpClient_Record_mp4))
				   nLastWatchTime = GetCurrentSecond();
			}
		}else
			nLastWatchTime = GetCurrentSecond();
    }

ABLMediaServer-2022-03-13 【增加录像保存、查询录像、录像下载功能】
1、增加媒体流点播失败，流找不到的通知消息 
	//码流找不到
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNotFound > 0 )
	{
		char  szJson[128];
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientNotFound);
		if (pHttpClient != NULL)
		{
			if (pHttpClient->SplitterAppStream(szURL))
			{
				sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\"}", pHttpClient->m_addStreamProxyStruct.app, pHttpClient->m_addStreamProxyStruct.stream, ABL_MediaServerPort.MediaServerID);
				pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
			}
		}
	}

2、当http通知类析构时，把变量复位为0  
	switch (netBaseNetType)
	{
	case NetBaseNetType_HttpClient_None_reader:
		 ABL_MediaServerPort.nClientNoneReader = 0;
		break;
	case NetBaseNetType_HttpClient_Not_found:
		 ABL_MediaServerPort.nClientNotFound = 0;
		break;
	case NetBaseNetType_HttpClient_Record_mp4:
		 ABL_MediaServerPort.nClientRecordMp4 = 0;
		break;
	}
	
3、3个消息通知条件都要增加一个	ABL_MediaServerPort.nClientRecordMp4 > 0 

	//无人观看消息,30秒中通知一次
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNoneReader > 0  && GetCurrentSecond() - nLastWatchTime >= 15)
	{
	
	//完成一个fmp4切片文件通知
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientRecordMp4 > 0 )

	//码流找不到
	if (ABL_MediaServerPort.hook_enable == 1 && ABL_MediaServerPort.nClientNotFound > 0 )

4、增加录像点播时，码流找不到的消息通知 
	if (ABL_MediaServerPort.hook_enable == 1 && bRet == false &&  ABL_MediaServerPort.nClientNotFound > 0)
	{
		char  szJson[128];
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientNotFound);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s___ReplayFMP4RecordFile__%s\",\"mediaServerId\":\"%s\"}", m_app,m_stream, szRecordFileName, ABL_MediaServerPort.MediaServerID);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}


ABLMediaServer-2022-03-12 【增加录像保存、查询录像、录像下载功能】
1、增加事件通知的CNetHttpClient 类，创建了3给实例 
	else if (netClientType == NetBaseNetType_HttpClient_None_reader)
	{//事件通知1
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = ABL_MediaServerPort.nClientNoneReader =  pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型  
	}
	else if ( netClientType == NetBaseNetType_HttpClient_Not_found)
	{//事件通知2
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = ABL_MediaServerPort.nClientNotFound = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
	else if (netClientType == NetBaseNetType_HttpClient_Record_mp4)
	{//事件通知3
		pXHClient = boost::make_shared<CNetClientHttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = ABL_MediaServerPort.nClientRecordMp4 = pXHClient->nClient;
		pXHClient->netBaseNetType = netClientType; //更新网络类型
	}
 
2、无人观看消息,15秒中通知一次
	if (GetCurrentSecond() - nLastWatchTime >= 15)
	{
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientNoneReader);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"key\":%d}", app,  stream, ABL_MediaServerPort.MediaServerID, netBaseNetType,nClient);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}

		nLastWatchTime = GetCurrentSecond();
	}

3、在CNetServerHttp 中增加提示3种消息通知，用于方便测试 	
	else if (strcmp(httpURL, "/index/hook/on_stream_none_reader") == 0 || strcmp(httpURL, "/index/hook/on_stream_not_found") == 0 || strcmp(httpURL, "/index/hook/on_record_mp4") == 0)
	{//提示收到通知事件
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http 收到通知事件 \r\nhttpURL = %s\r\n%s", this, nClient, httpURL, requestParam);
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Http Request [ %s ] Success \",\"key\":%d}", IndexApiCode_OK, httpURL, nClient);
		ResponseSuccess(szResponseBody);
		return true;
	}
	
4、完成一个fmp4切片文件通知
	if (ABL_MediaServerPort.hook_enable == 1)
	{
		boost::shared_ptr<CNetRevcBase> pHttpClient = GetNetRevcBaseClient(ABL_MediaServerPort.nClientRecordMp4);
		if (pHttpClient != NULL)
		{
			sprintf(szJson, "{\"app\":\"%s\",\"stream\":\"%s\",\"mediaServerId\":\"%s\",\"networkType\":%d,\"fileName\":\"%s\"}", app, stream, ABL_MediaServerPort.MediaServerID, netBaseNetType, szFileNameOrder);
			pHttpClient->PushVideo((unsigned char*)szJson, strlen(szJson), "JSON");
		}
	}
			
ABLMediaServer-2022-03-07 【增加录像保存、查询录像、录像下载功能】
1、编译Linux 版本 

2、把Linux平台的 boost 连接库一起打包压缩


ABLMediaServer-2022-03-05 【增加录像保存、查询录像、录像下载功能】
1、解决 RTPS录像点播有音频情况下的流畅性。在拖动播放时，重新计算视频，音频总播放数量，否则每读取一帧累加1帧
	if (pThis->bRestoreVideoFrameFlag)
	{//重新计算已经播放视频帧总数，因为已经拖动播放
		pThis->nReadVideoFrameCount = ((pts - pThis->nVideoFirstPTS) / (1000 / pThis->mediaCodecInfo.nVideoFrameRate));
		pThis->bRestoreVideoFrameFlag = false;
	}
	else
		pThis->nReadVideoFrameCount ++;
		
	if (pThis->bRestoreAudioFrameFlag)
	{//重新计算音频帧总数 ，因为已经拖到播放
		pThis->nReadAudioFrameCount = ((pts - pThis->nAudioFirstPTS) / pThis->mediaCodecInfo.nBaseAddAudioTimeStamp);
		pThis->bRestoreAudioFrameFlag = false;
	}
	else
		pThis->nReadAudioFrameCount++;
		

ABLMediaServer-2022-03-04 【增加录像保存、查询录像、录像下载功能】
1、兼容车牌识别摄像机 臻识 以rtsp协议接入流媒体服务器
	void  CNetClientRecvRtsp::SendSetup(WWW_AuthenticateType wwwType)
	{
	 nSendSetupCount++;
	 if (nSendSetupCount == 2)
	 {
		string strSession = szSessionID;
		int    nPos2 = strSession.find(";", 0);
		if (nPos2 > 0)
		{
			szSessionID[nPos2] = 0x00;
			WriteLog(Log_Debug, "SendPlay() ，nClient = %llu ,strSessionID = %s , szSessionID = %s ", nClient, strSession.c_str(), szSessionID);
		}
	}
	if (wwwType == WWW_Authenticate_None)
	{
		if (nSendSetupCount == 1)
		{
			if (m_rtspStruct.szRtspURLTrim[strlen(m_rtspStruct.szRtspURLTrim) - 1] == '/')
				sprintf(szResponseBuffer, "SETUP %s%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson);
			else
				sprintf(szResponseBuffer, "SETUP %s/%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson);
		}
		else if (nSendSetupCount == 2)
		{
			if (m_rtspStruct.szRtspURLTrim[strlen(m_rtspStruct.szRtspURLTrim) - 1] == '/')
				sprintf(szResponseBuffer, "SETUP %s%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, szSessionID);
			else
				sprintf(szResponseBuffer, "SETUP %s/%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, szSessionID);
		}
	}
	else if (wwwType == WWW_Authenticate_MD5)
	{
		Authenticator author;
		char*         szResponse;

		author.setRealmAndNonce(m_rtspStruct.szRealm, m_rtspStruct.szNonce);
		author.setUsernameAndPassword(m_rtspStruct.szUser, m_rtspStruct.szPwd);
		szResponse = (char*)author.computeDigestResponse("SETUP", m_rtspStruct.szRtspURLTrim); //要注意 uri ,有时候没有最后的 斜杠 /

		if (nSendSetupCount == 1)
		{
			if (m_rtspStruct.szRtspURLTrim[strlen(m_rtspStruct.szRtspURLTrim) - 1] == '/')
				sprintf(szResponseBuffer, "SETUP %s%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szRtspURLTrim, szResponse);
			else
				sprintf(szResponseBuffer, "SETUP %s/%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szRtspURLTrim, szResponse);
		}
		else if (nSendSetupCount == 2)
		{
			if (m_rtspStruct.szRtspURLTrim[strlen(m_rtspStruct.szRtspURLTrim) - 1] == '/')
				sprintf(szResponseBuffer, "SETUP %s%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szRtspURLTrim, szResponse, szSessionID);
			else
				sprintf(szResponseBuffer, "SETUP %s/%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_rtspStruct.szUser, m_rtspStruct.szRealm, m_rtspStruct.szNonce, m_rtspStruct.szRtspURLTrim, szResponse, szSessionID);
		}

		author.reclaimDigestResponse(szResponse);
	}
	else if (wwwType == WWW_Authenticate_Basic)
	{
		UserPasswordBase64(szBasic);

		if (nSendSetupCount == 1)
		{
			if (m_rtspStruct.szRtspURLTrim[strlen(m_rtspStruct.szRtspURLTrim) - 1] == '/')
				sprintf(szResponseBuffer, "SETUP %s%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Basic %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, szBasic);
			else
				sprintf(szResponseBuffer, "SETUP %s/%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Basic %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, szBasic);
		}
		else if (nSendSetupCount == 2)
		{
			if (m_rtspStruct.szRtspURLTrim[strlen(m_rtspStruct.szRtspURLTrim) - 1] == '/')
				sprintf(szResponseBuffer, "SETUP %s%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Basic %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, szBasic, szSessionID);
			else
				sprintf(szResponseBuffer, "SETUP %s/%s RTSP/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Basic %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\nSession: %s\r\n\r\n", m_rtspStruct.szRtspURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, szBasic, szSessionID);
		}
	}

	XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);

	nRtspProcessStep = RtspProcessStep_SETUP;

	//WriteLog(Log_Debug, "\r\n%s", szResponseBuffer);

		CSeq++;
	}
	
2、删除直接回复大华摄像机的rtcp包，改成如果收到rtcp包，直接回复 
 	else if (rtspHead.chan == 0x01)
	{//收到RTCP包，需要回复rtcp报告包
		//WriteLog(Log_Debug, "this =%X ,收到 视频 的RTCP包，需要回复rtcp报告包，netBaseNetType = %d  收到RCP包长度 = %d ", this, netBaseNetType, nReadLength);
		SendRtcpReportDataRR(nVideoSSRC, 1);
	}
	else if (rtspHead.chan == 0x03)
	{//收到RTCP包，需要回复rtcp报告包
		//WriteLog(Log_Debug, "this =%X ,收到 音频 的RTCP包，需要回复rtcp报告包，netBaseNetType = %d  收到RCP包长度 = %d ", this, netBaseNetType, nReadLength);
		SendRtcpReportDataRR(audioSSRC, 3);
	}  

ABLMediaServer-2022-03-03 【增加录像保存、查询录像、录像下载功能】
1、rtsp连接失败，sprintf 打印端口时类型错误 
	else if (memcmp(szIP, "rtsp://", 7) == 0 )
	{//rtsp 
		pXHClient = boost::make_shared<CNetClientRecvRtsp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
		CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
		if (CltHandle == 0)
		{//连接失败
			WriteLog(Log_Debug, "CreateNetRevcBaseClient()，连接 rtsp 服务器 失败 szURL = %s , szIP = %s ,port = %s ", szIP, pXHClient->m_rtspStruct.szIP, pXHClient->m_rtspStruct.szPort);
			pDisconnectBaseNetFifo.push((unsigned char*)&pXHClient->nClient, sizeof(pXHClient->nClient));
		}
	}

2、 在CMediaFifo、还有所有的类的 析构函数增加 malloc_trim(0);
	CMediaFifo::~CMediaFifo()
	{
		FreeFifo();
		malloc_trim(0);
	}

3、 winddows 平台没有函数 malloc_trim，增加该函数
	void malloc_trim(int n)
	{
		n = 5;
	}
	

ABLMediaServer-2022-03-02 【增加录像保存、查询录像、录像下载功能】
1、编译 linux 平台的 faac-1.29.9.2 

2、修改 Linux 平台下面的 Makefile 文件，把 faac 链接到工程文件中 

ABLMediaServer-2022-02-28 【增加录像保存、查询录像、录像下载功能】
1、修正媒体分发类中的音频数据分发 
	if (strcmp(szAudioCodec, "AAC") == 0)
		pClient->PushAudio(szAudio, nLength, m_mediaCodecInfo.szAudioName, nChannels, SampleRate);
	else
	{//G711A 、G711U 
		if (ABL_MediaServerPort.nG711ConvertAAC == 1)
		{
			if(strcmp(szAudioCodec, "G711_A") == 0 || strcmp(szAudioCodec, "G711_U") == 0)
			   pClient->PushAudio(pOutAACData, nOutAACDataLength, m_mediaCodecInfo.szAudioName, nChannels, SampleRate);
		}
		else
		   pClient->PushAudio(szAudio, nLength, m_mediaCodecInfo.szAudioName, nChannels, SampleRate);
	}

2、修正	http 代理拉流时设置h265的 payload = e_rtpdepkt_st_h265
  if (strcmp(szVideoName, "H264") == 0)
	 rtp_depacket_setpayload(hRtpHandle[0], nVideoPayload, e_rtpdepkt_st_h264);
  else if (strcmp(szVideoName, "H265") == 0)
	 rtp_depacket_setpayload(hRtpHandle[0], nVideoPayload, e_rtpdepkt_st_h265);
	
ABLMediaServer-2022-02-27 【增加录像保存、查询录像、录像下载功能】
1、如果转码，直接设置 bGetSDP = false ,这样 sdp 就会使用音视频参数来生成 sdp  
	bool bGetSDP = false;
	if (ABL_MediaServerPort.nG711ConvertAAC == 0)
		bGetSDP = pMediaSource->GethttpSDPContent(&sdpContent);
	else
		bGetSDP = false;
		
2、增加打印http 端口，htt-mp4 端口		
	WriteLog(Log_Debug, "从配置文件中读取到 \r\n运行参数：http = %d, http = %d , rtmp = %d ,http-flv = %d ,ws-flv = %d ,http-mp4 = %d, nHlsPort = %d , nHlsEnable = %d nHLSCutType = %d \r\n 网络接收线程数量 RecvThreadCount = %d 网络发送线程数量 SendThreadCount = %d ",
		                     ABL_MediaServerPort.nHttpServerPort,ABL_MediaServerPort.nhttpPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nWSFlvPort, ABL_MediaServerPort.nHttpMp4Port, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nHlsEnable , ABL_MediaServerPort.nHLSCutType,
		                     ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount);

ABLMediaServer-2022-02-25 【增加录像保存、查询录像、录像下载功能】
1、http代理拉流 增加字段 rtp负载方式 
   int                   nhttpRtpPayloadType;//rtp负载方式 0 未知 ，1 ES，2 PS ,用在http代理拉流时使用，
   
	//程序字段判断rtp负载类型 
	if (nhttpRtpPayloadType == httpRtpPayloadType_Unknow)
	{
		//PS 头
		if(memcmp(netDataCache+ (nNetStart + 12), psHeadFlag,4) == 0)
			nhttpRtpPayloadType = httpRtpPayloadType_PS;
		else
			nhttpRtpPayloadType = httpRtpPayloadType_ES;

		StartRtpPsDemux();//根据rtp负载类型，启动rtp、PS解包 
	}

2、增加 g711a、g711u 转码为aac  
	 
	bool   CMediaStreamSource::ConvertG711ToAAC(int nCodec, unsigned char* pG711, int nBytes)
	{
		if ( pG711 == NULL || nBytes <= 0)
			return false;

		if (nCodec == FLV_AUDIO_G711A)
			alaw_to_pcm16(nBytes, (const char*)pG711, g711toPCM);
		else if (nCodec == FLV_AUDIO_G711U)
			ulaw_to_pcm16(nBytes, (const char*)pG711, g711toPCM);
		else
			return false;

		if (1024 * 16 - nG711ToPCMCacheLength > 640)
		{
			memcpy(g711ToPCMCache + nG711ToPCMCacheLength, g711toPCM, 640);
			nG711ToPCMCacheLength += 640;
		}

		int nGet = 0;
		if (nG711ToPCMCacheLength >= nAACEncodeLength)
		{
			memcpy(aacEnc.pbPCMBuffer, g711ToPCMCache, nAACEncodeLength);
			aacEnc.EncodecAAC(&nRetunEncodeLength);
			if (nRetunEncodeLength > 0)
			{
				PushAudio((unsigned char*)aacEnc.pbAACBuffer, nRetunEncodeLength, "AAC", 1, 8000);
			}

			memmove(g711ToPCMCache, g711ToPCMCache + nAACEncodeLength, nG711ToPCMCacheLength - nAACEncodeLength);
			nG711ToPCMCacheLength = nG711ToPCMCacheLength - nAACEncodeLength;

			return true;
		}
		else
			return false; //不够AAC音频长度
	}
	
ABLMediaServer-2022-02-23 【增加录像保存、查询录像、录像下载功能】
1、修改makefile 文件 ps ,rtp 打包，解码都采用 gcc 4.8 编译 
	INCLUDES = -I../boost_lib/include
	LIBS = -L../boost_lib/lib -lboost_system -lboost_thread -lboost_log -lboost_regex -lboost_filesystem -lboost_date_time -lboost_chrono -lboost_atomic 

2、修改 ABLMediaServer 的 Makefile 文件 
	INCLUDES = -I../Linux/boost_lib/include \
			   -I../rapidjson-master/include \
			   -I../media-server-master/libflv/include \
			   -I../media-server-master/librtmp/include \
			   -I../media-server-master/libmpeg/include \
			   -I../media-server-master/libhls/include \
			   -I../media-server-master/libmov/include 
	LIBS = -L../bin \
		   -L../Linux/boost_lib/lib -lboost_system -lboost_thread -lboost_log -lboost_regex -lboost_filesystem -lboost_date_time -lboost_chrono -lboost_atomic -lrtmp -lflv -lmpeg -lhls -lmov -lrtp

		
ABLMediaServer-2022-02-22 【增加录像保存、查询录像、录像下载功能】
1、找到linux下，网络启动失败的原因，是makefile 编译 libXHNetSDK.so 方式不同造成网络启动失败 


ABLMediaServer-2022-02-21 【增加录像保存、查询录像、录像下载功能】
1、修改linux版本的打包库 rtppacket ，增加由外部指定时间戳

2、修改linux版本所有makefile文件，指定boost路径 

ABLMediaServer-2022-02-20 【增加录像保存、查询录像、录像下载功能】
1、ws-flv 输出时增加字段 Sec_WebSocket_Protocol ，从请求者获取数值 
  //获取
  wsParse.GetFieldValue("Sec_WebSocket_Protocol", szSec_WebSocket_Protocol);

  //回复
  sprintf(szWebSocketResponse, "HTTP/1.1 101 Switching Protocol\r\nAccess-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Origin: %s\r\nConnection: Upgrade\r\nDate: Mon, Nov 08 2021 01:52:45 GMT\r\nKeep-Alive: timeout=30, max=100\r\nSec-WebSocket-Accept: %s\r\nServer: %s\r\nUpgrade: websocket\r\nSec_WebSocket_Protocol: %s\r\n\r\n", szOrigin, szResponseClientKey, MediaServerVerson, szSec_WebSocket_Protocol);

ABLMediaServer-2022-02-18 【增加录像保存、查询录像、录像下载功能】
1、打印输出 key 时 ，使用 %llu 64位整型。 					
	if (tmpMediaSource->nMediaSourceType == MediaSourceType_LiveMedia)
	{//实况播放
		sprintf(szTemp2, "{\"key\":%llu,\"app\":\"%s\",\"stream\":\"%s\",\"status\":%s,\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"url\":{\"http\":\"http://%s:%d/%s/%s\",\"rtmp\":\"rtmp://%s:%d/%s/%s\",\"http-flv\":\"http://%s:%d/%s/%s.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s.flv\",\"http-mp4\":\"http://%s:%d/%s/%s.mp4\",\"http-hls\":\"http://%s:%d/%s/%s.m3u8\"}},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, tmpMediaSource->enable_mp4 == true ? "true" : "false", pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.nWidth, tmpMediaSource->m_mediaCodecInfo.nHeight, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate,
			ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
	}
	else
	{//录像点播
		sprintf(szTemp2, "{\"key\":%llu,\"app\":\"%s\",\"stream\":\"%s\",\"status\":%s,\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"url\":{\"http\":\"http://%s:%d/%s/%s\",\"rtmp\":\"rtmp://%s:%d/%s/%s\",\"http-flv\":\"http://%s:%d/%s/%s.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s.flv\",\"http-mp4\":\"http://%s:%d/%s/%s.mp4\"}},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, tmpMediaSource->enable_mp4 == true ? "true" : "false", pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.nWidth, tmpMediaSource->m_mediaCodecInfo.nHeight, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate,
			ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
	}
	
2、国标接入以UDP方式时，如果绑定2个端口期中一个失败，都要关闭，然后设置 nRet = 2 （启动国标接收失败）
	 }else
	 {//期中有一个端口绑定失败 
			XHNetSDK_DestoryUdp(nMediaClient);//关闭 rtp 
			XHNetSDK_DestoryUdp(nMediaClient2);//关闭 rtcp 
			nRet = 2 ;//标识为不成功 
	 }

ABLMediaServer-2022-02-17 【增加录像保存、查询录像、录像下载功能】
1、国标的初始端口修改为 10002 ，因为 10000用于接收rtp包 。
   unsigned short    ABL_nGB28181Port = 10002 ;

2、国标端口每次递增 2 ，偶数用于接收数 ，奇数用于rtcp包 
   do
   {
     nRet = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);
	 if(nRet != 0)
	  ABL_nGB28181Port += 2;
   } while (nRet != 0);
 
3、在几栏CNetRevcBase 的 InputNetData 函数增加一个参数 void* address ，在回复rtcp包需要用到 
	 class CNetRevcBase
	 {
	  public:
	   CNetRevcBase();
	   ~CNetRevcBase() ;
	   
	   virtual int InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength,void* address) = 0;//接收网络数据
	
	其他所以派生类的 InputNetData 函数 都要 增加这个变量 
	
4、增加rtcp回复包类
    CNetGB28181ServerRTCP::CNetGB28181ServerRTCP(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
		功能：
			负责接收国标的rtcp包，并且回复rtcp包 
			 
		日期    2022-02-17
		作者    罗家兄弟
		QQ      79941308
		E-Mail  79941308@qq.com

5、国标UDP方式的话，增加创建rtcp端口以及RTCP接收回复类实例 
	   if (atoi(m_openRtpServerStruct.port) == 0)
	   {
		  do
		  {
		   nRet  = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);//rtp
		   nRet2 = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port+1, NULL, &nMediaClient2, onread, 1);//rtcp
			if(nRet != 0 || nRet2 != 0 )
			 ABL_nGB28181Port += 2;
		  } while (nRet != 0 || nRet2 != 0 );
	   }
	   else
	   {
		   nRet = XHNetSDK_BuildUdp(NULL, atoi(m_openRtpServerStruct.port), NULL, &nMediaClient, onread, 1);
		   nRet2 = XHNetSDK_BuildUdp(NULL, atoi(m_openRtpServerStruct.port)+1, NULL, &nMediaClient2, onread, 1);
	   }

	 if(nRet == 0 && nRet2 == 0)
	 {//rtp ,rtcp 都绑定成功
		 boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerUDP, 0, nMediaClient, "", ABL_nGB28181Port, szTemp);
		 boost::shared_ptr<CNetRevcBase> pClientRtcp = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerRTCP, 0, nMediaClient2, "", ABL_nGB28181Port+1, szTemp);
		 if (pClient != NULL)
		 {
			pClient->hParent     = nClient; //记录国标代理的句柄号，当国标发流、收流断线时，能同时销毁代理句柄资源 
			pClient->m_gbPayload = atoi(m_openRtpServerStruct.payload);//更新为正确的paylad
			pClient->nClientRtcp = nMediaClient2;//rtcp 连接
			memcpy((unsigned char*)&pClient->m_addStreamProxyStruct, (unsigned char*)&m_addStreamProxyStruct, sizeof(m_addStreamProxyStruct));
		 }
	 }

ABLMediaServer-2022-02-15 【增加录像保存、查询录像、录像下载功能】
1、创建根据录像文件创建点播的录像媒体源，把
	boost::shared_ptr<CMediaStreamSource>  CNetRevcBase::CreateReplayClient(char* szReplayURL,uint64_t* nReturnReplayClient)
	{
		....  
	  
		nMediaSourceType = MediaSourceType_ReplayMedia;
		duration = pTempSource->nMediaDuration;
	}
	
	
2、在组装根据媒体信息拼装 SDP 信息，增加 a=range: npt=0-180.00 字段，返回录像回放的时间长 duration，单位秒 
	bool CNethttpServer::GethttpSDPFromMediaStreamSource(httpSDPContentStruct sdpContent, bool bGetFlag)
	{
		memset(szhttpSDPContent, 0x00, sizeof(szhttpSDPContent));

		//视频
		nVideoSSRC = rand();
		memset((char*)&optionVideo, 0x00, sizeof(optionVideo));
		if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName,"H264") == 0)
		{
			optionVideo.streamtype = e_rtppkt_st_h264;
			if (bGetFlag)
				nVideoPayload = sdpContent.nVidePayload;
			else
				nVideoPayload = 96;
			if(duration == 0)
			  sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\na=range: npt=0-\r\nm=video 6000 RTP/AVP %d\r\nb=AS:832\r\na=rtpmap:%d H264/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n", nVideoPayload, nVideoPayload, nVideoPayload);
			else 
			  sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\na=range: npt=0-%.3f\r\nm=video 6000 RTP/AVP %d\r\nb=AS:832\r\na=rtpmap:%d H264/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n",(double)duration, nVideoPayload, nVideoPayload, nVideoPayload);
		}
		else if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName, "H265") == 0)
		{
			optionVideo.streamtype = e_rtppkt_st_h265;
			if (bGetFlag)
				nVideoPayload = sdpContent.nVidePayload;
			else
				nVideoPayload = 97;
			if(duration == 0)
			  sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\na=range: npt=0-\r\nm=video 6000 RTP/AVP %d\r\nb=AS:3007\r\na=rtpmap:%d H265/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n", nVideoPayload, nVideoPayload, nVideoPayload);
			else
			  sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\na=range: npt=0-%.3f\r\nm=video 6000 RTP/AVP %d\r\nb=AS:3007\r\na=rtpmap:%d H265/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n",(double)duration, nVideoPayload, nVideoPayload, nVideoPayload);
		}
		else
			return false;


ABLMediaServer-2022-02-13 【增加录像保存、查询录像、录像下载功能】
1 rtp打包输入参数增加时间戳，支持由外部指定视频、音频时间戳,判断标准 timestamp 为0 时使用内部自动
  增量时间戳，当大于0时使用外部指定时间戳 
	struct _rtp_packet_input
	{
		uint32_t handle;
		uint32_t ssrc;
		uint8_t* data;
		uint32_t datasize;
		uint32_t timestamp;
		_rtp_packet_input()
		{
			handle = 0 ;
			ssrc = 0;
			data = NULL;
			datasize = 0 ;
			timestamp = 0 ;
		}
	};
	
	int CNethttpServer::SendVideo()
	{
		nRecvDataTimerBySecond = 0;

		unsigned char* pData = NULL;
		int            nLength = 0;
		uint32_t       nVdeoFrameNumber = 0;
		if ((pData = m_videoFifo.pop(&nLength)) != NULL)
		{
			inputVideo.data = pData;
			inputVideo.datasize = nLength;
	 
			if (nMediaSourceType == MediaSourceType_ReplayMedia)
			{//如果是录像回放，前面4个字节是视频帧序号，根据这个帧序号生成时间戳直接送入rtp打包
				inputVideo.data = pData + 4;
				inputVideo.datasize = nLength - 4;
				memcpy((char*)&nVdeoFrameNumber, pData, sizeof(uint32_t));
				inputVideo.timestamp = nVdeoFrameNumber * 3600 ;
			}
			rtp_packet_input(&inputVideo);

			m_videoFifo.pop_front();
		}

		return 0;
	}

2、在录像回放时，用两个pts差来计算已经播放了多少帧视频，音频，包括拖动播放，否则拖动播放的进度条显示有误
 
    //计算视频 
	if (pThis->nVideoFirstPTS != 0)
		pThis->nReadVideoFrameCount = ((pts - pThis->nVideoFirstPTS) / (1000 / pThis->mediaCodecInfo.nVideoFrameRate));
	
    //计算音频	
	pThis->nReadAudioFrameCount = ((pts - pThis->nAudioFirstPTS) / pThis->mediaCodecInfo.nBaseAddAudioTimeStamp);
	
	//把已经播放帧数，写入fifo ,长度4个字节
	memcpy(pThis->s_packet, (unsigned char*)&pThis->nReadVideoFrameCount, sizeof(pThis->nReadVideoFrameCount));
	if (abs(pThis->m_dScaleValue - 8.0) <= 0.01 || abs(pThis->m_dScaleValue - 16.0) <= 0.01)
	{//抽帧
		if (pThis->CheckVideoIsIFrame(pThis->mediaCodecInfo.szVideoName, pThis->s_packet+4, pThis->nRetLength))
			pThis->pMediaSource->PushVideo(pThis->s_packet, pThis->nRetLength+4, pThis->mediaCodecInfo.szVideoName);
	}
	else
		pThis->pMediaSource->PushVideo(pThis->s_packet, pThis->nRetLength+4, pThis->mediaCodecInfo.szVideoName);

3、创建点播视频源是， 指定视频源为录像点播
	boost::shared_ptr<CMediaStreamSource> CNetRevcBase::CreateReplayClient(char* szReplayURL,uint64_t* nReturnReplayClient)
	{
	#ifdef OS_System_Windows
		sprintf(szRequestReplayRecordFile, "%s%s\\%s\\%s.mp4", ABL_MediaServerPort.recordPath, szSplliterApp, szSplliterStream, szReplayRecordFile);
	#else
		sprintf(szRequestReplayRecordFile, "%s%s/%s/%s.mp4", ABL_MediaServerPort.recordPath, szSplliterApp, szSplliterStream, szReplayRecordFile);
	#endif

		boost::shared_ptr<CMediaStreamSource> pTempSource = GetMediaStreamSource(szReplayURL);
		if (pTempSource == NULL)
		{
		   ...
		}
		
	//指定视频源为录像点播 	
	nMediaSourceType = MediaSourceType_ReplayMedia;

4、在http ,rtmp ,flv ,ws-flv , http-mp4 时点播输出时，都要判断是否是点播视频 ，如果是点播视频，要把前面的帧数量移除掉
	if((pData = m_videoFifo.pop(&nLength)) != NULL )
	{
		if (nMediaSourceType == MediaSourceType_LiveMedia)//实况播放
			MuxerVideoFlV(mediaCodecInfo.szVideoName, pData, nLength);
		else//点播视频，要把前面的帧数量移除掉
			MuxerVideoFlV(mediaCodecInfo.szVideoName, pData+4, nLength-4);
			
		m_videoFifo.pop_front();
	}
 

ABLMediaServer-2022-02-11 【增加录像保存、查询录像、录像下载功能】
1、过期的录像文件不再删除，采用覆盖内容的方法，文件名字修改为新文件名字 
	//修改过期录像文件
	bool  CRecordFileSource::UpdateExpireRecordFile(char* szNewFileName)
	{
		std::lock_guard<std::mutex> lock(RecordFileLock);
		uint64_t nGetFile;
		uint64_t nSecond = 0; 
		char    szDateTime[128] = { 0 };
		bool    bUpdateFlag = false;

		if (fileList.size() <= 0 )
		{
			WriteLog(Log_Debug, "UpdateExpireRecordFile %s 尚未有录像文件 ,新名字为 %s ", m_szShareURL, szNewFileName);
			return false ; 
		}

		while (fileList.size() > 0 )
		{
			nGetFile = fileList.front();
			sprintf(szDateTime, "%llu", nGetFile);
			nSecond = GetCurrentSecond() - GetCurrentSecondByTime(szDateTime);
			if (nSecond > (ABL_MediaServerPort.fileKeepMaxTime * 3600))
			{
				fileList.pop_front();
	#ifdef OS_System_Windows
				sprintf(szDeleteFile, "%s%s\\%s\\%s.mp4", ABL_MediaServerPort.recordPath, m_app, m_stream, szDateTime);
	#else 
				sprintf(szDeleteFile, "%s%s/%s/%s.mp4", ABL_MediaServerPort.recordPath, m_app, m_stream, szDateTime);
	#endif
				//如果修改失败，回收以后再次修改
				if (rename(szDeleteFile,szNewFileName) != 0 )
				{
					fileList.push_back(nGetFile); 
					WriteLog(Log_Debug, "UpdateExpireRecordFile %s 修改文件 %llu.mp4 失败，回收以后再修改 ", m_szShareURL, nGetFile);
				}
				else
				{
				  bUpdateFlag = true;
				  WriteLog(Log_Debug, "UpdateExpireRecordFile %s 修改文件成功 %s,新名字为 %s ",m_szShareURL,szDeleteFile, szNewFileName);
				  break;
				}
			}
			else
				break;
		}

		if(!bUpdateFlag)
			WriteLog(Log_Debug, "UpdateExpireRecordFile %s 没有录像文件到期 ,新名字为 %s ", m_szShareURL, szNewFileName);
	 
		return bUpdateFlag ;
	}

2、如果如果录像文件存在就修改内存，如果文件不到期则创建新的录像文件 
	boost::shared_ptr<CRecordFileSource> pRecord = GetRecordFileSource(pNetServerHttpMp4->m_szShareMediaURL);
	if (pRecord)
	{
		bUpdateFlag = pRecord->UpdateExpireRecordFile(pNetServerHttpMp4->szFileName);
		if (bUpdateFlag)
		{
			pNetServerHttpMp4->fWriteMP4 = fopen(pNetServerHttpMp4->szFileName, "r+b");
			if (pNetServerHttpMp4->fWriteMP4)
				fseek(pNetServerHttpMp4->fWriteMP4, 0, SEEK_SET);
		}
		else
		   pNetServerHttpMp4->fWriteMP4 = fopen(pNetServerHttpMp4->szFileName, "wb");

		if (pNetServerHttpMp4->fWriteMP4)
		{
		   pRecord->AddRecordFile(pNetServerHttpMp4->szFileNameOrder);
		   WriteLog(Log_Debug, "CStreamRecordFMP4 = %X %s 增加录像文件 nClient = %llu ,nMediaClient = %llu szFileNameOrder %s ", pNetServerHttpMp4, pNetServerHttpMp4->m_szShareMediaURL, pNetServerHttpMp4->nClient, pNetServerHttpMp4->nMediaClient, pNetServerHttpMp4->szFileNameOrder);
		 }
	}
	
ABLMediaServer-2022-02-10 【增加录像保存、查询录像、录像下载功能】
1、支持MP4文件以http协议进行极速下载，最大下载速度 30M/S  
	int CReadRecordFileInput::ProcessNetData() 
	{
		std::lock_guard<std::mutex> lock(readRecordFileInputLock);
		nRecvDataTimerBySecond = 0;

		if (mov == NULL || m_bPauseFlag == true )
		{
			mov_readerTime = GetTickCount64();
			Sleep(10);
			RecordReplayThreadPool->InsertIntoTask(nClient);
			return -1;
		}

		if (nAVType == AVType_Video)
		{//读取视频
			if ((abs(m_dScaleValue - 8.0) <= 0.01 || abs(m_dScaleValue - 16.0) <= 0.01))
			{//8、16倍速不需要等待 
				mov_readerTime = GetTickCount64();
				nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);

				if (nReadVideoFrameCount % 25 == 0)
				{
					if (abs(m_dScaleValue - 8.0) <= 0.01)
						Sleep(60);
					else
						Sleep(30);
				}
			}
			else if (abs(m_dScaleValue - 255.0) <= 0.01 )
			{//http录像下载
				mov_readerTime = GetTickCount64();
				nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);
				Sleep(5);
			}
			
2、当不是录像下载时，才能重新移动到文件头，重新播放。			
	if (ABL_MediaServerPort.fileRepeat == 1 && !(abs(m_dScaleValue - 255.0) <= 0.01) )
	{//当文件读取完毕，并且不是http下载时，才重新读取文件
		int64_t nStartTime = 0;
		int nRet = mov_reader_seek(mov, &nStartTime);
		WriteLog(Log_Debug, "ProcessNetData 文件读取完毕 ,nClient = %llu ,现在重新再次播放 ,nRet = %d ", nClient, nRet);
	}
	else
	{
	   WriteLog(Log_Debug, "ProcessNetData 文件读取完毕 ,nClient = %llu ", nClient);
	   DeleteNetRevcBaseClient(nClient);
	   return -1;
	}

3、把Sleep(5) 修改为 Sleep(2) 	
	{//读取视频的时间尚未到，需要Sleep(2) ,否则CPU会狂跑
		if ( !(abs(m_dScaleValue - 8.0) <= 0.01 || abs(m_dScaleValue - 16.0) <= 0.01) )
		   Sleep(2); //8倍速、16倍速，不需要Sleeep
	}

ABLMediaServer-2022-02-09 【增加录像保存、查询录像、录像下载功能】
1、媒体源的构造函数增加两个参数, MediaSourceType nSourceType （实况、录像点播）, uint32_t nDuration （录像文件时长）
	CMediaStreamSource_ptr CreateMediaStreamSource(char* szURL, uint64_t nClient, MediaSourceType nSourceType, uint32_t nDuration)
	{
		std::lock_guard<std::mutex> lock(ABL_CMediaStreamSourceMapLock);

		CMediaStreamSource_ptr pXHClient = NULL;
		string      strURL = szURL;
		try
		{
			do
			{
			   pXHClient = boost::make_shared<CMediaStreamSource>(szURL,nClient, nSourceType, nDuration);
			} while (pXHClient == NULL);
		}
		catch (const std::exception &e)
		{
			return NULL;
		}

		std::pair<boost::unordered_map<string, CMediaStreamSource_ptr>::iterator, bool> ret =
			xh_ABLMediaStreamSourceMap.insert(std::make_pair(strURL, pXHClient));
		if (!ret.second)
		{
			pXHClient.reset();
			return NULL;
		}

		return pXHClient;
	}

2、	 创建录像点播媒体源 时，需要增加提供两个参数 MediaSourceType_ReplayMedia（MediaSourceType_LiveMedia）, duration
	
		pMediaSource = CreateMediaStreamSource(m_szShareMediaURL, hClient, MediaSourceType_ReplayMedia, duration / 1000 );
		if (pMediaSource == NULL)
		{
			WriteLog(Log_Debug, "CReadRecordFileInput 创建媒体源失败 =  %X ,nClient = %llu m_szShareMediaURL %s ", this, hClient, m_szShareMediaURL);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return;
		}

ABLMediaServer-2022-02-08 【增加录像保存、查询录像、录像下载功能】
1、创建媒体源时，需要指定媒体源的类型（实况、录像点播），需要指定录像点播的总时长(单位秒)
    MediaSourceType        nMediaSourceType;//媒体源类型，实况播放，录像点播
    uint32_t               nMediaDuration;//媒体源时长，单位秒，当录像点播时有效
   
    //创建录像点播媒体源
	pMediaSource = CreateMediaStreamSource(m_szShareMediaURL, hClient);
	if(pMediaSource == NULL)
	{
		WriteLog(Log_Debug, "CReadRecordFileInput 创建媒体源失败 =  %X ,nClient = %llu m_szShareMediaURL %s ", this, hClient, m_szShareMediaURL);
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
 		return;
	}
	pMediaSource->nMediaSourceType = MediaSourceType_ReplayMedia; //媒体源类型，实况播放，录像点播
	pMediaSource->nMediaDuration = duration;                      //媒体源时长，单位秒，当录像点播时有效
	
2、录像文件点播时不支持 hls 切片回放，把HLS切片关闭。	
	if (ABL_MediaServerPort.nHlsEnable == 1 && nMediaSourceType == MediaSourceType_LiveMedia)
	{

    //url 去掉 hls 	
	if (tmpMediaSource->nMediaSourceType == MediaSourceType_LiveMedia)
	{//实况播放
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"status\":%s,\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"url\":{\"http\":\"http://%s:%d/%s/%s\",\"rtmp\":\"rtmp://%s:%d/%s/%s\",\"http-flv\":\"http://%s:%d/%s/%s.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s.flv\",\"http-mp4\":\"http://%s:%d/%s/%s.mp4\",\"http-hls\":\"http://%s:%d/%s/%s.m3u8\"}},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, tmpMediaSource->enable_mp4 == true ? "true" : "false", pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.nWidth, tmpMediaSource->m_mediaCodecInfo.nHeight, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate,
			ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
	}
	else
	{//录像点播
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"status\":%s,\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"url\":{\"http\":\"http://%s:%d/%s/%s\",\"rtmp\":\"rtmp://%s:%d/%s/%s\",\"http-flv\":\"http://%s:%d/%s/%s.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s.flv\",\"http-mp4\":\"http://%s:%d/%s/%s.mp4\"}},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, tmpMediaSource->enable_mp4 == true ? "true" : "false", pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.nWidth, tmpMediaSource->m_mediaCodecInfo.nHeight, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate,
			ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
	}

3、拖动时间戳超出文件最大时长，要直接返回
	if (nTimestamp > (duration / 1000))
	{
		WriteLog(Log_Debug, "ReaplyFileSeek 拖动时间戳超出文件最大时长 ,nClient = %llu ,nTimestamp = %llu ,duration = %d ", nClient, nTimestamp, duration / 1000 );
		return false; 
	}
	
ABLMediaServer-2022-02-07 【增加录像保存、查询录像、录像下载功能】
1、优化文件流的各种倍速的计算
	if ((abs(m_dScaleValue - 8.0) <= 0.01 || abs(m_dScaleValue - 16.0) <= 0.01))
	{//8、16倍速不需要等待 
		mov_readerTime = GetTickCount64();
		nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);

		if (nReadVideoFrameCount % 25 == 0)
		{
			if (abs(m_dScaleValue - 8.0) <= 0.01)
				Sleep(120);
			else
				Sleep(65);
		}
	}
	else if ( (GetTickCount64() - mov_readerTime) >= (nVidepSpeedTime - 2))
	{
	   mov_readerTime = GetTickCount64();
	   nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);
	}
	else 
	{//读取视频的时间尚未到，需要Sleep(5) ,否则CPU会狂跑
		if ( !(abs(m_dScaleValue - 8.0) <= 0.01 || abs(m_dScaleValue - 16.0) <= 0.01) )
		   Sleep(5); //8倍速、16倍速，不需要Sleeep
	}
	nReadVideoFrameCount ++;


2、修正视频帧速度计算 
	if (m_nVideoFrameSpeed >= 24 && m_nVideoFrameSpeed <= 29)
		m_nVideoFrameSpeed = 25;
	else if (m_nVideoFrameSpeed >= 29)
		m_nVideoFrameSpeed = 30;

3、http点播支持暂停播放		
	else if (memcmp(pRecvData, "PAUSE ", 6) == 0 && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
	{
		boost::shared_ptr<CNetRevcBase> pBasePtr = GetNetRevcBaseClientNoLock(nReplayClient);
		if (pBasePtr)
		{
			CReadRecordFileInput* pReplayPtr = (CReadRecordFileInput*)pBasePtr.get();
			pReplayPtr->UpdatePauseFlag(true);//暂停播放
		}
		
		//回复暂停命令
		sprintf(szResponseBuffer, "http/1.0 200 OK\r\nServer: %s\r\nCSeq: %s\r\nSession: %lld\r\nRTP-Info: %s\r\n\r\n", MediaServerVerson, szCSeq, currentSession, szCurhttpURL);
		nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		if (nSendRet != 0)
		{
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return;
		}
	
		WriteLog(Log_Debug, "收到断开 暂停 命令，立即执行暂停 nClient = %llu , nReplayClient = %llu ", nClient, nReplayClient);
 	}
	
4、实现http点播录像时,支持改变播放速度 ,支持拖动播放 
	  boost::shared_ptr<CNetRevcBase> pBasePtr = GetNetRevcBaseClientNoLock(nReplayClient);
	  if (pBasePtr )
	  {
		  CReadRecordFileInput* pReplayPtr = (CReadRecordFileInput*)pBasePtr.get();
		  pReplayPtr->UpdatePauseFlag(false);//继续播放

		  //更新点播速度			 
		  char szScale[256] = { 0 };
		  GetFieldValue("Scale", szScale);
		  if(strlen(szScale) > 0 )
		  {
			  pReplayPtr->UpdateReplaySpeed(atof(szScale));
		  } 

		  //实现拖动播放
		  char   szRange[256] = { 0 };
		  string strRange;
		  int    nPos1 = 0, nPos2 = 0;
		  char   szRangeValue[256] = { 0 };
		  GetFieldValue("Range", szRange);
		  if (strlen(szRange) > 0)
		  {
			  strRange = szRange;
			  nPos1 = strRange.find("npt=", 0);
			  nPos2 = strRange.find("-", 0);
			  if (nPos1 >= 0 && nPos2 > 0)
			  {
				  memcpy(szRangeValue, szRange + nPos1 + 4, nPos2 - nPos1 - 4);
				  if(atoi(szRangeValue) > 0 )
					 pReplayPtr->ReaplyFileSeek(atoi(szRangeValue));
			  }
		  }

	  }
	}

5、mp4录像切片文件中,统一使用 GetTickCount64()函数,否则在一些Windows Server 版本出问题.
	bool CStreamRecordFMP4::writeTSBufferToMP4File(unsigned char* pTSData, int nLength)
	{
		if (fWriteMP4 && pTSData != NULL && nLength > 0)
		{
			fwrite(pTSData, 1, nLength, fWriteMP4);
			fflush(fWriteMP4);

			if (GetTickCount64() - nCreateDateTime >= 1000 * ABL_MediaServerPort.fileSecond)
			{
				fclose(fWriteMP4);
	#ifdef OS_System_Windows
				SYSTEMTIME st;
				GetLocalTime(&st);
				sprintf(szFileName, "%s%04d%02d%02d%02d%02d%02d.mp4", szRecordPath, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
				sprintf(szFileNameOrder,"%04d%02d%02d%02d%02d%02d.mp4", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);;
	#else
				time_t now;
				time(&now);
				struct tm *local;
				local = localtime(&now);
				sprintf(szFileName, "%s%04d%02d%02d%02d%02d%02d.mp4", szRecordPath, local->tm_year + 1900, local->tm_mon+1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);
				sprintf(szFileNameOrder, "%04d%02d%02d%02d%02d%02d.mp4", local->tm_year + 1900, local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);;
	#endif
				fWriteMP4 = fopen(szFileName, "wb");
				if (fWriteMP4 != NULL)
				{
					fwrite(s_packet, 1, s_packetLength, fWriteMP4);
					fflush(fWriteMP4);
					
					boost::shared_ptr<CRecordFileSource> pRecord = GetRecordFileSource(m_szShareMediaURL);
					if (pRecord)
					{
					   pRecord->AddRecordFile(szFileNameOrder);
					   WriteLog(Log_Debug, "CStreamRecordFMP4 = %X %s 增加录像文件 nClient = %llu ,nMediaClient = %llu szFileNameOrder %s ", this, m_szShareMediaURL, nClient, nMediaClient, szFileNameOrder);
					}				
				}

				nCreateDateTime = GetTickCount64();
			}

			return true;
		}
		else
			return false;
	}

ABLMediaServer-2022-02-06 【增加录像保存、查询录像、录像下载功能】
1 、媒体源加入拷贝对象时，需要检测是否已经存在
	bool CMediaStreamSource::AddClientToMap(NETHANDLE nClient)
	{
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		MediaSendMap::iterator it;
		it = mediaSendMap.find(nClient);
		if (it != mediaSendMap.end())
		{
			WriteLog(Log_Debug, "客户端 %llu 已经存在媒体资源 %s 拷贝线程中 ", nClient,m_szURL);
			return false;
		}
		
2、发送线程池中，也需要检测是否存在对象，如果已经加入过不能再加入
	//查找客户端是否存在发送线程中
	bool CMediaSendThreadPool::findClientAtArray(uint64_t nClient)
	{
		int i = 0;
		int j = 0;
		for ( i = 0; i < nCreateThreadProcessCount; i++)
		{
			for ( j= 0;j < threadContainClient[i].nMaxClientArraySize ;j++)
			{
				if (threadContainClient[i].nClients[j] == nClient)
				{
					WriteLog(Log_Debug, "把客户端 nClient = %llu 已经存在媒体发送线程池中，不需要再加入 ,nThreadID = %d ", nClient, i);
					return true;
				}
			}
		}
		return false;
	}

	//把客户端加入发送线程池 
	bool  CMediaSendThreadPool::AddClientToThreadPool(uint64_t nClient)
	{
		std::lock_guard<std::mutex> lock(threadLock);
		
		//查找客户端是否存在发送线程中
		if (findClientAtArray(nClient))
			return false;
			
3、更新像回放速度
	bool CReadRecordFileInput::UpdateReplaySpeed(double dScaleValue)
	{
		double dCalcSpeed = 40.00;
		dCalcSpeed = (dBaseSpeed / dScaleValue);
		nVidepSpeedTime = (int)dCalcSpeed;
		m_dScaleValue = dScaleValue;
		WriteLog(Log_Debug, "UpdateReplaySpeed 更新录像回放速度 ,nClient = %llu ,dCalcSpeed = %.2f, nVidepSpeedTime = %d  ", nClient, dCalcSpeed, nVidepSpeedTime);

		return true;
	}

4、实现录像回放暂停、继续播放
	bool CReadRecordFileInput::UpdatePauseFlag(bool bFlag)
	{
		m_bPauseFlag = bFlag;
		WriteLog(Log_Debug, "UpdatePauseFlag 更新暂停播放标志 ,nClient = %llu ,m_bPauseFlag = %d  ", nClient, m_bPauseFlag);
		return true;
	}

5、实现录像http点播时拖动播放
	bool  CReadRecordFileInput::ReaplyFileSeek(uint64_t nTimestamp)
	{
		std::lock_guard<std::mutex> lock(readRecordFileInputLock);
		if (mov == NULL || m_bPauseFlag == true)
			return false;
		int64_t nSeekToTime = m_nStartTimestamp + (nTimestamp * 1000) ;////开始的时间戳 加上 拖动到的时间戳 这样才正确
		int nRet = mov_reader_seek(mov, &nSeekToTime);
		WriteLog(Log_Debug, "ReaplyFileSeek 拖动播放 ,nClient = %llu ,nTimestamp = %llu ,nRet = %d ", nClient, nTimestamp, nRet);
	}


ABLMediaServer-2022-01-25 【增加录像保存、查询录像、录像下载功能】
1、把 mov_file_buffer.c 的文件移除掉，把里面的代码移动到 ReadRecordFileInput.cpp 文件
	#if defined(_WIN32) || defined(_WIN64)
	#define fseek64 _fseeki64
	#define ftell64 _ftelli64
	#elif defined(OS_LINUX)
	#define fseek64 fseeko64
	#define ftell64 ftello64
	#else
	#define fseek64 fseek
	#define ftell64 ftell
	#endif

	static int mov_file_read(void* fp, void* data, uint64_t bytes)
	{
		if (bytes == fread(data, 1, bytes, (FILE*)fp))
			return 0;
		return 0 != ferror((FILE*)fp) ? ferror((FILE*)fp) : -1 /*EOF*/;
	}

	static int mov_file_write(void* fp, const void* data, uint64_t bytes)
	{
		return bytes == fwrite(data, 1, bytes, (FILE*)fp) ? 0 : ferror((FILE*)fp);
	}

	static int mov_file_seek(void* fp, int64_t offset)
	{
		return fseek64((FILE*)fp, offset, SEEK_SET);
	}

	static int64_t mov_file_tell(void* fp)
	{
		return ftell64((FILE*)fp);
	}

	const struct mov_buffer_t* mov_file_buffer(void)
	{
		static struct mov_buffer_t s_io = {
			mov_file_read,
			mov_file_write,
			mov_file_seek,
			mov_file_tell,
		};
		return &s_io;
	}

2、根据录像路径查找所有录像文件 - linux 
	void FindHistoryRecordFile(char* szRecordPath)
	{
		struct dirent * filename;    // return value for readdir()
		DIR * dir;                   // return value for opendir()
		dir = opendir(szRecordPath);
		char  szTempPath[512] = { 0 };

		while ((filename = readdir(dir)) != NULL)
		{
			// get rid of "." and ".."
			if (strcmp(filename->d_name, ".") == 0 ||
				strcmp(filename->d_name, "..") == 0)
				continue;
				
			if (strlen(filename->d_name) > 0 )
			{
				//WriteLog(Log_Debug, "FindHistoryRecordFile ，路径 %s ", filename->d_name);

				struct dirent * filename2;     
				DIR *           dir2;                   
				memset(szTempPath, 0x00, sizeof(szTempPath));
				sprintf(szTempPath,"%s%s", szRecordPath, filename->d_name);
				dir2 = opendir(szTempPath);
	   
				while ((filename2 = readdir(dir2)) != NULL)
				{
					if (!(strcmp(filename2->d_name, ".") == 0 || strcmp(filename2->d_name, "..") == 0))
					{
						//WriteLog(Log_Debug, "FindHistoryRecordFile ，第2级路径 %s ", filename2->d_name);

						struct dirent * filename3;     
						DIR *           dir3;                   
						memset(szTempPath, 0x00, sizeof(szTempPath));
						sprintf(szTempPath,"%s%s/%s", szRecordPath, filename->d_name,filename2->d_name);
						dir3 = opendir(szTempPath);
						
						CRecordFileSource_ptr pRecord = CreateRecordFileSource(filename->d_name,filename2->d_name);
						
						while ((filename3 = readdir(dir3)) != NULL)
						{
							if (!(strcmp(filename3->d_name, ".") == 0 || strcmp(filename3->d_name, "..") == 0))
							{
								//WriteLog(Log_Debug, "FindHistoryRecordFile ,录像文件名字 %s ", filename3->d_name);
								if (pRecord)
								{
									pRecord->AddRecordFile(filename3->d_name);
								}
							}
						}
						closedir(dir3);
						pRecord->Sort();
						
					}
				}//while ((filename2 = readdir(dir2)) != NULL)
				closedir(dir2);
				
			}
		}//while ((filename = readdir(dir)) != NULL)
		closedir(dir);
	}

	
ABLMediaServer-2022-01-24 【增加录像保存、查询录像、录像下载功能】	
1、从参数配置读取到下载速度时 httpDownloadSpeed ，如果小于等于0 ，则赋值为 1
	if (ABL_MediaServerPort.httpDownloadSpeed > 10)
		ABL_MediaServerPort.httpDownloadSpeed = 10;
	else if (ABL_MediaServerPort.httpDownloadSpeed <= 0)
		ABL_MediaServerPort.httpDownloadSpeed = 1;
		
2、http 下载、或者 http-mp4点播时，	获取下载的速度，并且限制下载速度的范围
 	nHttpDownloadSpeed = atoi(szDownLoadSpeed);
	if (nHttpDownloadSpeed > 10)
		nHttpDownloadSpeed = 10;
	else if (nHttpDownloadSpeed <= 0)
		nHttpDownloadSpeed = 1;

3、http-mp4录像文件点播，暂时采用http下载文件的方式播放，不过下载速度为1倍速 download_speed=1	 
	sprintf(szTemp2, "{\"file\":\"%llu.mp4\",\"url\":{\"http\":\"http://%s:%d/%s/%s%s%llu\",\"rtmp\":\"rtmp://%s:%d/%s/%s%s%llu\",\"http-flv\":\"http://%s:%d/%s/%s%s%llu.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s%s%llu.flv\",\"http-mp4\":\"http://%s:%d/%s/%s%s%llu.mp4?download_speed=1\",\"download\":\"http://%s:%d/%s/%s%s%llu.mp4?download_speed=%d\"}},", *it2,
	ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
	ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
	ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
	ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
	ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
	ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2, ABL_MediaServerPort.httpDownloadSpeed);
	
4、【修复严重BUG】修复http-mp4 录像文件点播，要复位断线检测的变量 nRecvDataTimerBySecond ，否则断线检测会断开这个连接，
   因为 http-mp4 点播时，不需要 PushVideo ,也不需要 PushAudio, 录像点播是出发 ProcessNetData() 这个函数 
	int CNetServerHTTP_MP4::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(mediaMP4MapLock);
		nRecvDataTimerBySecond = 0 ;

	
5、http-mp4 点播时，原来的发送速度太快，需要减慢 	
	if (httpMp4Type == HttpMp4Type_Download && bCheckHttpMP4Flag == true && fFileMp4 != NULL)
    {//录像下载
	  if ( (GetTickCount64() - nCreateDateTime) >= (200 / nHttpDownloadSpeed) )
	  {
		nCreateDateTime = GetTickCount64();

		
ABLMediaServer-2022-01-23 【增加录像保存、查询录像、录像下载功能】	
1、在发送mp4文件下载时，增加Content-Length 字段，这样下载客户端就会知道文件下载完毕 
	nRecordFileSize = 1024 * 1024 * 100;
#ifdef OS_System_Windows
	struct _stat64 fileBuf;
	int error = _stat64(szRequestReplayRecordFile, &fileBuf);
	if (error == 0)
		nRecordFileSize = fileBuf.st_size;
#else 
	struct stat fileBuf;
	int error = stat(szRequestReplayRecordFile, &fileBuf);
	if (error == 0)
		nRecordFileSize = fileBuf.st_size;
#endif
	sprintf(httpResponseData, "HTTP/1.1 200 OK\r\nConnection: keep-alive\r\nContent-Type: video/mp4; charset=utf-8\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nContent-Length: %d\r\nServer: %s\r\n\r\n", nRecordFileSize, MediaServerVerson);

ABLMediaServer-2022-01-22 【增加录像保存、查询录像、录像下载功能】	
1、检测开始时间、结束时间 是否是数字的字符串（0 ~ 9）
	if ( boost::all(m_queryRecordListStruct.starttime, boost::is_digit()) == false || boost::all(m_queryRecordListStruct.endtime, boost::is_digit()) == false )
	{//检测开始时间、结束时间 是否是数字的字符串（0 ~ 9）
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[starttime , endtime ] error , must is number \"}", IndexApiCode_secretError);
		ResponseSuccess(szResponseBody);
		return false;
	}
	
2、检测查询时间间隔不能超过3天
	if (GetCurrentSecondByTime(m_queryRecordListStruct.endtime) - GetCurrentSecondByTime(m_queryRecordListStruct.starttime)  >  (3 * 24 * 3600))
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"query times No more than 3 days \"}", IndexApiCode_secretError, ABL_MediaServerPort.fileSecond);
		ResponseSuccess(szResponseBody);
		return false;
	}
	
3、更新读取文件的音频格式，视频格式到 CMediaSource 	
	//更新媒体源信息
	if (pThis->pMediaSource != NULL)
	{
		strcpy(pThis->pMediaSource->m_mediaCodecInfo.szAudioName, "AAC");
		pThis->pMediaSource->m_mediaCodecInfo.nChannels = channel_count;
		pThis->pMediaSource->m_mediaCodecInfo.nSampleRate = sample_rate;
	}
	
	//更新视频源的帧速度
	if ( pThis->pMediaSource != NULL)
	{
		if (pThis->pMediaSource->bUpdateVideoSpeed == false)
		{
		   int nVideoSpeed = pThis->CalcFlvVideoFrameSpeed(pts, 1000);
		   if (nVideoSpeed > 0)
		   {
			 pThis->pMediaSource->UpdateVideoFrameSpeed(nVideoSpeed);
			 WriteLog(Log_Debug, "nClient = %llu , 更新视频源 %s 的帧速度成功，初始速度为%d ,更新后的速度为%d, ", pThis->nClient, pThis->pMediaSource->m_szURL, pThis->pMediaSource->m_mediaCodecInfo.nVideoFrameRate, nVideoSpeed);
		   }
		}
	}
4、录像文件点播支持 http-mp4 播放
	boost::shared_ptr<CMediaStreamSource> pushClient;
	strcpy(szMediaSourceURL, szMP4Name);
	if (strstr(szMP4Name, RecordFileReplaySplitter) == NULL)
	{
		 pushClient = GetMediaStreamSource(szMP4Name);
		if (pushClient == NULL)
		{
			WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X, 没有推流对象的地址 %s nClient = %llu ", this, szMP4Name, nClient);

			sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: keep-alive\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

			DeleteNetRevcBaseClient(nClient);
			return -1;
		}
	}
	else
	{//录像点播
	   //查询点播的录像是否存在
		if (QueryRecordFileIsExiting(szMediaSourceURL) == false)
		{
			WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X, 没有录像文件 %s nClient = %llu ", this, szMP4Name, nClient);

			sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: keep-alive\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

			DeleteNetRevcBaseClient(nClient);
			return -1;
		}

		//创建录像文件点播
		pushClient = CreateReplayClient(szMediaSourceURL, &nReplayClient);
		if (pushClient == NULL)
		{
			WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X, 创建录像点播失败 %s nClient = %llu ", this, szMP4Name, nClient);

			sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: keep-alive\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

			DeleteNetRevcBaseClient(nClient);
			return -1;
		}
	}
 
5 、优化flv ,rtmp ,mp4 ,计算flv的视频帧速度，因为录像的视频，pts 不是恒定的，所以根据pts计算1此得到的帧速度是不准确的，
    需要累计多个帧速度进行平均 。
	int   CNetRevcBase::CalcFlvVideoFrameSpeed(int nVideoPTS, int nMaxValue)
	{
		int nVideoFrameSpeed = 25;
		if (oldVideoTimestamp == 0)
		{
			oldVideoTimestamp = nVideoPTS;
		}
		else
		{
			if (nVideoPTS != oldVideoTimestamp && nVideoPTS > oldVideoTimestamp)
			{
				nVideoFrameSpeed = nMaxValue / (nVideoPTS  - oldVideoTimestamp);
				if (nVideoFrameSpeed > 30)
					nVideoFrameSpeed = 30;

				oldVideoTimestamp = nVideoPTS;
				nVideoFrameSpeedOrder ++;
				//WriteLog(Log_Debug, "this = %X ,nVideoFrameSpeed = %llu ", this, nVideoFrameSpeed );
				if (nVideoFrameSpeedOrder < 10)
					return -1;
				else
				{
					if (nCalcVideoFrameCount >= CalcMaxVideoFrameSpeed)
						return m_nVideoFrameSpeed;

					nVideoFrameSpeedArray[nCalcVideoFrameCount] = nVideoFrameSpeed;//视频帧速度数组
					nCalcVideoFrameCount ++ ; //计算次数

					if (nCalcVideoFrameCount >= CalcMaxVideoFrameSpeed)
					{
						double dCount = 0;
						double dArrayCount = CalcMaxVideoFrameSpeed;
						for (int i = 0; i < CalcMaxVideoFrameSpeed; i++)
							dCount += nVideoFrameSpeedArray[i];

						double dDec = dCount / dArrayCount ;
						m_nVideoFrameSpeed = dCount / dArrayCount;
						double dJian = dDec - m_nVideoFrameSpeed;
						
						if (dJian > 0.5)
							m_nVideoFrameSpeed += 1;

						return m_nVideoFrameSpeed;
					}
					else
						return -1;
				}
			}
			return -1;
		}
		return -1;
	}

6  、增加录像下载功能
	if (httpMp4Type == HttpMp4Type_Download && bCheckHttpMP4Flag == true && fFileMp4 != NULL)
	{//录像下载
		if ( (GetTickCount64() - nCreateDateTime) >= (100 / nHttpDownloadSpeed) )
		{
			nCreateDateTime = GetTickCount64();

			nReadLength = fread(pFmp4SPSPPSBuffer, 1, Send_DownloadFile_MaxPacketCount, fFileMp4);
			if (nReadLength > 0)
			{
				nWriteRet = XHNetSDK_Write(nClient, pFmp4SPSPPSBuffer, nReadLength, 1);
				if (nWriteRet != 0)
				{
					WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X, 下载录像时，文件发送失败 %s nClient = %llu ", this, szMP4Name, nClient);
					DeleteNetRevcBaseClient(nClient);
					return -1;
				}
			}
			else
			{
				WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X, 录像文件下载完毕 %s nClient = %llu ", this, szMP4Name, nClient);
				DeleteNetRevcBaseClient(nClient);
				return -1;
			}
		}
		else
		{
			if (nHttpDownloadSpeed != 10)
			{
			   Sleep(1);
			}
		}
	   RecordReplayThreadPool->InsertIntoTask(nClient); //投递任务
	}

	
ABLMediaServer-2022-01-21 【增加录像保存、查询录像、录像下载功能】	
1、代理拉流，国标收流、http、rtmp推流 都禁止出现 __ReplayFMP4RecordFile__ 
 	//检测app stream 里面是否有 RecordFileReplaySplitter 
	if (strstr(m_addStreamProxyStruct.app, RecordFileReplaySplitter) != NULL || strstr(m_addStreamProxyStruct.stream, RecordFileReplaySplitter) != NULL)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"app , stream parameter error,Forbidden %s \",\"key\":%d}", IndexApiCode_ParamError, RecordFileReplaySplitter, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}

	//http 推流 也禁止 出现  __ReplayFMP4RecordFile__
	boost::shared_ptr<CMediaStreamSource> pMediaSourceTemp = GetMediaStreamSource(szMediaSourceURL);
	if (pMediaSourceTemp != NULL || strstr(szMediaSourceURL, RecordFileReplaySplitter) != NULL )
	{
		sprintf(szResponseBuffer, "http/1.0 406 Not Acceptable\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
		nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		WriteLog(Log_Debug, "ANNOUNCE 推流地址已经存在 %s ", szMediaSourceURL);

		DeleteNetRevcBaseClient(nClient);
		return;
	}	
	
	//rtmp 推流 限制app ,stream 禁止出现 RecordFileReplaySplitter 
	if (strstr(app, RecordFileReplaySplitter) != NULL || strstr(stream, RecordFileReplaySplitter) != NULL)
	{
		WriteLog(Log_Debug, " app ,stream 禁止出现 __ReplayFMP4RecordFile__ 字符串 ");
		DeleteNetRevcBaseClient(pClient->nClient);
		return 0;
	}

2 、增加查询录像文件是否存在 
	bool  CRecordFileSource::queryRecordFile(char* szRecordFileName)
	{
		std::lock_guard<std::mutex> lock(RecordFileLock);

		bool bRet = false;
		if (strlen(szRecordFileName) < 14)
			return false;

		//去掉扩展名 .flv , .mp4 , .m3u8 
		if (strstr(szRecordFileName, ".flv") != NULL || strstr(szRecordFileName, ".mp4") != NULL)
			szRecordFileName[strlen(szRecordFileName) - 4] = 0x00;
		if (strstr(szRecordFileName, ".m3u8") != NULL )
			szRecordFileName[strlen(szRecordFileName) - 5] = 0x00;

		list<uint64_t>::iterator it2;
		for (it2 = fileList.begin(); it2 != fileList.end(); it2++)
		{
			if (*it2 == atoll(szRecordFileName))
			{
				bRet = true;
				break;
			}
		}
		return bRet;
	}
	
3、根据录像点播的url查询录像文件是否存在 
	bool   CNetRevcBase::QueryRecordFileIsExiting(char* szReplayRecordFileURL)
	{
		memset(szSplliterShareURL, 0x00, sizeof(szSplliterShareURL));//录像点播时切割的url 
		memset(szReplayRecordFile, 0x00, sizeof(szReplayRecordFile));//录像点播切割的录像文件名字 
		memset(szSplliterApp, 0x00, sizeof(szSplliterApp));
		memset(szSplliterStream, 0x00, sizeof(szSplliterStream));
		string strRequestMediaSourceURL = szReplayRecordFileURL;
		int   nPos = strRequestMediaSourceURL.find(RecordFileReplaySplitter, 0);
		if (nPos <= 0)
			return false ;

		memcpy(szSplliterShareURL, szMediaSourceURL, nPos);
		memcpy(szReplayRecordFile, szMediaSourceURL + (nPos + strlen(RecordFileReplaySplitter)), strlen(szMediaSourceURL) - nPos - strlen(RecordFileReplaySplitter));

		if (QureyRecordFileFromRecordSource(szSplliterShareURL, szReplayRecordFile) == false)
			return false ;

		int   nPos2 = strRequestMediaSourceURL.find("/", 2);
		if (nPos2 > 0)
		{
			memcpy(szSplliterApp, szReplayRecordFileURL + 1, nPos2 -1 );
			memcpy(szSplliterStream, szReplayRecordFileURL + nPos2 + 1, nPos - nPos2 -1 );
		}

		return true;
	}

4、根据录像文件创建点播的录像媒体源
	boost::shared_ptr<CMediaStreamSource>   CNetRevcBase::CreateReplayClient(char* szReplayURL,uint64_t* nReturnReplayClient)
	{
	#ifdef OS_System_Windows
		sprintf(szRequestReplayRecordFile, "%s%s\\%s\\%s.mp4", ABL_MediaServerPort.recordPath, szSplliterApp, szSplliterStream, szReplayRecordFile);
	#else
		sprintf(szRequestReplayRecordFile, "%s%s/%s/%s.mp4", ABL_MediaServerPort.recordPath, szSplliterApp, szSplliterStream, szReplayRecordFile);
	#endif

		boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(szReplayURL);
		if (pMediaSource == NULL)
		{
			boost::shared_ptr<CNetRevcBase> replayClient = CreateNetRevcBaseClient(ReadRecordFileInput_ReadFMP4File, 0, 0, szRequestReplayRecordFile, 0, szSplliterShareURL);
			if (replayClient)//记录录像点播的client 
			 *nReturnReplayClient = replayClient->nClient;

			pMediaSource = GetMediaStreamSource(szReplayURL);
			if (pMediaSource == NULL)
			{
				if (replayClient)
					pDisconnectBaseNetFifo.push((unsigned char*)&replayClient->nClient, sizeof(replayClient->nClient));
				return NULL;
			}
			int nWaitCount = 0;
			while (!pMediaSource->bUpdateVideoSpeed)
			{
				nWaitCount++;
				Sleep(200);
				if (nWaitCount >= 10)
					break;
			}
		}
		
		return  pMediaSource;
	}

5、在http 、rtmp 、flv 、ws_flv 录像文件点播时，先判断是否是实况播放，录像点播 ，如果是录像点播 先判断文件是否存在，如果不存在直接断开，如果存在则创建文件点播

	//判断源流媒体是否存在
	if (strstr(szMediaSourceURL, RecordFileReplaySplitter) == NULL)
	{//观看实况
		pMediaSource = GetMediaStreamSource(szMediaSourceURL);
		if (pMediaSource == NULL || strlen(pMediaSource->m_mediaCodecInfo.szVideoName) == 0)
		{
			sprintf(szResponseBuffer, "http/1.0 404 Not FOUND\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
			nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
			WriteLog(Log_Debug, "媒体流 %s 不存在 ,准备删除 nClient =%llu ", szMediaSourceURL, nClient);

			DeleteNetRevcBaseClient(nClient);
			return;
		}
	}
	else
	{//录像点播
	 
		//查询点播的录像是否存在
		if (QueryRecordFileIsExiting(szMediaSourceURL) == false)
		{
			sprintf(szResponseBuffer, "http/1.0 404 Not FOUND\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
			nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
			WriteLog(Log_Debug, "录像文件 %s 不存在 ,准备删除 nClient = %llu ", szMediaSourceURL, nClient);
			DeleteNetRevcBaseClient(nClient);
			return;
		}

		//创建录像文件点播
		pMediaSource = CreateReplayClient(szMediaSourceURL,&nReplayClient);
		if (pMediaSource == NULL)
		{
			sprintf(szResponseBuffer, "http/1.0 404 Not FOUND\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
			nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
			WriteLog(Log_Debug, "http服务器创建录像文件点播失败 %s  nClient = %llu ", szMediaSourceURL, nClient);
			DeleteNetRevcBaseClient(nClient);
			return;
		}
	}
	
6、录像文件点播 ，删除掉hls 方式点播，因为hls 从创建到正式生效需要12秒 	
	if (*it2 >= atoll(queryStruct.starttime) && *it2 <= atoll(queryStruct.endtime))
	{
		memset(szTemp2, 0x00, sizeof(szTemp2));

		sprintf(szTemp2, "{\"file\":\"%llu.mp4\",\"url\":{\"http\":\"http://%s:%d/%s/%s%s%llu\",\"rtmp\":\"rtmp://%s:%d/%s/%s%s%llu\",\"http-flv\":\"http://%s:%d/%s/%s%s%llu.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s%s%llu.flv\",\"http-mp4\":\"http://%s:%d/%s/%s%s%llu.mp4\",\"http-hls\":\"http://%s:%d/%s/%s%s%llu.m3u8\",\"download\":\"http://%s:%d/%s/%s%s%llu.mp4?download_speed=%d\"}},", *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2, ABL_MediaServerPort.httpDownloadSpeed);

		strcat(szMediaSourceInfo, szTemp2);
		nMediaCount++;
	}
	
7、录像文件查找时，判断录像文件名字是否都为数字
	string strFile = szRecordFileName;
	bCheckDigit = boost::all(strFile,boost::is_digit());
	if (!bCheckDigit)
		return false;
	
ABLMediaServer-2022-01-20 增加录像保存、查询录像、录像下载功能】	
1、定义录像、实况url的区分标识字符串 
    #define   RecordFileReplaySplitter          "__ReplayFMP4RecordFile__"  //实况、录像区分的标志字符串，用于区分实况，放置在url中。
	
	sprintf(szTemp2, "{\"file\":\"%llu.mp4\",\"url\":{\"http\":\"http://%s:%d/%s/%s%s%llu\",\"rtmp\":\"rtmp://%s:%d/%s/%s%s%llu\",\"http-flv\":\"http://%s:%d/%s/%s%s%llu.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s%s%llu.flv\",\"http-mp4\":\"http://%s:%d/%s/%s%s%llu.mp4\",\"http-hls\":\"http://%s:%d/%s/%s%s%llu.m3u8\",\"download\":\"http://%s:%d/%s/%s%s%llu.mp4?download_speed=%d\"}},", *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2,
		ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, RecordFileReplaySplitter, *it2, ABL_MediaServerPort.httpDownloadSpeed);

2、在录像文件输入流时 ，根据录像文件 ，app,stream 组装好 录像回放的url 
	 
	bool  CReadRecordFileInput::GetMediaShareURLFromFileName(char* szRecordFileName,char* szMediaURL)
	{
		if (szRecordFileName == NULL || strlen(szRecordFileName) == 0 || szMediaURL == NULL || strlen(szMediaURL) == 0)
			return false;

		string strRecordFileName = szRecordFileName;
	#ifdef OS_System_Windows
		replace_all(strRecordFileName, "\\", "/"); 
	#endif
		int   nPos;
		char  szTempFileName[512] = { 0 };
		nPos = strRecordFileName.rfind("/", strlen(szRecordFileName));
		if (nPos > 0)
		{
			memcpy(szTempFileName, szRecordFileName + nPos+1, strlen(szRecordFileName) - nPos);
			szTempFileName[strlen(szTempFileName) - 4] = 0x00;
			sprintf(m_szShareMediaURL, "%s%s%s", szMediaURL, RecordFileReplaySplitter, szTempFileName);
			return true;
		}else 
		  return false;
	}

3、支持录像文件点播完毕后，再次循环播放，由配置参数 fileRepeat 决定 
	if (nReadRet == 0)
	{//录像文件读取完毕 
		if (ABL_MediaServerPort.fileRepeat == 1)
		{
			int64_t nStartTime = 0;
			int nRet = mov_reader_seek(mov, &nStartTime);
		    WriteLog(Log_Debug, "ProcessNetData 文件读取完毕 ,nClient = %llu ,现在重新再次播放 ,nRet = %d ", nClient, nRet);

			RecordReplayThreadPool->InsertIntoTask(nClient);
		}
		else
		{
		   WriteLog(Log_Debug, "ProcessNetData 文件读取完毕 ,nClient = %llu ", nClient);
 		   DeleteNetRevcBaseClient(nClient);
		}
	}

4、文件读取修改未线程池方式读取，不再需要 Sleep(40) 的方式 
	int CReadRecordFileInput::ProcessNetData() 
	{
		std::lock_guard<std::mutex> lock(readRecordFileInputLock);
		if (mov == NULL)
			return -1;

		nRecvDataTimerBySecond = 0;

		if (nAVType == AVType_Video)
		{//读取视频
			if (GetTickCount64() - mov_readerTime >= 40)
			{
			  mov_readerTime = GetTickCount64();
			  nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);
			}
			else//读取视频的时间尚未到，需要Sleep(5) ,否则CPU会狂跑
				Sleep(5);
		}
		else if (nAVType == AVType_Audio)  
		{//音频直接读取
			nReadRet = mov_reader_read(mov, s_buffer, sizeof(s_buffer), ReadRecordFileInput_onread, this);
		}

		if (nReadRet == 0)
		{//录像文件读取完毕 
			if (ABL_MediaServerPort.fileRepeat == 1)
			{
				int64_t nStartTime = 0;
				int nRet = mov_reader_seek(mov, &nStartTime);
				WriteLog(Log_Debug, "ProcessNetData 文件读取完毕 ,nClient = %llu ,现在重新再次播放 ,nRet = %d ", nClient, nRet);
			}
			else
			{
			   WriteLog(Log_Debug, "ProcessNetData 文件读取完毕 ,nClient = %llu ", nClient);
			   DeleteNetRevcBaseClient(nClient);
			   return -1;
			}
		}
		else if (nReadRet < 0)
		{//文件读取出错 
			WriteLog(Log_Debug, "ProcessNetData 文件读取出错 ,nClient = %llu ",  nClient);
			DeleteNetRevcBaseClient(nClient);
			return -1;
		}
	 
		RecordReplayThreadPool->InsertIntoTask(nClient);

		return 0 ;	
	}

5、时刻计算读取录像文件的视频帧速度，用于线程池读取录像文件的等待时间 nVidepSpeedTime
	//时刻计算视频帧速度
	pThis->nVidepSpeedTime = pts - pThis->nOldPTS;
	pThis->nOldPTS = pts;
	if (pThis->nVidepSpeedTime <= 0)
		pThis->nVidepSpeedTime = 40;
	else if (pThis->nVidepSpeedTime > 1000)
		pThis->nVidepSpeedTime = 40 ;
		
ABLMediaServer-2022-01-19 【增加录像保存、查询录像、录像下载功能】	
1、在媒体源 销毁时，检测提供源是不是代理，如果是代理则需要检测重连次数，重连次数大于设置值才销毁代理对象 
   【 在  ABLMediaServer-2022-01-18 版本中修改引发出的一个BUG（3、修正 代理拉流 http ,rtmp ,flv ,在创建媒体源时，是传入代理类的hParent ）】 
	boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClientNoLock(nClient);
	if (pClient)
	{
		if (pClient->netBaseNetType == NetBaseNetType_addStreamProxyControl || pClient->netBaseNetType == NetBaseNetType_addPushProxyControl)
 		{//代理拉流，代理推流 ,需要检测重连次数超过 配置文件的此次，才断开代理拉流对象 
			if(pClient->nReConnectingCount > ABL_MediaServerPort.nReConnectingCount)
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
 		}else
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
	}else
 	   pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));

2、定义一个删除文件函数 ABLDeleteFile()
	bool   ABLDeleteFile(char* szFileName)
	{
		return ::DeleteFile(szFileName);
	}
	bool  ABLDeleteFile(char* szFileName)
	{
		int nRet = unlink(szFileName);
		return (nRet == 0) ? true : false;
	}
	
3、录像文件删除失败，回收以后再次删除 ，有可能删除录像文件时刻，正在回放该文件，所以需要回收再次删除 
	if (ABLDeleteFile(szDeleteFile) == false)
	{
		fileList.push_back(nGetFile); 
		WriteLog(Log_Debug, "DeleteExpireRecordFile %s 删除文件 %llu.mp4 失败，回收以后再删除 ", m_szShareURL, nGetFile);
	}
	else
	  WriteLog(Log_Debug, "DeleteExpireRecordFile %s 删除文件  %s ",m_szShareURL,szDeleteFile);

4、修正、统一录像查询返回的各种协议播放的url 	  
	if (iterator1 != xh_ABLRecordFileSourceMap.end())
	{
		pRecord = (*iterator1).second;
		
		for(it2 = pRecord->fileList.begin() ;it2 != pRecord->fileList.end() ;it2 ++)
		{
			if (*it2 >= atoll(queryStruct.starttime) && *it2 <= atoll(queryStruct.endtime))
			{
				memset(szTemp2, 0x00, sizeof(szTemp2));

				sprintf(szTemp2, "{\"file\":\"%llu.mp4\",\"url\":{\"http\":\"http://%s:%d/%s/%s_%llu\",\"rtmp\":\"rtmp://%s:%d/%s/%s_%llu\",\"http-flv\":\"http://%s:%d/%s/%s_%llu.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s_%llu.flv\",\"http-mp4\":\"http://%s:%d/%s/%s_%llu.mp4\",\"http-hls\":\"http://%s:%d/%s/%s_%llu.m3u8\",\"download\":\"http://%s:%d/%s/%s_%llu.mp4?download_speed=%d\"}},", *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, queryStruct.app, queryStruct.stream, *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, queryStruct.app, queryStruct.stream, *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, queryStruct.app, queryStruct.stream, *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, queryStruct.app, queryStruct.stream, *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, queryStruct.app, queryStruct.stream, *it2,
					ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, *it2, ABL_MediaServerPort.httpDownloadSpeed);

				strcat(szMediaSourceInfo, szTemp2);
				nMediaCount++;
			}
		}
		
	    录像文件返回的url ，采用如下的命名方式 
		{
			"code": 0,
			"app": "Media",
			"stream": "Camera_00001",
			"starttime": "20220119173038",
			"endtime": "20220119173438",
			"recordFileList": [
				{
					"file": "20220119173438.mp4",
					"url": {
						"http": "http://44.35.33.239:554/Media/Camera_00001_20220119173438",
						"rtmp": "rtmp://44.35.33.239:1935/Media/Camera_00001_20220119173438",
						"http-flv": "http://44.35.33.239:8088/Media/Camera_00001_20220119173438.flv",
						"ws-flv": "ws://44.35.33.239:6088/Media/Camera_00001_20220119173438.flv",
						"http-mp4": "http://44.35.33.239:5088/Media/Camera_00001_20220119173438.mp4",
						"http-hls": "http://44.35.33.239:9088/Media/Camera_00001_20220119173438.m3u8",
						"download": "http://44.35.33.239:5088/Media/Camera_00001_20220119173438.mp4?download_speed=6"
					}
				}
			]
		}	   
ABLMediaServer-2022-01-18 增加录像保存、查询录像、录像下载功能】	
1、增加录像查收时间的长度、结束时间必须大于开始时间、检测时间必须小于 当前时间 减去 切片时间 
	if (strlen(m_queryRecordListStruct.starttime) != 14 || strlen(m_queryRecordListStruct.endtime) != 14)
	{//开始时间、结束时间的长短检测 
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[starttime , endtime ] Length Error ,length must 14 \"}", IndexApiCode_secretError);
		ResponseSuccess(szResponseBody);
		return false;
	}

	if ( atoll(m_queryRecordListStruct.endtime) < atoll(m_queryRecordListStruct.starttime))
	{//结束时间必须大于开始时间
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"endtime must greater than starttime \"}", IndexApiCode_secretError);
		ResponseSuccess(szResponseBody);
		return false;
	}

	//检测结束时间必须小于当前时间的
	if (GetCurrentSecondByTime(m_queryRecordListStruct.endtime) > (GetCurrentSecond() - ABL_MediaServerPort.fileSecond))
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"endtime must current time %llu second before \"}", IndexApiCode_secretError, ABL_MediaServerPort.fileSecond);
		ResponseSuccess(szResponseBody);
		return false;
	}

2、采用 sscanf 来获取 年月日时分秒 	
	uint64_t GetCurrentSecondByTime(char* szDateTime)
	{
		if (szDateTime == NULL || strlen(szDateTime) < 14)
			return 0;

		time_t clock;
		struct tm tm ;
	 
		sscanf(szDateTime, "%04d%02d%02d%02d%02d%02d", &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec);
		tm.tm_year = tm.tm_year - 1900;
		tm.tm_mon = tm.tm_mon - 1;
		tm.tm_isdst = -1;
		clock = mktime(&tm);
		return clock;
	}
	
3、修正 代理拉流 http ,rtmp ,flv ,在创建媒体源时，是传入代理类的hParent 
	if (strlen(m_szShareMediaURL) > 0)
	{
		pMediaSource = CreateMediaStreamSource(m_szShareMediaURL, hParent);
		if (pMediaSource)
			pMediaSource->enable_mp4 = (strcmp(m_addStreamProxyStruct.enable_mp4, "1") == 0) ? true : false;
	}

4、HLS 需要更新最后观看是否，否则会因为无人观看，断开接入流 	
	int CNetServerHLS::ProcessNetData()
	{
 	    //更新最后观看时间
	    pushClient->nLastWatchTime = GetCurrentSecond();
	
5、获取系统配置，增加了几个参数 
	bool CNetServerHTTP::index_api_getServerConfig()
	{
		memset((char*)&m_getServerConfigStruct, 0x00, sizeof(m_getServerConfigStruct));

		GetKeyValue("secret", m_getServerConfigStruct.secret);
	 
		if (strcmp(m_getServerConfigStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, MaxMediaSourceInfoLength);
		sprintf(szMediaSourceInfoBuffer, "{\"code\":0,\"params\":[{\"enable_audio\":%d,\"memo\":\"enable_audio = 1 open Audio , enable_audio = 0 Close Audio \"},{\"httpServerPort\":%d,\"memo\":\"http api port \"},{\"httpPort\":%d,\"memo\":\"http port \"},{\"rtmpPort\":%d,\"memo\":\"rtmp port \"},{\"httpFlvPort\":%d,\"memo\":\"http-flv port \"},{\"hls_enable\":%d,\"memo\":\"hls whether enable \"},{\"hlsPort\":%d,\"memo\":\"hls port\"},{\"wsPort\":%d,\"memo\":\"websocket flv port\"},{\"mp4Port\":%d,\"memo\":\"http mp4 port\"},{\"hlsCutType\":%d,\"memo\":\"hlsCutType = 1 hls cut to Harddisk,hlsCutType = 2  hls cut Media to memory\"},{\"h265CutType\":%d,\"memo\":\" 1 h265 cut TS , 2 cut fmp4 \"},{\"RecvThreadCount\":%d,\"memo\":\" RecvThreadCount \"},{\"SendThreadCount\":%d,\"memo\":\"SendThreadCount\"},{\"GB28181RtpTCPHeadType\":%d,\"memo\":\"rtp Length Type\"},{\"rtpPacketOfhttp\":%d,\"memo\":\"http 1  rtp paylaod ES,2 rtp payload PS\"},{\"ReConnectingCount\":%d,\"memo\":\"Try reconnections times .\"},{\"maxTimeNoOneWatch\":%d,\"memo\":\"maxTimeNoOneWatch .\"},{\"pushEnable_mp4\":%d,\"memo\":\"pushEnable_mp4 .\"},{\"fileSecond\":%d,\"memo\":\"fileSecond .\"},{\"fileKeepMaxTime\":%d,\"memo\":\"fileKeepMaxTime .\"},{\"httpDownloadSpeed\":%d,\"memo\":\"httpDownloadSpeed .\"}]}", 
			ABL_MediaServerPort.nEnableAudio,ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nhttpPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nWSFlvPort, ABL_MediaServerPort.nHttpMp4Port, ABL_MediaServerPort.nHLSCutType, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nGBRtpTCPHeadType, ABL_MediaServerPort.nRtpPacketOfhttp, ABL_MediaServerPort.nReConnectingCount,
			ABL_MediaServerPort.maxTimeNoOneWatch, ABL_MediaServerPort.pushEnable_mp4,ABL_MediaServerPort.fileSecond,ABL_MediaServerPort.fileKeepMaxTime,ABL_MediaServerPort.httpDownloadSpeed);
		ResponseSuccess(szMediaSourceInfoBuffer);

		return true;
	}
	
6、增加读取录像文件类库 ReadRecordFileInput.cpp 、 ReadRecordFileInput.h
	
ABLMediaServer-2022-01-17【增加录像保存、查询录像、录像下载功能】	
1、开启录像前，要先创建录像文件源，否则录像文件名字加入不了 
	if (CreateRecordFileSource(app, stream))
	{
		WriteLog(Log_Debug, " 创建文件源成功 app = %s ,stream = %s  ", app, stream );
	}

2、创建文件源时，先判断是否存在，如果存储则不用再创建 	
	CRecordFileSource_ptr CreateRecordFileSource(char* app,char* stream)
	{
		char szShareURL[512] = { 0 };
		sprintf(szShareURL, "/%s/%s", app, stream);
		CRecordFileSource_ptr pReordFile = GetRecordFileSource(szShareURL);
		if (pReordFile != NULL)
		{
			WriteLog(Log_Debug, "CreateRecordFileSource 失败 , app = %s ,stream = %s 已经存在 ", app, stream);
			return false;
		}

		std::lock_guard<std::mutex> lock(ABL_CRecordFileSourceMapLock);

		CRecordFileSource_ptr pRecord = NULL;
		 
		try
		{
			do
			{
				pRecord = boost::make_shared<CRecordFileSource>(app,stream);
			} while (pRecord == NULL);
		}
		catch (const std::exception &e)
		{
			return NULL;
		}

		std::pair<boost::unordered_map<string, CRecordFileSource_ptr>::iterator, bool> ret =
			xh_ABLRecordFileSourceMap.insert(std::make_pair(pRecord->m_szShareURL, pRecord));
		if (!ret.second)
		{
			pRecord.reset();
			return NULL;
		}

		return pRecord;

3、在linux下，创建文件夹前，先调用 umask(0) ,否则可能会创建文件夹失败
	int showAllFiles( const char * dir_name,bool& bExitingFlag,int& fileSize)
	{
		umask(0);
		mkdir("./log",777);
		umask(0);
		mkdir(LogFilePath,777);

		
ABLMediaServer-2022-01-16【增加录像保存、查询录像、录像下载功能】	
1、 查询录像
	int queryRecordListByTime(char* szMediaSourceInfo, queryRecordListStruct queryStruct)
	{
		std::lock_guard<std::mutex> lock(ABL_CRecordFileSourceMapLock);

		CRecordFileSource_ptrMap::iterator iterator1;
		CRecordFileSource_ptr   pRecord = NULL;
		list<uint64_t>::iterator it2;

		int   nMediaCount = 0;
		char  szTemp2[1024 * 32] = { 0 };
		char  szShareMediaURL[256] = { 0 };
		bool  bAddFlag = false;

		if (xh_ABLRecordFileSourceMap.size() > 0)
		{
			sprintf(szMediaSourceInfo, "{\"code\":0,\"app\":\"%s\",\"stream\":\"%s\",\"starttime\":\"%s\",\"endtime\":\"%s\",\"recordFileList\":[",queryStruct.app,queryStruct.stream,queryStruct.starttime,queryStruct.endtime);
		}

		sprintf(szShareMediaURL, "/%s/%s", queryStruct.app, queryStruct.stream);
		iterator1 = xh_ABLRecordFileSourceMap.find(szShareMediaURL);
		if (iterator1 != xh_ABLRecordFileSourceMap.end())
		{
			pRecord = (*iterator1).second;
			
			for(it2 = pRecord->fileList.begin() ;it2 != pRecord->fileList.end() ;it2 ++)
			{
				if (*it2 >= atoll(queryStruct.starttime) && *it2 <= atoll(queryStruct.endtime))
				{
					memset(szTemp2, 0x00, sizeof(szTemp2));

					sprintf(szTemp2, "{\"file\":\"%llu.mp4\",\"url\":{\"http\":\"http://%s:%d/%s/%s/%llu.mp4\",\"rtmp\":\"rtmp://%s:%d/%s/%s_%llu\",\"http-flv\":\"http://%s:%d/%s/%s_%llu.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s_%llu.flv\",\"http-mp4\":\"http://%s:%d/%s/%s/%llu.mp4\",\"http-hls\":\"http://%s:%d/%s/%s/%llu.m3u8\",\"download\":\"http://%s:%d/%s/%s/%llu.mp4?download_speed=%d\"}},", *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, queryStruct.app, queryStruct.stream, *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, queryStruct.app, queryStruct.stream, *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, queryStruct.app, queryStruct.stream, *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, queryStruct.app, queryStruct.stream, *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, queryStruct.app, queryStruct.stream, *it2,
						ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, queryStruct.app, queryStruct.stream, *it2, ABL_MediaServerPort.httpDownloadSpeed);

					strcat(szMediaSourceInfo, szTemp2);
					nMediaCount++;
				}
			}
		}
		else
		{
			return NULL;
		}
		 
		if (nMediaCount > 0)
		{
			szMediaSourceInfo[strlen(szMediaSourceInfo) - 1] = 0x00;
			strcat(szMediaSourceInfo, "]}");
		}

		if (nMediaCount == 0)
		{
			sprintf(szMediaSourceInfo, "{\"code\":%d,\"count\":0,\"memo\":\"RecordList [app: %s , stream: %s] Not Found .\"}", IndexApiCode_OK, queryStruct.app, queryStruct.stream);
		}

		return nMediaCount;
	}


ABLMediaServer-2022-01-15【增加录像保存、查询录像、录像下载功能】	
1、解决 close_sreams 接口函数的BUG，当删除代理输入的码流时，只是删除了拉流对象，代理对象没有删除，会造成代理对象
   反复去拉流 
	 
	int  CloseMediaStreamSource(closeStreamsStruct closeStruct)
	{
		std::lock_guard<std::mutex> lock(ABL_CMediaStreamSourceMapLock);
		CMediaStreamSource_ptrMap::iterator iterator1;
		CMediaStreamSource_ptr   pClient = NULL;
		int  nDeleteCount =  0 ;

		for (iterator1 = xh_ABLMediaStreamSourceMap.begin(); iterator1 != xh_ABLMediaStreamSourceMap.end(); ++iterator1)
		{
			pClient = (*iterator1).second;
	 
			//代理拉流对象也要删除
			CNetRevcBase_ptr pParend = GetNetRevcBaseClientNoLock(pClient->nClient);

			if (closeStruct.force == 1 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) > 0)
			{//强制关闭
				if (strcmp(pClient->app, closeStruct.app) == 0 && strcmp(pClient->stream, closeStruct.stream) == 0)
				{
					nDeleteCount ++;
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
					if (pParend)
					{
					   pDisconnectBaseNetFifo.push((unsigned char*)&pParend->hParent, sizeof(pParend->hParent));
					   WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ,nClient = %llu,nParent = %llu ", pClient->m_szURL, pClient->app, pClient->stream, pParend->nClient, pParend->hParent);
					}
				}
			}
			else if (closeStruct.force == 1 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) == 0)
			{//强制关闭
				if (strcmp(pClient->app, closeStruct.app) == 0 )
				{
					nDeleteCount++;
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
					if (pParend)
					{
						pDisconnectBaseNetFifo.push((unsigned char*)&pParend->hParent, sizeof(pParend->hParent));
						WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ,nClient = %llu,nParent = %llu ", pClient->m_szURL, pClient->app, pClient->stream, pParend->nClient, pParend->hParent);
					}
				}
			}
			else if (closeStruct.force == 1 && strlen(closeStruct.app) == 0 && strlen(closeStruct.stream) == 0)
			{//强制关闭
					nDeleteCount++;
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
					if (pParend)
					{
						pDisconnectBaseNetFifo.push((unsigned char*)&pParend->hParent, sizeof(pParend->hParent));
						WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ,nClient = %llu,nParent = %llu ", pClient->m_szURL, pClient->app, pClient->stream, pParend->nClient, pParend->hParent);
					}
			}
			else if (closeStruct.force == 0 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) > 0)
			{//不强制关闭
				if (pClient->mediaSendMap.size() == 0 && strcmp(pClient->app, closeStruct.app) == 0 && strcmp(pClient->stream, closeStruct.stream) == 0)
				{
					nDeleteCount ++;
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
					if (pParend)
					{
						pDisconnectBaseNetFifo.push((unsigned char*)&pParend->hParent, sizeof(pParend->hParent));
						WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ,nClient = %llu,nParent = %llu ", pClient->m_szURL, pClient->app, pClient->stream, pParend->nClient, pParend->hParent);
					}
				}
			}
			else if (closeStruct.force == 0 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) == 0)
			{//不强制关闭
				if (pClient->mediaSendMap.size() == 0 && strcmp(pClient->app, closeStruct.app) == 0)
				{
					nDeleteCount++;
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
					if (pParend)
					{
						pDisconnectBaseNetFifo.push((unsigned char*)&pParend->hParent, sizeof(pParend->hParent));
						WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ,nClient = %llu,nParent = %llu ", pClient->m_szURL, pClient->app, pClient->stream, pParend->nClient, pParend->hParent);
					}
				}
			}
		}
		return nDeleteCount ;
	}

2、为了计算帧速度更加精确，等待帧数量修改为15帧
	//计算视频帧速度
	int  CNetRevcBase::CalcVideoFrameSpeed(unsigned char* pRtpData, int nLength)
	{
		if (pRtpData == NULL)
			return -1 ;
		
		int nVideoFrameSpeed = 25 ;
		memcpy((char*)&rtp_header, pRtpData, sizeof(rtp_header));
		if (oldVideoTimestamp == 0)
		{
			oldVideoTimestamp = ntohl(rtp_header.timestamp);
		}
		else
		{
			if (ntohl(rtp_header.timestamp) != oldVideoTimestamp && ntohl(rtp_header.timestamp) > oldVideoTimestamp )
			{
				//WriteLog(Log_Debug, "this = %X ,nVideoFrameSpeed = %llu ", this,(90000 / (ntohl(rtp_header.timestamp) - oldVideoTimestamp)) );

				nVideoFrameSpeed = 90000 / (ntohl(rtp_header.timestamp) - oldVideoTimestamp) ;
				if (nVideoFrameSpeed > 30)
					nVideoFrameSpeed = 30;

				//妈的，有些时间戳乱搞打包，强制赋值为25帧每秒 
				if (nVideoFrameSpeed <= 5)
					nVideoFrameSpeed = 25;

				oldVideoTimestamp = ntohl(rtp_header.timestamp);
				nVideoFrameSpeedOrder ++;
				if (nVideoFrameSpeedOrder < 15)
					return -1;
				else
				   return nVideoFrameSpeed;
			}
			return -1;
		}
		return -1;
	}

3、如果查询输入列表不存在，返回正确，数量为0 
	if (nMediaCount == 0)
	{
		sprintf(szMediaSourceInfo, "{\"code\":%d,\"count\":0,\"memo\":\"MediaSource [app: %s , stream: %s] Not Found .\"}", IndexApiCode_OK, mediaListStruct.app, mediaListStruct.stream);
	}
	
4、增加录像文件到list 	
	bool CRecordFileSource::AddRecordFile(char* szFileName)
	{
		std::lock_guard<std::mutex> lock(RecordFileLock);

		memset(szBuffer, 0x00, sizeof(szBuffer));
		memcpy(szBuffer, szFileName, strlen(szFileName) - 4);
		uint64_t nSecond = GetCurrentSecond() - GetCurrentSecondByTime(szBuffer);

		if (nSecond > (ABL_MediaServerPort.fileKeepMaxTime * 3600))
		{
	#ifdef OS_System_Windows
		  sprintf(szDeleteFile, "%s%s\\%s\\%s.mp4", ABL_MediaServerPort.recordPath, m_app, m_stream, szBuffer);
	#else
		  sprintf(szDeleteFile, "%s%s/%s/%s.mp4", ABL_MediaServerPort.recordPath, m_app, m_stream, szDateTime);
	#endif
		  DeleteFile(szDeleteFile);
		  WriteLog(Log_Debug, "DeleteExpireRecordFile 删除文件  %s ", szDeleteFile);
		}else
			fileList.push_back(atoll(szBuffer));
	 
		return true;
	}

5、排序
	void CRecordFileSource::Sort()
	{
		std::lock_guard<std::mutex> lock(RecordFileLock);
		fileList.sort();
	}

6、删除过期录像文件
	int  CRecordFileSource::DeleteExpireRecordFile()
	{
		std::lock_guard<std::mutex> lock(RecordFileLock);
		uint64_t nGetFile;
		uint64_t nSecond = 0; 
		char    szDateTime[128] = { 0 };
		int     nDeleteCount = 0;

		while (fileList.size() > 0 )
		{
			nGetFile = fileList.front();
			sprintf(szDateTime, "%llu", nGetFile);
			nSecond = GetCurrentSecond() - GetCurrentSecondByTime(szDateTime);
			if (nSecond > (ABL_MediaServerPort.fileKeepMaxTime * 3600))
			{
				fileList.pop_front();
	#ifdef OS_System_Windows
				sprintf(szDeleteFile, "%s%s\\%s\\%s.mp4", ABL_MediaServerPort.recordPath, m_app, m_stream, szDateTime);
	#else 
				sprintf(szDeleteFile, "%s%s/%s/%s.mp4", ABL_MediaServerPort.recordPath, m_app, m_stream, szDateTime);
	#endif
				DeleteFile(szDeleteFile);
				WriteLog(Log_Debug, "DeleteExpireRecordFile 删除文件  %s ",szDeleteFile);
				nDeleteCount ++;
			}
			else
				break;
		}
		return nDeleteCount;
	}

7、保存录像时，把录像名字加入list,任务会定期检测，如果过期了进行删除
	bool CStreamRecordFMP4::writeTSBufferToMP4File(unsigned char* pTSData, int nLength)
	{
		if (fWriteMP4 && pTSData != NULL && nLength > 0)
		{
			fwrite(pTSData, 1, nLength, fWriteMP4);
			fflush(fWriteMP4);

			if (GetTickCount() - nCreateDateTime >= 1000 * ABL_MediaServerPort.fileSecond)
			{
				fclose(fWriteMP4);
	#ifdef OS_System_Windows
				SYSTEMTIME st;
				GetLocalTime(&st);
				sprintf(szFileName, "%s%04d%02d%02d%02d%02d%02d.mp4", szRecordPath, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
				sprintf(szFileNameOrder,"%04d%02d%02d%02d%02d%02d.mp4", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);;
	#else
				time_t now;
				time(&now);
				struct tm *local;
				local = localtime(&now);
				sprintf(szFileName, "%s%04d%02d%02d%02d%02d%02d.mp4", szRecordPath, local->tm_year + 1900, local->tm_mon+1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);
				sprintf(szFileNameOrder, "%04d%02d%02d%02d%02d%02d.mp4", local->tm_year + 1900, local->tm_mon + 1, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);;
	#endif
				fWriteMP4 = fopen(szFileName, "wb");
				if (fWriteMP4 != NULL)
				{
					fwrite(s_packet, 1, s_packetLength, fWriteMP4);
					fflush(fWriteMP4);
					
					boost::shared_ptr<CRecordFileSource> pRecord = GetRecordFileSource(m_szShareMediaURL);
					if (pRecord)
					{
					   pRecord->AddRecordFile(szFileNameOrder);
					   WriteLog(Log_Debug, "CStreamRecordFMP4 = %X 增加录像文件 nClient = %llu ,nMediaClient = %llu szFileNameOrder %s ", this, nClient, nMediaClient, szFileNameOrder);
					}				
				}

				nCreateDateTime = GetTickCount();
			}

			return true;
		}
		else
			return false;
	}


ABLMediaServer-2022-01-14【增加录像保存、查询录像、录像下载功能】	
1、增加推流是否自动录像参数，并根据参数是否开启录像 

	//rtmp推流上来 如果配置推流录像，则开启录像标志 
	if(pClient->pMediaSource && ABL_MediaServerPort.pushEnable_mp4 == 1)
	   pClient->pMediaSource->enable_mp4 = true;

	   
	//http 推流上来   
	if (pMediaSource)
	{
		//如果配置推流录像，则开启录像标志
		if (ABL_MediaServerPort.pushEnable_mp4 == 1)
			pMediaSource->enable_mp4 = true; 
	}

ABLMediaServer-2022-01-13【增加录像保存、查询录像、录像下载功能】	
1、增加录像文件源存储map 
	/* 录像文件存储 -------------------------------------------------------------------------------------*/
	CRecordFileSource_ptr CreateRecordFileSource(char* app,char* stream)
	{
		std::lock_guard<std::mutex> lock(ABL_CRecordFileSourceMapLock);

		CRecordFileSource_ptr pRecord = NULL;
		 
		try
		{
			do
			{
				pRecord = boost::make_shared<CRecordFileSource>(app,stream);
			} while (pRecord == NULL);
		}
		catch (const std::exception &e)
		{
			return NULL;
		}

		std::pair<boost::unordered_map<string, CRecordFileSource_ptr>::iterator, bool> ret =
			xh_ABLRecordFileSourceMap.insert(std::make_pair(pRecord->m_szShareURL, pRecord));
		if (!ret.second)
		{
			pRecord.reset();
			return NULL;
		}

		return pRecord;
	}

	CRecordFileSource_ptr GetRecordFileSource(char* szShareURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CRecordFileSourceMapLock);

		CRecordFileSource_ptrMap::iterator iterator1;
		CRecordFileSource_ptr   pRecord = NULL;

		iterator1 = xh_ABLRecordFileSourceMap.find(szShareURL);
		if (iterator1 != xh_ABLRecordFileSourceMap.end())
		{
			pRecord = (*iterator1).second;
			return pRecord;
		}
		else
		{
			return NULL;
		}
	}

	bool  DeleteRecordFileSource(char* szURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CRecordFileSourceMapLock);

		CRecordFileSource_ptrMap::iterator iterator1;

		iterator1 = xh_ABLRecordFileSourceMap.find(szURL);
		if (iterator1 != xh_ABLRecordFileSourceMap.end())
		{
			xh_ABLRecordFileSourceMap.erase(iterator1);
			return true;
		}
		else
		{
			return false;
		}
	}

	//增加一个录像文件到录像媒体源
	bool AddRecordFileToRecordSource(char* szShareURL,char* szFileName)
	{
		std::lock_guard<std::mutex> lock(ABL_CRecordFileSourceMapLock);

		CRecordFileSource_ptrMap::iterator iterator1;
	 
		iterator1 = xh_ABLRecordFileSourceMap.find(szShareURL);
		if (iterator1 != xh_ABLRecordFileSourceMap.end())
		{
			return (*iterator1).second->AddRecordFile(szFileName);
		}
		else
		{
			return false ;
		}
	}
	/* 录像文件存储 -------------------------------------------------------------------------------------*/

2、	增加录像下载速度设置 httpDownloadSpeed 
	ABL_MediaServerPort.httpDownloadSpeed = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "httpDownloadSpeed", "6"));
	if (ABL_MediaServerPort.httpDownloadSpeed > 10)
		ABL_MediaServerPort.httpDownloadSpeed = 10;

ABLMediaServer-2022-01-12【增加录像保存、查询录像、录像下载功能】
1、 如果帧速度5帧，强制修正为25帧
	//妈的，有些时间戳乱搞打包，强制赋值为25帧每秒 
	if (nVideoFrameSpeed <= 5)
		nVideoFrameSpeed = 25;

2、超过5帧都丢弃，有些音频乱打包，否则造成程序奔溃 
	//对AAC的rtp包进行切割
	void  CNethttpServer::SplitterRtpAACData(unsigned char* rtpAAC, int nLength)
	{
		au_header_length = (rtpAAC[0] << 8) + rtpAAC[1];
		au_header_length = (au_header_length + 7) / 8;  
		ptr = rtpAAC;

		au_size = 2;  
		au_numbers = au_header_length / au_size;

		//超过5帧都丢弃，有些音频乱打包
		if (au_numbers > 5 )
			return ;

ABLMediaServer-2022-01-11【增加录像保存、查询录像、录像下载功能】
1、国标TCP对象创建后，把代理的 m_addStreamProxyStruct 拷贝给国标TCP对象 m_addStreamProxyStruct
	CNetRevcBase_ptr gb28181RecvProxy = GetNetRevcBaseClientNoLock(hParent);
	if (gb28181RecvProxy != NULL)
	{//把国标代理的信息拷贝个国标TCP
		pXHClient->m_gbPayload = atoi(gb28181RecvProxy->m_openRtpServerStruct.payload);//更新paylad 
		memcpy((unsigned char*)&pXHClient->m_addStreamProxyStruct, (unsigned char*)&gb28181RecvProxy->m_addStreamProxyStruct, sizeof(gb28181RecvProxy->m_addStreamProxyStruct));
	}

2、重大BUG改进 http-mp4、fMP4切片保存为mp4文件都采用原来的架构、流程处理，fmp4切片在Linux下不会奔溃 
	int CNetServerHTTP_MP4::PushAudio(uint8_t* pAudioData, uint32_t nDataLength, char* szAudioCodec, int nChannels, int SampleRate)
	{
		if (ABL_MediaServerPort.nEnableAudio == 0)
			return -1;

		if (strcmp(mediaCodecInfo.szAudioName, "AAC") != 0)
			return 0;

		m_audioFifo.push(pAudioData, nDataLength);

		return 0;
	}

	int CNetServerHTTP_MP4::SendVideo()
	{
		std::lock_guard<std::mutex> lock(mediaMP4MapLock);
		
		if(!bCheckHttpMP4Flag)
			return -1 ;

		nRecvDataTimerBySecond = 0;

		if (!bCheckHttpMP4Flag)
			return -1;

		if (nVideoStampAdd == 0)
			nVideoStampAdd = 1000 / mediaCodecInfo.nVideoFrameRate;

		if (hlsFMP4 == NULL)
			hlsFMP4 = hls_fmp4_create((1) * 1000, fmp4_hls_segment, this);
	 
		videoDts += nVideoStampAdd;

		unsigned char* pData = NULL;
		int            nLength = 0;
		if ((pData = m_videoFifo.pop(&nLength)) != NULL)
		{
			if (hlsFMP4)
				VideoFrameToFMP4File(pData, nLength);

			m_videoFifo.pop_front();
		}
	}

	int CNetServerHTTP_MP4::SendAudio()
	{
		if(!bCheckHttpMP4Flag || ABL_MediaServerPort.nEnableAudio == 0 || strcmp(mediaCodecInfo.szAudioName, "AAC") != 0)
			return -1 ;
	  
		unsigned char* pData = NULL;
		int            nLength = 0;
		if ((pData = m_audioFifo.pop(&nLength)) != NULL)
		{
			if (ABL_MediaServerPort.nEnableAudio == 1 && strcmp(mediaCodecInfo.szAudioName, "AAC") == 0)
			{
				if (nAsyncAudioStamp == -1)
					nAsyncAudioStamp = GetTickCount();

				avtype = PSI_STREAM_AAC;

				if (hlsFMP4 != NULL && track_video >= 0)
				{
					if (track_aac == -1)
					{
						nAACLength = mpeg4_aac_adts_frame_length(pData, nLength);
						if (nAACLength < 0)
						{
							m_audioFifo.pop_front();
							return false;
						}

						mpeg4_aac_adts_load(pData, nLength, &aacHandle);
						nExtenAudioDataLength = mpeg4_aac_audio_specific_config_save(&aacHandle, szExtenAudioData, sizeof(szExtenAudioData));
						if (nExtenAudioDataLength > 0)
						{
							track_aac = hls_fmp4_add_audio(hlsFMP4, MOV_OBJECT_AAC, mediaCodecInfo.nChannels, 16, mediaCodecInfo.nSampleRate, szExtenAudioData, nExtenAudioDataLength);
						}
					}

					//必须hls_init_segment 初始化完成才能写音频段，在回调函数里面做标志 
					if (track_aac >= 0 && hls_init_segmentFlag)
					{
						hls_fmp4_input(hlsFMP4, track_aac, pData + 7, nLength - 7, audioDts, audioDts, 0);
					}
				}

				audioDts += mediaCodecInfo.nBaseAddAudioTimeStamp;

				//500毫秒同步一次 
				if (GetTickCount() - nAsyncAudioStamp >= 500)
				{
					if (videoDts < audioDts)
					{
						nVideoStampAdd = (1000 / mediaCodecInfo.nVideoFrameRate) + 5;
					}
					else if (videoDts > audioDts)
					{
						nVideoStampAdd = (1000 / mediaCodecInfo.nVideoFrameRate) - 5;
					}
					nAsyncAudioStamp = GetTickCount();
				}
			}
			m_audioFifo.pop_front();
		}
		return 0;
	}

ABLMediaServer-2022-01-10【增加录像保存、查询录像、录像下载功能】
1、优化录像文件名字，采用年月日时分秒 
	if (pNetServerHttpMp4->fWriteMP4 == NULL)
	{
#ifdef OS_System_Windows
		SYSTEMTIME st;
		GetLocalTime(&st);
		sprintf(pNetServerHttpMp4->szFileName,"%s%04d%02d%02d%02d%02d%02d.mp4", pNetServerHttpMp4->szRecordPath, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
#else
		time_t now;
		time(&now);
		struct tm *local;
		local = localtime(&now);
		sprintf(pNetServerHttpMp4->szFileName, "%s%04d%02d%02d%02d%02d%02d.mp4", pNetServerHttpMp4->szRecordPath, local->tm_year + 1900, local->tm_mon, local->tm_mday, local->tm_hour, local->tm_min, local->tm_sec);
#endif
	  pNetServerHttpMp4->fWriteMP4 = fopen(pNetServerHttpMp4->szFileName, "wb");
	}

2、支持用户设置的路径进行保存文件
	if (strlen(ABL_MediaServerPort.recordPath) == 0)
	   strcpy(ABL_MediaServerPort.recordPath, ABL_MediaSeverRunPath);
	else
	{//用户设置的路径,防止用户没有创建好路径
		int nPos = 0;
		char szTempPath[512] = { 0 };
		string strPath = ABL_MediaServerPort.recordPath;
		while (true)
		{
			nPos = strPath.find("\\", nPos+3);
			if (nPos > 0)
			{
				memcpy(szTempPath, ABL_MediaServerPort.recordPath, nPos);
				::CreateDirectory(szTempPath, NULL);
			}
			else
			{
				::CreateDirectory(ABL_MediaServerPort.recordPath, NULL);
				break;
			}
		}
	}

	//创建子路径 record 
	if (ABL_MediaServerPort.recordPath[strlen(ABL_MediaServerPort.recordPath) - 1] != '\\')
		strcat(ABL_MediaServerPort.recordPath, "\\");
	strcat(ABL_MediaServerPort.recordPath, "record\\");
	::CreateDirectory(ABL_MediaServerPort.recordPath, NULL);

	WriteLog(Log_Debug, "创建成功录像路径：%s ", ABL_MediaServerPort.recordPath);

3、国标接收对象创建时，把代理记录的信息拷贝给国标对象 
    
	 //UDP方式
	 boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerUDP, 0, nMediaClient, "", ABL_nGB28181Port, szTemp);
	 if (pClient != NULL)
	 {
		pClient->hParent     = nClient; //记录国标代理的句柄号，当国标发流、收流断线时，能同时销毁代理句柄资源 
		pClient->m_gbPayload = atoi(m_openRtpServerStruct.payload);//更新为正确的paylad
		memcpy((unsigned char*)&pClient->m_addStreamProxyStruct, (unsigned char*)&m_addStreamProxyStruct, sizeof(m_addStreamProxyStruct));
	 }

	//TCP方式 （因为TCP方式，连接成功后才产生国标接收对象）
	if (gb28181RecvProxy != NULL)
	{
		pXHClient->m_gbPayload = atoi(gb28181RecvProxy->m_openRtpServerStruct.payload);//更新paylad 
		strcpy(pXHClient->m_addStreamProxyStruct.app, gb28181RecvProxy->m_openRtpServerStruct.app);
		strcpy(pXHClient->m_addStreamProxyStruct.stream, gb28181RecvProxy->m_openRtpServerStruct.stream_id);
		strcpy(pXHClient->m_addStreamProxyStruct.enable_mp4, gb28181RecvProxy->m_openRtpServerStruct.enable_mp4);
	}
	
ABLMediaServer-2022-01-09【增加录像保存、查询录像、录像下载功能】
1、修正 class CNetServerHTTP_MP4 的一个定义变量的严重BUG
　　  unsigned char*       pH265Buffer[MediaStreamSource_VideoFifoLength];
　　修正为：
      unsigned char        pH265Buffer[MediaStreamSource_VideoFifoLength];
   
2、增加录像保存文件 "StreamRecordFMP4.cpp" "StreamRecordFMP4.h"
 
3、代理拉流增加是否保存参数 enable_mp4 
	GetKeyValue("enable_mp4", m_addStreamProxyStruct.enable_mp4);
	
	//检测enable_mp4 的值
	if (strlen(m_addStreamProxyStruct.enable_mp4) > 0 && !(strcmp(m_addStreamProxyStruct.enable_mp4,"1") == 0 || strcmp(m_addStreamProxyStruct.enable_mp4, "0") == 0))
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"enable_mp4 parameter error , enable_mp4 must [1 , 0 ]\",\"key\":%d}", IndexApiCode_ParamError, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}

4、在MediaSource 的pushVideo 函数中 增加创建录像对象 
	bool CMediaStreamSource::PushVideo(unsigned char* szVideo, int nLength, char* szVideoCodec)
	{//直接拷贝给每个网络发送对象 
		std::lock_guard<std::mutex> lock(mediaSendMapLock);
	
		//创建录制MP4对象
		if (enable_mp4 == true && recordMP4 == 0)
		{
			recordMP4 = XHNetSDK_GenerateIdentifier();
			CreateNetRevcBaseClient(NetBaseNetType_RecordFile_FMP4, 0, recordMP4, "", 0, "");
			WriteLog(Log_Debug, "创建录制MP4对象成功 app = %s ,stream = %s , recordMP4 = %llu ", app, stream, recordMP4);

			//加入媒体拷贝
			mediaSendMap.insert(MediaSendMap::value_type(recordMP4, recordMP4));

			//加入媒体发送
			pMediaSendThreadPool->AddClientToThreadPool(recordMP4);
		}
	
	析构函数增加 关闭录像对象 
	
	//关闭录像存储
	if (enable_mp4 && recordMP4 > 0)
		pDisconnectBaseNetFifo.push((unsigned char*)&recordMP4, sizeof(recordMP4));
		
5、代理拉流接入、国标接入都增加 是否录像 参数 enable_mp4 【1 录像，0 未录像】 		 
   char   enable_mp4[64]

6、开始、停止录像
 	bool  CNetServerHTTP::index_api_startStopRecord(bool bFlag)
	{
		char szShareMediaURL[256] = { 0 };

		memset((char*)&m_startStopRecordStruct, 0x00, sizeof(m_startStopRecordStruct));
		GetKeyValue("secret", m_startStopRecordStruct.secret);
		GetKeyValue("vhost", m_startStopRecordStruct.vhost);
		GetKeyValue("app", m_startStopRecordStruct.app);
		GetKeyValue("stream", m_startStopRecordStruct.stream);
	 
		if (strlen(m_startStopRecordStruct.secret) == 0 || strlen(m_startStopRecordStruct.app) == 0 || strlen(m_startStopRecordStruct.stream) == 0 )
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[secret , app , stream ] parameter need .\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strcmp(m_startStopRecordStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//app ,stream 这两个字符串里面不能有 / 
		if (strstr(m_startStopRecordStruct.app, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"app parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}
		if (strstr(m_startStopRecordStruct.stream, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"stream parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strlen(m_startStopRecordStruct.app) > 0 && strlen(m_startStopRecordStruct.stream) > 0)
		{
			//检测 app stream 是否存在
			sprintf(szShareMediaURL, "/%s/%s", m_startStopRecordStruct.app, m_startStopRecordStruct.stream);
			boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);
			if (tmpMediaSource == NULL)
			{
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s Not Found \"}", IndexApiCode_ParamError, szShareMediaURL);
				ResponseSuccess(szResponseBody);
				return false;
			}

			if (bFlag)
			{//开始录像
				if (tmpMediaSource->enable_mp4 == false && tmpMediaSource->recordMP4 == 0)
				{//尚未开始录像
				  sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s start Record .\"}", IndexApiCode_OK, szShareMediaURL);
				  tmpMediaSource->enable_mp4 = true;
				}
				else
				{//已经开始录像
					sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s have record .\"}", IndexApiCode_OK, szShareMediaURL);
				}
			}
			else
			{
				if (tmpMediaSource->enable_mp4 == true && tmpMediaSource->recordMP4 > 0 )
				{//已经开始录像
					sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s stop Record .\"}", IndexApiCode_OK, szShareMediaURL);
					tmpMediaSource->enable_mp4 = false ;
					pDisconnectBaseNetFifo.push((unsigned char*)&tmpMediaSource->recordMP4, sizeof(tmpMediaSource->recordMP4));
					tmpMediaSource->recordMP4 = 0;
				}
				else
				{//尚未开始录像
					sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s have not Record .\"}", IndexApiCode_OK, szShareMediaURL);
				}
			}
			ResponseSuccess(szResponseBody);
		}
		else
		{//参数错误 
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
		}

		return true;
	}

ABLMediaServer-2022-01-06【增加输出 http-mp4，彻底解决Linux 下的mp4轮询压测播放】
1、升级北京老陈的media-server 底层库，可以解决fmp4切片的内存泄露 

2、把pH265Buffer、s_packet 在创建fmp4切片时才产生内存块，这是造成在Linux下轮询压测奔溃的原因。

    删除掉 下面的内存分配，修改为构造函数分配，或者修改为字符数组即可。 
	if (pH265Buffer == NULL)
		pH265Buffer = new unsigned char[MediaStreamSource_VideoFifoLength];
		
	if (s_packet == NULL)
		s_packet = new unsigned char[1024*16];

3、国标TCP方式接收也修改为预先分配好内存块 
	if (GetNetServerTypeByHandle(serverHandle, szMediaSource,hParent) == NetServerHandleType_GB28181RecvStream)
	{//国标TCP方式接收码流
		CNetGB28181RtpServer* gb28181TCP = NULL ;
		pXHClient = boost::make_shared<CNetGB28181RtpServer>(serverHandle, CltHandle, szIP, nPort, szMediaSource);
		pXHClient->netBaseNetType = NetBaseNetType_NetGB28181RtpServerTCP_Server;//国标28181 tcp 方式接收码流 

		gb28181TCP = (CNetGB28181RtpServer*)pXHClient.get();
		if (gb28181TCP)
		  gb28181TCP->netDataCache = new unsigned char[MaxNetDataCacheBufferLength]; //在使用前先准备好内存 

		pXHClient->hParent = hParent;//记录国标代理句柄号

		CNetRevcBase_ptr gb28181RecvProxy = GetNetRevcBaseClientNoLock(hParent);
		if (gb28181RecvProxy != NULL)
			pXHClient->m_gbPayload = atoi(gb28181RecvProxy->m_openRtpServerStruct.payload);//更新paylad 
	}
	
4、	HLS 视频播放类 CNetServerHLS，pTsFileBuffer 也修改为在构造函数预先分配好内存块
	CNetServerHLS::CNetServerHLS(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
	{
 		//首次分配内存 
		pTsFileBuffer = NULL;
		while(pTsFileBuffer == NULL)
		{
			nCurrentTsFileBufferSize = MaxDefaultTsFmp4FileByteCount;
			pTsFileBuffer = new unsigned char[nCurrentTsFileBufferSize];
		}

5、 http-flv  ws-flv  MP4 rtmp 的流输出，如果15秒，没有码流输出，也要加入删除列表 
	((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpFLVServerSendPush ||//监测http-flv发流 
	((*iterator1).second)->netBaseNetType == NetBaseNetType_WsFLVServerSendPush ||//监测ws-flv发流 
	((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpMP4ServerSendPush || //监测MP4发流 
	((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpServerSendPush  //检测rtmp发流 
		
ABLMediaServer-2022-01-04【增加输出 http-mp4】
1、增加重连次数，并且可以设置，重连次数超过设定值，则进行销毁 

	 ABL_MediaServerPort.nReConnectingCount = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "ReConnectingCount", "48000"));

	((*iterator1).second)->nReConnectingCount ++; //重连次数累积 

	if (((*iterator1).second)->nReConnectingCount > ABL_MediaServerPort.nReConnectingCount)
	{
		WriteLog(Log_Debug, "nClient = %llu , nMediaClient = %llu ,url: %s 重连次数已经达到 %llu 次，需要断开 ", ((*iterator1).second)->nClient, ((*iterator1).second)->nMediaClient, ((*iterator1).second)->m_addStreamProxyStruct.url, ((*iterator1).second)->nReConnectingCount);
		pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof(((*iterator1).second)->nClient));
	}
	else
	{
		WriteLog(Log_Debug, "nClient = %llu , nMediaClient = %llu 检测到网络异常断开2 , %s ，现在执行第 %llu 次重连  ", ((*iterator1).second)->nClient, ((*iterator1).second)->nMediaClient,((*iterator1).second)->m_addStreamProxyStruct.url, ((*iterator1).second)->nReConnectingCount);
		pReConnectStreamProxyFifo.push((unsigned char*)&((*iterator1).second)->nClient,sizeof(((*iterator1).second)->nClient));
	}

2、如果更新过视频帧速度，说明代理成功过，该代理不能立即删除  	
	//如果是超时断开的，往往就是原来代理成功过的，需要无限次重连 
	if (((*iterator1).second)->bProxySuccessFlag == false && pClient->bUpdateVideoFrameSpeedFlag == true )
		((*iterator1).second)->bProxySuccessFlag = true;

3、如果重新连接成功，重连次数复位
				  
	if (pClient->bUpdateVideoFrameSpeedFlag == true && ((*iterator1).second)->nReConnectingCount != 0)
	{
		((*iterator1).second)->nReConnectingCount = 0;
		WriteLog(Log_Debug, "nClient = %llu , nMediaClient = %llu ,url %s ，重连次数复位为 0 ", ((*iterator1).second)->nClient, ((*iterator1).second)->nMediaClient, ((*iterator1).second)->m_addStreamProxyStruct.url);
	}
	
4、获取服务器配置信息增加重连次数参数 ABL_MediaServerPort.nReConnectingCount	 	
	sprintf(szMediaSourceInfoBuffer, "{\"code\":0,\"params\":[{\"enable_audio\":%d,\"memo\":\"enable_audio = 1 open Audio , enable_audio = 0 Close Audio \"},{\"httpServerPort\":%d,\"memo\":\"http api port \"},{\"httpPort\":%d,\"memo\":\"http port \"},{\"rtmpPort\":%d,\"memo\":\"rtmp port \"},{\"httpFlvPort\":%d,\"memo\":\"http-flv port \"},{\"hls_enable\":%d,\"memo\":\"hls whether enable \"},{\"hlsPort\":%d,\"memo\":\"hls port\"},{\"wsPort\":%d,\"memo\":\"websocket flv port\"},{\"mp4Port\":%d,\"memo\":\"http mp4 port\"},{\"hlsCutType\":%d,\"memo\":\"hlsCutType = 1 hls cut to Harddisk,hlsCutType = 2  hls cut Media to memory\"},{\"h265CutType\":%d,\"memo\":\" 1 h265 cut TS , 2 cut fmp4 \"},{\"RecvThreadCount\":%d,\"memo\":\" RecvThreadCount \"},{\"SendThreadCount\":%d,\"memo\":\"SendThreadCount\"},{\"GB28181RtpTCPHeadType\":%d,\"memo\":\"rtp Length Type\"},{\"rtpPacketOfhttp\":%d,\"memo\":\"http 1  rtp paylaod ES,2 rtp payload PS\"},{\"ReConnectingCount\":%d,\"memo\":\"Try reconnections times .\"}]}",
		ABL_MediaServerPort.nEnableAudio,ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nhttpPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nWSFlvPort, ABL_MediaServerPort.nHttpMp4Port, ABL_MediaServerPort.nHLSCutType, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nGBRtpTCPHeadType, ABL_MediaServerPort.nRtpPacketOfhttp, ABL_MediaServerPort.nReConnectingCount);
	ResponseSuccess(szMediaSourceInfoBuffer);


ABLMediaServer-2022-01-03【增加输出 http-mp4】
1、在CNetRectBase 、CMediaSource 类库中的音视频同步视频增量不能固定为45、35 ，需要用1000 除以 视频帧速度 
	void  CNetRevcBase::SyncVideoAudioTimestamp()
	{
		//500毫秒同步一次 
		if (GetTickCount() - nAsyncAudioStamp >= 500)
		{
			if (flvPS < flvAACDts)
			{
				nVideoStampAdd = (1000 / mediaCodecInfo.nVideoFrameRate ) + 5 ;
			}
			else if (flvPS > flvAACDts)
			{
				nVideoStampAdd = (1000 / mediaCodecInfo.nVideoFrameRate) - 5 ;
			}
			nAsyncAudioStamp = GetTickCount();

			//WriteLog(Log_Debug, "CMediaStreamSource = %X flvPS = %d ,flvAACDts = %d ", this, flvPS, flvAACDts);
		}
	}

2  判断是否成功过，如果尚未成功，则立即删除 ，如果成功过则无限次重连
    在代理拉流断线检测时，标识为已经成功代理过
	else if (((*iterator1).second)->netBaseNetType == NetBaseNetType_addStreamProxyControl || ((*iterator1).second)->netBaseNetType == NetBaseNetType_addPushProxyControl)
	{//控制代理拉流、代理推流,检测代理拉流是否有断线
		//如果是超时断开的，往往就是原来代理成功过的，需要无限次重连 
		if (((*iterator1).second)->bProxySuccessFlag == false)
			((*iterator1).second)->bProxySuccessFlag = true; 


    //在执行删除时，检测一下标志 
	CNetRevcBase_ptr pParent = GetNetRevcBaseClientNoLock(pClient->hParent);
	if (pParent->bProxySuccessFlag == false)
		pDisconnectBaseNetFifo.push((unsigned char*)&pClient->hParent, sizeof(pClient->hParent));

    //各种代理，如果成功了，需要设置个标志 
	else if (memcmp(data_, "http/1.0 200", 12) == 0 && nhttpProcessStep == httpProcessStep_PLAY && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
	{
		WriteLog(Log_Debug, "收到 Play 回复命令，http交互完毕 nClient = %llu ", nClient);
		bMediaProcessSuccessFlag = true;
	}
	
ABLMediaServer-2022-01-02【增加输出 http-mp4】
1、把绑定端口的返回值，起名为对应的网络协议，方便绑定端口出错时，好定位是那个端口 
   int nBindHttp, nBindhttp, nBindRtmp,nBindWsFlv,nBindHttpFlv, nBindHls,nBindMp4;
   
   WriteLog(Log_Debug, "Bind  nBindHttp = %d , nBindhttp = %d , nBindRtmp = %d ,nBindWsFlv = %d ,nBindHttpFlv = %d , nBindHls = %d ,nBindMp4 = %d \r\n", nBindHttp, nBindhttp, nBindRtmp, nBindWsFlv, nBindHttpFlv, nBindHls, nBindMp4);

2、http-flv,rtmp,hls,ws-flv,http-mp4 网络协议媒体输出，音视频同步起效。原来的音视频同步尚未起作用

   在基类赋值为0 
	nVideoStampAdd = 0 ;

  //首次计算，后面的由同步函数控制
  if (nVideoStampAdd == 0)
	 nVideoStampAdd = 1000 / mediaCodecInfo.nVideoFrameRate;

  //因视频同步
	void  CNetRevcBase::SyncVideoAudioTimestamp()
	{
		//500毫秒同步一次 
		if (GetTickCount() - nAsyncAudioStamp >= 1000)
		{
			if (flvPS < flvAACDts)
			{
				nVideoStampAdd = 45;
			}
			else if (flvPS > flvAACDts)
			{
				nVideoStampAdd = 35;
			}
			nAsyncAudioStamp = GetTickCount();

			//WriteLog(Log_Debug, "CMediaStreamSource = %X flvPS = %d ,flvAACDts = %d ", this, flvPS, flvAACDts);
		}
	}
  
ABLMediaServer-2022-01-01【增加输出 http-mp4】
1、更新北京老陈的底层媒体库

2、优化了一下http-mp4输出，没有那么容易奔溃，但是还没有彻底解决

3、在使用说明文件中增加了网络类型对照表
  
	  1 媒体输入网络类型对照表 
	  
		  整形值     代表意义
		  21         以rtmp方式推送接入流媒体服务器
		  23         以http方式推送接入流媒体服务器
		  30         服务器以http方式主动拉流接入
		  31         服务器以rtmp方式主动拉流接入  
		  32         服务器以flv方式主动拉流接入
		  33         服务器以hls方式主动拉流接入
		  60         服务器以国标28181的UDP方式接入
		  61         服务器以国标28181的TCP方式接入
		  
	  2 媒体输出网络类型对照表 	  
		 整形值     代表意义
		  22         服务器以http被动方式往外发送码流 ，即常见的vlc点播 
		  24         服务器以rtmp被动方式往外发送码流 ，即常见的vlc点播 
		  25         服务器以flv被动方式往外发送码流 ，即常见的vlc点播 、浏览器播放 
		  26         服务器以hls被动方式往外发送码流 ，即常见的vlc点播 、浏览器播放 
		  27         服务器以ws-flv被动方式往外发送码流 ,EasyPlayer.js插件播放、浏览器播放 
		  28         服务器以http-mp4被动方式往外发送码流 ，即常见的vlc点播 、浏览器播放 
		  
		  40         服务器以http主动方式往外发送码流 ，即常见的http推流
		  41         服务器以rtmp主动方式往外发送码流 ，即常见的rtmp推流
		  65         服务器以国标GB28181主动UDP方式往外发送码流 ，即常见的国标以UDP方式往上级推流
		  66         服务器以国标GB28181主动TCP方式往外发送码流 ，即常见的国标以TCP方式往上级推流



ABLMediaServer-2021-12-29【增加输出 http-mp4】
1、增加用户配置本地IP地址，如果用户不配置，则程序自动获取一个，要是配置则使用配置的IP地址
	//获取用户配置的IP地址 
	strcpy(ABL_szLocalIP, ABL_ConfigFile.ReadConfigString("ABLMediaServer", "localipAddress", ""));

	//自动获取IP地址
	if (strlen(ABL_szLocalIP) == 0)
	{
		string strIPTemp;
		GetLocalAdaptersInfo(strIPTemp);
		int nPos = strIPTemp.find(",", 0);
		if (nPos > 0)
 		  memcpy(ABL_szLocalIP, strIPTemp.c_str(), nPos);
		 else 
		  strcpy(ABL_szLocalIP, "127.0.0.1");
	}

ABLMediaServer-2021-12-28【增加输出 http-mp4】
1、在DeleteNetRevcBaseClient 函数中，删除掉  pRemoveBaseNetFromThreadFifo.push((unsigned char*)&CltHandle, sizeof(uint64_t));
	bool  DeleteNetRevcBaseClient(NETHANDLE CltHandle)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;

		iterator1 = xh_ABLNetRevcBaseMap.find(CltHandle);
		if (iterator1 != xh_ABLNetRevcBaseMap.end())
		{
			pRemoveBaseNetFromThreadFifo.push((unsigned char*)&CltHandle, sizeof(uint64_t)); //加入FIFO，在另一个线程进行移除 

			xh_ABLNetRevcBaseMap.erase(iterator1);
			return true;
		}
		else
		{
			return false;
		}
	}
	
2、在onclose()函数中 pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));替换为  DeleteNetRevcBaseClient(clihandle);
	DeleteNetRevcBaseClient(clihandle);
 
3、在移除掉拷贝线程、发送线程时，删除掉  pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));
	//先做移除
	if (pRemoveBaseNetFromThreadFifo.GetSize() > 0)
	{//定期移除掉拷贝线程、发送线程 
		while ((pData = pRemoveBaseNetFromThreadFifo.pop(&nLength)) != NULL)
		{
			if (nLength == sizeof(nClient))
			{
				memcpy((char*)&nClient, pData, sizeof(nClient));
				if (nClient > 0)
				{
					DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
					pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
					
					//删除掉 
					//pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
 				}
			}

			pRemoveBaseNetFromThreadFifo.pop_front();
		}
	}

4、在 CNetRevcBase 的析构函数中删除掉 	
	CNetRevcBase::~CNetRevcBase()
	{
		pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
		pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nClient, sizeof(nClient));
	}
	
5、在回复http时，替换 \r\n 为空格  
	bool  CNetRevcBase::ResponseHttp(uint64_t nHttpClient,char* szSuccessInfo,bool bClose)
	{
		std::lock_guard<std::mutex> lock(httpResponseLock);

		if (bResponseHttpFlag)
			return true;

		//回复http请求
		string strReponseError = szSuccessInfo ;
		replace_all(strReponseError, "\r\n", " ");
		strcpy(szSuccessInfo, strReponseError.c_str());	
	
ABLMediaServer-2021-12-27【增加输出 http-mp4】
1、完成Linux平台的IP地址获取
	bool GetLocalAdaptersInfo(string& strIPList)
	{
		struct ifaddrs *ifaddr, *ifa;

		int family, s;

		char szAllIPAddress[4096]={0};
		char host[NI_MAXHOST] = {0};

		if (getifaddrs(&ifaddr) == -1) 
		{ //通过getifaddrs函数得到所有网卡信息
			return false ;
		}

		for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) 
		{ //做链表做循环

			if (ifa->ifa_addr == NULL) //判断地址是否为空
				continue;

			family = ifa->ifa_addr->sa_family; //得到IP地址的协议族
	 
			if (family == AF_INET ) 
			{ //判断协议族是AF_INET还是AF_INET6
				memset(host,0x00, NI_MAXHOST);
				 
				//通过getnameinfo函数得到对应的IP地址。NI_MAXHOST为宏定义，值为1025. NI_NUMERICHOST宏定义，和NI_NUMERICSERV对应，都试一下就知道了。
				s = getnameinfo(ifa->ifa_addr,
					(family == AF_INET) ? sizeof(struct sockaddr_in) :
					sizeof(struct sockaddr_in6),
					host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);

				 if(strcmp(host,"127.0.0.1") != 0)
				 {
				   strcat(szAllIPAddress,host);
				   strcat(szAllIPAddress,",");
				 }	
				 
				 if (s != 0) 
				 {
					printf("getnameinfo() failed: %s\n", gai_strerror(s));
				 }
			}
		}
		WriteLog(Log_Debug, "szAllIPAddress = %s ",szAllIPAddress);
		strIPList = szAllIPAddress;
		
		return true ;
	}

ABLMediaServer-2021-12-26【增加输出 http-mp4】
1、由于修改了发送函数，写日志大小控制条件也要变化，小于２０４８才写入日志文件　
	if(nPos < 2048 )
	  WriteLog(Log_Debug, szSuccessInfo);

2、增加获取windows平台下的IP地址，如果获取到２个以上，则拷贝第一个地址　　
	bool GetLocalAdaptersInfo(string& strIPList)
	{
		//IP_ADAPTER_INFO结构体
		PIP_ADAPTER_INFO pIpAdapterInfo = NULL;
		pIpAdapterInfo = new IP_ADAPTER_INFO;

		//结构体大小
		unsigned long ulSize = sizeof(IP_ADAPTER_INFO);

		//获取适配器信息
		int nRet = GetAdaptersInfo(pIpAdapterInfo, &ulSize);

		if (ERROR_BUFFER_OVERFLOW == nRet)
		{
			//空间不足，删除之前分配的空间
			delete[]pIpAdapterInfo;

			//重新分配大小
			pIpAdapterInfo = (PIP_ADAPTER_INFO) new BYTE[ulSize];

			//获取适配器信息
			nRet = GetAdaptersInfo(pIpAdapterInfo, &ulSize);

			//获取失败
			if (ERROR_SUCCESS != nRet)
			{
				if (pIpAdapterInfo != NULL)
				{
					delete[]pIpAdapterInfo;
				}
				return FALSE;
			}
		}

		//MAC 地址信息
		char szMacAddr[20];
		//赋值指针
		PIP_ADAPTER_INFO pIterater = pIpAdapterInfo;
		while (pIterater)
		{
			//cout << "网卡名称：" << pIterater->AdapterName << endl;

			//cout << "网卡描述：" << pIterater->Description << endl;

			sprintf_s(szMacAddr, 20, "%02X-%02X-%02X-%02X-%02X-%02X",
				pIterater->Address[0],
				pIterater->Address[1],
				pIterater->Address[2],
				pIterater->Address[3],
				pIterater->Address[4],
				pIterater->Address[5]);

			//cout << "MAC 地址：" << szMacAddr << endl;
			//cout << "IP地址列表：" << endl << endl;

			//指向IP地址列表
			PIP_ADDR_STRING pIpAddr = &pIterater->IpAddressList;
			while (pIpAddr)
			{
				//cout << "IP地址：  " << pIpAddr->IpAddress.String << endl;
				//cout << "子网掩码：" << pIpAddr->IpMask.String << endl;

				strIPList += pIpAddr->IpAddress.String;
				strIPList += ",";

				//指向网关列表
				PIP_ADDR_STRING pGateAwayList = &pIterater->GatewayList;
				while (pGateAwayList)
				{
					//cout << "网关：    " << pGateAwayList->IpAddress.String << endl;
					pGateAwayList = pGateAwayList->Next;
				}
				pIpAddr = pIpAddr->Next;
			}
			//cout << endl << "--------------------------------------------------" << endl;
			pIterater = pIterater->Next;
		}

		//清理
		if (pIpAdapterInfo)
		{
			delete[]pIpAdapterInfo;
		}

		return true;
	}

　　拷贝IP地址　
	string strIPTemp;
	GetLocalAdaptersInfo(strIPTemp);
	int nPos = strIPTemp.find(",", 0);
	if (nPos > 0)
 	  memcpy(ABL_szLocalIP, strIPTemp.c_str(), nPos);
	 else 
	  strcpy(ABL_szLocalIP, "127.0.0.1");

ABLMediaServer-2021-12-25【增加输出 http-mp4】
1、删除许多类，在析构函数中的如下代码，不需要单独删除，在基类中已经加入链表等待删除 

   	//从媒体拷贝线程池移除
	DeleteClientMediaStreamSource(nClient);
	pMediaSendThreadPool->DeleteClientToThreadPool(nClient);

	boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(m_szShareMediaURL);
	if (pMediaSource != NULL)
	   pMediaSource->DeleteClientFromMap(nClient);

2、http 服务器，在回复请求时，发送模块优化，有时候回复的buffer 可能有5、6兆，需要分比发送 ，最大长度 Send_ResponseHttp_MaxPacketCount
	//回复成功信息
	bool  CNetServerHTTP::ResponseSuccess(char* szSuccessInfo)
	{
		std::lock_guard<std::mutex> lock(httpResponseLock);

		int nLength = strlen(szSuccessInfo);
		if(strlen(szConnection) == 0)
		  sprintf(szResponseHttpHead, "HTTP/1.1 200 OK\r\nServer: %s\r\nContent-Type: application/json;charset=utf-8\r\nAccess-Control-Allow-Origin: *\r\nConnection: close\r\nContent-Length: %d\r\n\r\n", MediaServerVerson, nLength);
		else
		 sprintf(szResponseHttpHead, "HTTP/1.1 200 OK\r\nServer: %s\r\nContent-Type: application/json;charset=utf-8\r\nAccess-Control-Allow-Origin: *\r\nConnection: %s\r\nContent-Length: %d\r\n\r\n", MediaServerVerson, szConnection, nLength);
		XHNetSDK_Write(nClient, (unsigned char*)szResponseHttpHead, strlen(szResponseHttpHead), 1);

		int nPos = 0;
		int nWriteRet;
		int nSendErrorCount = 0;
		while (nLength > 0 && szSuccessInfo != NULL)
		{
			if (nLength > Send_ResponseHttp_MaxPacketCount)
			{
				nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)szSuccessInfo + nPos, Send_ResponseHttp_MaxPacketCount, 1);
				nLength -= Send_ResponseHttp_MaxPacketCount;
				nPos += Send_ResponseHttp_MaxPacketCount;
			}
			else
			{
				nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)szSuccessInfo + nPos, nLength, 1);
				nPos += nLength;
				nLength = 0;
			}

			if (nWriteRet != 0)
			{//发送出错
				nSendErrorCount++;
				if (nSendErrorCount >= 5)
				{
					WriteLog(Log_Debug, "CNetServerHTTP = %X nClient = %llu 发送次数超过 %d 次 ，准备删除 ", this, nClient, nSendErrorCount);
					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
					break;
				}
			}
			else
				nSendErrorCount = 0;
		}

		if(nLength < 1024 )
		  WriteLog(Log_Debug, szSuccessInfo);
	  
		return true;
	}
	
3、获取本机的IP地址，包括windows平台、Linux平台 
	

4、在回复的媒体源中增加返回 http、rtmp、http-flv、ws-flv、http-mp4 的url 
	if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
	{
		memset(szTemp2, 0x00, sizeof(szTemp2));
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"url\":{\"http\":\"http://%s:%d/%s/%s\",\"rtmp\":\"rtmp://%s:%d/%s/%s\",\"http-flv\":\"http://%s:%d/%s/%s.flv\",\"ws-flv\":\"ws://%s:%d/%s/%s.flv\",\"http-mp4\":\"http://%s:%d/%s/%s.mp4\",\"http-hls\":\"http://%s:%d/%s/%s.m3u8\"}},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.nWidth, tmpMediaSource->m_mediaCodecInfo.nHeight, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate,
			ABL_szLocalIP, ABL_MediaServerPort.nhttpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nRtmpPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nWSFlvPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHttpMp4Port, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream,
			ABL_szLocalIP, ABL_MediaServerPort.nHlsPort, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);

		strcat(szMediaSourceInfo, szTemp2);

		nMediaCount++;
	}

ABLMediaServer-2021-12-24【增加输出 http-mp4】
1、在服务关闭时，关闭3个tcp端口 
	XHNetSDK_Unlisten(srvhandle_6088);
	XHNetSDK_Unlisten(srvhandle_8089);
	XHNetSDK_Unlisten(srvhandle_9088);

2、获取系统信息增加 ws-flv、http-mp4 两个端口
	 
	bool CNetServerHTTP::index_api_getServerConfig()
	{
		memset((char*)&m_getServerConfigStruct, 0x00, sizeof(m_getServerConfigStruct));

		GetKeyValue("secret", m_getServerConfigStruct.secret);
	 
		if (strcmp(m_getServerConfigStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, MaxMediaSourceInfoLength);
		sprintf(szMediaSourceInfoBuffer, "{\"code\":0,\"params\":[{\"httpServerPort\":%d,\"memo\":\"http api port \"},{\"httpPort\":%d,\"memo\":\"http port \"},{\"rtmpPort\":%d,\"memo\":\"rtmp port \"},{\"httpFlvPort\":%d,\"memo\":\"http-flv port \"},{\"hls_enable\":%d,\"memo\":\"hls whether enable \"},{\"hlsPort\":%d,\"memo\":\"hls port\"},{\"wsPort\":%d,\"memo\":\"websocket flv port\"},{\"mp4Port\":%d,\"memo\":\"http mp4 port\"},{\"hlsCutType\":%d,\"memo\":\"hlsCutType = 1 hls cut to Harddisk,hlsCutType = 2  hls cut Media to memory\"},{\"h265CutType\":%d,\"memo\":\" 1 h265 cut TS , 2 cut fmp4 \"},{\"RecvThreadCount\":%d,\"memo\":\" RecvThreadCount \"},{\"SendThreadCount\":%d,\"memo\":\"SendThreadCount\"},{\"GB28181RtpTCPHeadType\":%d,\"memo\":\"rtp Length Type\"},{\"rtpPacketOfhttp\":%d,\"memo\":\"http 1  rtp paylaod ES,2 rtp payload PS\"}]}",
			ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nhttpPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nWSFlvPort, ABL_MediaServerPort.nHttpMp4Port, ABL_MediaServerPort.nHLSCutType, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nGBRtpTCPHeadType, ABL_MediaServerPort.nRtpPacketOfhttp);
		ResponseSuccess(szMediaSourceInfoBuffer);

		return true;
	}
	
3、在移除拷贝线程、发送线程时，增加删除断裂对象 pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient)); 
    1）	 
		if (pRemoveBaseNetFromThreadFifo.GetSize() > 0)
		{//定期移除掉拷贝线程、发送线程 
			while ((pData = pRemoveBaseNetFromThreadFifo.pop(&nLength)) != NULL)
			{
				if (nLength == sizeof(nClient))
				{
					memcpy((char*)&nClient, pData, sizeof(nClient));
					if (nClient > 0)
					{
 						DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
						pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 

						pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
					}
				}

				pRemoveBaseNetFromThreadFifo.pop_front();
			}
		}
    
	2 ） 在 DeleteClientFromMap 删除掉  pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
	bool CMediaStreamSource::DeleteClientFromMap(NETHANDLE nClient)
	{
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		MediaSendMap::iterator it;
		it = mediaSendMap.find(nClient);
		if (it != mediaSendMap.end())
		{
		    //删除掉 
			//pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));

			mediaSendMap.erase(it);
			WriteLog(Log_Debug, "把一个客户端 %llu 从媒体资源拷贝线程移除 ", nClient);
			return true;
		}else
		   return false ;
	}

4、优化Http接收Get、POST两个方式处理模块

	int CNetServerHTTP::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(NetServerHTTPLock);
		int nHttpHeadEndPos = CheckHttpHeadEnd();

		if ( !(memcmp(netDataCache, "GET ", 4) == 0 || memcmp(netDataCache, "POST ", 5) == 0))
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X , nClient = %llu , 接收的数据非法 ", this, nClient);
			DeleteNetRevcBaseClient(nClient);
		}

		if (nHttpHeadEndPos < 0 )
			return -1;

		memset(szHttpHead, 0x00, sizeof(szHttpHead));
		memcpy(szHttpHead, netDataCache + nNetStart, nHttpHeadEndPos - nNetStart + 4 );
		httpParse.ParseSipString(szHttpHead);

		nContent_Length = 0;
		memset(szContentLength, 0x00, sizeof(szContentLength));
		if (httpParse.GetFieldValue("Content-Length", szContentLength))
		{//POST 
			nContent_Length = atoi(szContentLength);

			if (nContent_Length <= 0)
			{//如果为post 方式，必须填写body内容
				WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误1 nClient = %llu ", this, nClient);
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"body content Not Found \",\"key\":%d}", IndexApiCode_HttpProtocolError, 0);
				ResponseSuccess(szResponseBody);

				//全部清空
				nNetStart = nNetEnd = netDataCacheLength = 0;
				memset(netDataCache, 0x00, MaxNetServerHttpBuffer);
				return -1;
			}
	 
			if (netDataCacheLength - (nHttpHeadEndPos + 4) < nContent_Length  )
				return -2;//数据尚未接收完整 

			memset(szHttpPath, 0x00, sizeof(szHttpPath));
			if (httpParse.GetFieldValue("POST", szHttpPath) == false)
			{
				WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误2 nClient = %llu ", this, nClient);
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Http Protocol Error \",\"key\":%d}", IndexApiCode_HttpProtocolError, 0);
				ResponseSuccess(szResponseBody);
				
				//全部清空
				nNetStart = nNetEnd = netDataCacheLength = 0;
				memset(netDataCache, 0x00, MaxNetServerHttpBuffer);
				return -3;
			}

			//去掉HTTP 1.1 
			string strHttpPath = szHttpPath;
			int    nPos;
			nPos = strHttpPath.find(" HTTP", 0);
			if (nPos > 0)
				szHttpPath[nPos] = 0x00;

			//去掉？号后面的参数
			strHttpPath = szHttpPath;
			nPos = strHttpPath.find("?", 0);
			if (nPos > 0)
				szHttpPath[nPos] = 0x00;

			memset(szHttpBody, 0x00, sizeof(szHttpBody));
			memcpy(szHttpBody, netDataCache + nHttpHeadEndPos + 4, nContent_Length);

			ResponseHttpRequest("POST", szHttpPath, szHttpBody);
		}
		else
		{
			memset(szHttpPath, 0x00, sizeof(szHttpPath));
			memset(szHttpBody, 0x00, sizeof(szHttpBody));
			
			if (httpParse.GetFieldValue("GET", szHttpPath) == false)
			{
				WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误3 nClient = %llu ", this, nClient);
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Http Protocol Error \",\"key\":%d}", IndexApiCode_HttpProtocolError, 0);
				ResponseSuccess(szResponseBody);

				//全部清空 
				nNetStart = nNetEnd = netDataCacheLength = 0;
				memset(netDataCache, 0x00, MaxNetServerHttpBuffer);
				return -4;
			}
			//去掉HTTP 1.1 
			string strHttpPath = szHttpPath;
			int    nPos;
			nPos = strHttpPath.find(" HTTP", 0);
			if (nPos > 0)
				szHttpPath[nPos] = 0x00;

			//去掉？号,把?后面buffer，作为参数
			strHttpPath = szHttpPath;
			nPos = strHttpPath.find("?", 0);
			if (nPos > 0)
			{
				memcpy(szHttpBody, szHttpPath + nPos + 1, strlen(szHttpPath) - nPos - 1);
				szHttpPath[nPos] = 0x00;
			}
	 
			ResponseHttpRequest("GET", szHttpPath, szHttpBody);
		}

		//把剩余的buff往前移动 
		netDataCacheLength = netDataCacheLength - (nHttpHeadEndPos + 4 + nContent_Length);
		if (netDataCacheLength > 0)
		{
			memmove(netDataCache, netDataCache + (nHttpHeadEndPos + 4 + nContent_Length), netDataCacheLength);
			nNetStart = 0;
			nNetEnd = netDataCacheLength;

			//把剩余的空间清空 
			memset(netDataCache + nNetEnd , 0x00, MaxNetServerHttpBuffer - nNetEnd );
		}
		else
		{
			nNetStart = nNetEnd = netDataCacheLength = 0;

			//全部清空 
			memset(netDataCache, 0x00, MaxNetServerHttpBuffer);
		}
	 
		return 0;
	}
	
ABLMediaServer-2021-12-23【增加输出 http-mp4】
1、http-mp4发送修改为每32K发送一次
	int CNetServerHTTP_MP4::SendVideo()
	{
		unsigned char* pData = NULL;
		int            nLength = 0;
		int            nPos = 0;
		int            nSendErrorCount = 0 ;

		if ((pData = m_videoFifo.pop(&nLength)) != NULL)
		{
			if (nLength > 0)
			{
				//发送MP4码流 
				nPos = 0 ;
				while (nLength > 0 && pData != NULL)
				{
					if (nLength > Send_MP4File_MaxPacketCount)
					{
						nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)pData + nPos, Send_MP4File_MaxPacketCount, 1);
						nLength -= Send_MP4File_MaxPacketCount;
						nPos += Send_MP4File_MaxPacketCount;
					}
					else
					{
						nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)pData + nPos, nLength, 1);
						nPos += nLength;
						nLength = 0;
					}

					if (nWriteRet != 0)
					{//发送出错
						nSendErrorCount ++;
						if (nSendErrorCount >= 5)
						{
							WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X nClient = %llu 发送次数超过 %d 次 ，准备删除 ", this, nClient, nSendErrorCount);
							pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
							break;
						}
					}
				}
			}
			m_videoFifo.pop_front();
		}
		return 0;
	}

ABLMediaServer-2021-12-21【增加输出 http-mp4】
1、获取媒体源函数增加 app、stream 这个两个条件关键字 
	int GetAllMediaStreamSource(char* szMediaSourceInfo, getMediaListStruct mediaListStruct)
	{
			std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

			CNetRevcBase_ptrMap::iterator iterator1;
			CNetRevcBase_ptr   pClient = NULL;
			int   nMediaCount = 0;
			char  szTemp2[4096] = { 0 };
			char  szShareMediaURL[256];
			bool  bAddFlag = false;

			bAddFlag = false;

			if (strlen(mediaListStruct.app) == 0 && strlen(mediaListStruct.stream) == 0 && tmpMediaSource != NULL)
			{
				  bAddFlag = true;
 			}
			else if (strlen(mediaListStruct.app) > 0 && strlen(mediaListStruct.stream) > 0 && tmpMediaSource != NULL)
			{
				if (strcmp(mediaListStruct.app, tmpMediaSource->app) == 0 && strcmp(mediaListStruct.stream, tmpMediaSource->stream) == 0)
					bAddFlag = true;
			}
			else if (strlen(mediaListStruct.app) > 0 && strlen(mediaListStruct.stream) == 0 && tmpMediaSource != NULL)
			{
				if (strcmp(mediaListStruct.app, tmpMediaSource->app) == 0)
					bAddFlag = true;
			}
			else if (strlen(mediaListStruct.app) == 0 && strlen(mediaListStruct.stream) > 0 && tmpMediaSource != NULL)
			{
				if ( strcmp(mediaListStruct.stream, tmpMediaSource->stream) == 0)
					bAddFlag = true;
			}
			else
				bAddFlag = false ;

			if (bAddFlag == true && tmpMediaSource != NULL )
			{
				if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
				{
					sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"width\":%d,\"height\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
						tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.nWidth, tmpMediaSource->m_mediaCodecInfo.nHeight,tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

					strcat(szMediaSourceInfo, szTemp2);

					nMediaCount++;
				}
 			}

 2、获取所有往外发送的列表函数中，增加 NetBaseNetType_HttpMP4ServerSendPush ，mp4播放类型 
	int GetAllOutList(char* szMediaSourceInfo, char* szOutType)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		CNetRevcBase_ptr   pClient = NULL;
		int   nMediaCount = 0;
		char  szTemp2[1024] = { 0 };
	 
		if (xh_ABLMediaStreamSourceMap.size() > 0)
		{
			strcpy(szMediaSourceInfo, "{\"code\":0,\"memo\":\"success\",\"outList\":[");
		}

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); ++iterator1)
		{
			pClient = (*iterator1).second;

			if (pClient->netBaseNetType == NetBaseNetType_RtmpServerSendPush || pClient->netBaseNetType == NetBaseNetType_httpServerSendPush || pClient->netBaseNetType == NetBaseNetType_HttpFLVServerSendPush ||
				pClient->netBaseNetType == NetBaseNetType_HttpHLSServerSendPush || pClient->netBaseNetType == NetBaseNetType_WsFLVServerSendPush || pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpUDP || 
				pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect || pClient->netBaseNetType == NetBaseNetType_httpClientPush || pClient->netBaseNetType == NetBaseNetType_RtmpClientPush ||
				pClient->netBaseNetType == NetBaseNetType_HttpMP4ServerSendPush )
			{

  3、HLS切片、htt-mp4 视频输出的 s_packet 不需要很大的缓存，只需要 16K即可 
  
	 if (s_packet == NULL)
		 s_packet = new unsigned char[1024*16];
		 
	static int hls_init_segment(hls_fmp4_t* hls, void* param)
	{
		CMediaStreamSource* pMediaSource = (CMediaStreamSource*)param;
		if (pMediaSource == NULL)
			return 0;

		int bytes = hls_fmp4_init_segment(hls, pMediaSource->s_packet, 1024*16);
		
 4、http-mp4 ts 流发送移动到 sendVideo 函数中，不要在切片回调函数进行发送。
 
	int CNetServerHTTP_MP4::SendVideo()
	{
		unsigned char* pData = NULL;
		int            nLength = 0;

		if ((pData = m_videoFifo.pop(&nLength)) != NULL)
		{
			if (nLength > 0)
			{
				nWriteRet = XHNetSDK_Write(nClient, pData, nLength, 1);
				if (nWriteRet != 0)
				{
					WriteLog(Log_Debug, "CNetServerHTTP_MP4 = %X SendVideo() 发送出错，准备删除 nClient = %llu ", this,nClient);
					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				}
			}
			m_videoFifo.pop_front();
		}
		return 0;
	}

 5、如果查找不到可以媒体流，返回 -1003 ，并且提示 app ,stream 的值

	if (nMediaCount == 0)
	{
		sprintf(szMediaSourceInfo, "{\"code\":%d,\"memo\":\"MediaSource [app: %s , stream: %s] Not Found .\"}", IndexApiCode_MediaSourceNotFound, mediaListStruct.app, mediaListStruct.stream);
	}
  
ABLMediaServer-2021-12-20【增加输出 http-mp4】
1、把DeleteNetRevcBaseClient 函数中的 XHNetSDK_Disconnect 删除掉，否则可能引发卡死 
	bool  DeleteNetRevcBaseClient(NETHANDLE CltHandle)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;

		iterator1 = xh_ABLNetRevcBaseMap.find(CltHandle);
		if (iterator1 != xh_ABLNetRevcBaseMap.end())
		{
		    /*-- 删除掉 XHNetSDK_Disconnect ----*/
			// XHNetSDK_Disconnect((*iterator1).second->nClient);

			pRemoveBaseNetFromThreadFifo.push((unsigned char*)&CltHandle, sizeof(uint64_t)); //加入FIFO，在另一个线程进行移除 

			xh_ABLNetRevcBaseMap.erase(iterator1);
			return true;
		}
		else
		{
			return false;
		}
	}

2、扩大 SipFieldStruct 结构的值 	
	struct SipFieldStruct
	{
		char szKey[384];
		char szValue[1024*16];
		SipFieldStruct()
		{
			memset(szKey, 0x00, sizeof(szKey));
			memset(szValue, 0x00, sizeof(szValue));
		}
	};

3、把CMeidaSource 里面的   int64_t  tsDeleteTime 修改为 int64_t   tsCreateTime; 
 
4、在获取视频宽、高函数中，增加时间范围限制，防止一直在获取视频宽、高  
	bool  CMediaStreamSource::GetVideoWidthHeight(unsigned char* pVideoData, int nDataLength)
	{
		if (!(m_mediaCodecInfo.nWidth == 0 && m_mediaCodecInfo.nHeight == 0))
			return false;

		//防止有些视频分析不出宽、高，一直在疯狂的计算视频宽、高，30秒内，如分析不出，往后就不再分析、计算宽高 
		if ((GetTickCount64() - tsCreateTime) > 1000 * 30)
			return false;

 
ABLMediaServer-2021-12-19【增加输出 http-mp4】
1、增加切片音频
	int CNetServerHTTP_MP4::PushAudio(uint8_t* pVideoData, uint32_t nDataLength, char* szAudioCodec, int nChannels, int SampleRate)
	{
		std::lock_guard<std::mutex> lock(mediaMP4MapLock);

		if (ABL_MediaServerPort.nEnableAudio == 1 && strcmp(mediaCodecInfo.szAudioName, "AAC") == 0)
		{
			if (nAsyncAudioStamp == -1)
				nAsyncAudioStamp = GetTickCount();

			avtype = PSI_STREAM_AAC;

			if (hlsFMP4 != NULL && track_video >= 0 )
			{
				if (track_aac == -1)
				{
					nAACLength = mpeg4_aac_adts_frame_length(pVideoData, nDataLength);
					if (nAACLength < 0)
						return false;

					mpeg4_aac_adts_load(pVideoData, nDataLength, &aacHandle);
					nExtenAudioDataLength = mpeg4_aac_audio_specific_config_save(&aacHandle, szExtenAudioData, sizeof(szExtenAudioData));
					if (nExtenAudioDataLength > 0)
					{
						track_aac = hls_fmp4_add_audio(hlsFMP4, MOV_OBJECT_AAC, nChannels, 16, SampleRate, szExtenAudioData, nExtenAudioDataLength);
					}
				}

				//必须hls_init_segment 初始化完成才能写音频段，在回调函数里面做标志 
				if (track_aac >= 0 && hls_init_segmentFlag)
				{
					hls_fmp4_input(hlsFMP4, track_aac, pVideoData + 7, nDataLength - 7, audioDts, audioDts, 0);
				}
			}

			audioDts += mediaCodecInfo.nBaseAddAudioTimeStamp;

			//500毫秒同步一次 
			if (GetTickCount() - nAsyncAudioStamp >= 500)
			{
				if (videoDts < audioDts)
				{
					nVideoStampAdd = 45;
				}
				else if (videoDts > audioDts)
				{
					nVideoStampAdd = 35;
				}
				nAsyncAudioStamp = GetTickCount();
			}
		}

		return 0;
	}

2、增加http-mp4 媒体数据发送，vlc播放视频初步正常

ABLMediaServer-2021-12-18【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、增加 查找SPS出现的位置
	unsigned  int  CNetRevcBase::FindSpsPosition(unsigned char* szVideoBuffer, int nBufferLength, bool &bFind)
	{
		unsigned int nPos = 0;
		unsigned char H265HeadFlag[4] = { 0x00,0x00,0x00,0x01 };
		unsigned char nFrameTypeH265, nTempFrame;
		bFind = false;
		for (int i = 0; i < nBufferLength; i++)
		{
			if (memcmp(H265HeadFlag, szVideoBuffer + i, 4) == 0)
			{
				if (strcmp(mediaCodecInfo.szVideoName, "H264") == 0)
				{
					nTempFrame = (szVideoBuffer[i + 4] & 0x1F);
					if (nTempFrame == 7)
					{
						nPos = i;
						bFind = true;
						break;
					}
				}
				else if (strcmp(mediaCodecInfo.szVideoName, "H265") == 0)
				{
					nTempFrame = szVideoBuffer[i + 4];
					nFrameTypeH265 = (nTempFrame & 0x7E) >> 1;
					if (nFrameTypeH265 == 33)
					{//SPS帧
						nPos = i;
						bFind = true;
						break;
					}
				}
			}
		}

		return nPos + 4;
	}

2   获取H265宽、高
	bool  CNetRevcBase::ParseSequenceParameterSet(BYTE* data, int size, vc_params_t& params)
	{
		if (size < 20)
		{
			return false;
		}
		NALBitstream bs(data, size);
		// seq_parameter_set_rbsp()  
		bs.GetWord(4);// sps_video_parameter_set_id  
		int sps_max_sub_layers_minus1 = bs.GetWord(3);
		if (sps_max_sub_layers_minus1 > 6)
		{
			return false;
		}
		bs.GetWord(1);
		{
			bs.GetWord(2);
			bs.GetWord(1);
			params.profile = bs.GetWord(5);
			bs.GetWord(32);//  
			bs.GetWord(1);//   
			bs.GetWord(1);//   
			bs.GetWord(1);//   
			bs.GetWord(1);//    
			bs.GetWord(44);//   
			params.level = bs.GetWord(8);// general_level_idc  
			uint8 sub_layer_profile_present_flag[6] = { 0 };
			uint8 sub_layer_level_present_flag[6] = { 0 };
			for (int i = 0; i < sps_max_sub_layers_minus1; i++) {
				sub_layer_profile_present_flag[i] = bs.GetWord(1);
				sub_layer_level_present_flag[i] = bs.GetWord(1);
			}
			if (sps_max_sub_layers_minus1 > 0)
			{
				for (int i = sps_max_sub_layers_minus1; i < 8; i++) {
					uint8 reserved_zero_2bits = bs.GetWord(2);
				}
			}
			for (int i = 0; i < sps_max_sub_layers_minus1; i++)
			{
				if (sub_layer_profile_present_flag[i]) {
					bs.GetWord(2);
					bs.GetWord(1);
					bs.GetWord(5);
					bs.GetWord(32);
					bs.GetWord(1);
					bs.GetWord(1);
					bs.GetWord(1);
					bs.GetWord(1);
					bs.GetWord(44);
				}
				if (sub_layer_level_present_flag[i]) {
					bs.GetWord(8);// sub_layer_level_idc[i]  
				}
			}
		}
		uint32_t sps_seq_parameter_set_id = bs.GetUE();
		if (sps_seq_parameter_set_id > 15) {
			return false;
		}
		uint32_t chroma_format_idc = bs.GetUE();
		if (sps_seq_parameter_set_id > 3) {
			return false;
		}
		if (chroma_format_idc == 3) {
			bs.GetWord(1);//    
		}
		params.width = bs.GetUE(); // pic_width_in_luma_samples  
		params.height = bs.GetUE(); // pic_height_in_luma_samples  
		if (bs.GetWord(1)) {
			bs.GetUE();
			bs.GetUE();
			bs.GetUE();
			bs.GetUE();
		}
		uint32_t bit_depth_luma_minus8 = bs.GetUE();
		uint32_t bit_depth_chroma_minus8 = bs.GetUE();
		if (bit_depth_luma_minus8 != bit_depth_chroma_minus8) {
			return false;
		}

		//修正高度  
		if (params.height == 1088)
			params.height = 1080;

		return true;
	}

3 获取H264宽、高
	bool  CNetRevcBase::GetWidthHeightFromSPS(unsigned char* szSPS, int nSPSLength, int& nWidth, int& nHeight)
	{
		s.p = (uint8_t *)szSPS;//在这里,_Resolution是经过BASE64解码后的SPS数据的指针
		s.p_start = (uint8_t *)szSPS;
		s.p_end = (uint8_t *)(szSPS + nSPSLength);//size是SPS数据的长度
		s.i_left = 8;//这个是固定的.是指SPS的对齐宽度

		if (_spsreader.Do_Read_SPS(&s, &nWidth, &nHeight) != 0)
		{
			nWidth = 0;
			nHeight = 0;
			return false ;
		}

		//修复计算出来的高
		if (nWidth == 1920 && nHeight == 1088)
		{
			nHeight = 1080;
		}
		else if (nWidth == 1920 && nHeight == 544)
		{//修正分析错误的分辨率 85038坪葵路金葵中路路口
			nHeight = 1080;
		}
		else if (nWidth == 4096 && nHeight == 1808)
		{
			nHeight = 1800;
		}
		return true ;
	}

4、增加mp4切片文件NetServerHTTP_MP4.cpp \ NetServerHTTP_MP4.h 

ABLMediaServer-2021-12-17【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、由于有些http客户端以post方式发过来的http头有些字段数据超长，超过2000字节，造成内存拷贝越界 崩溃。需要扩大 szValue 大小 

	#define  MaxSipBodyContentLength   64*1024 //最大的body数据长度

	struct SipFieldStruct
	{
		char szKey[256];
		char szValue[10240];
		SipFieldStruct()
		{
			memset(szKey, 0x00, sizeof(szKey));
			memset(szValue, 0x00, sizeof(szValue));
		}
	};


ABLMediaServer-2021-12-16【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、把输出列表中的sourceType 修改为 networkType 

	if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
	{
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

		strcat(szMediaSourceInfo, szTemp2);

		nMediaCount++;
	}
	
2、	修改http post 方式，上一个版本 2021-12-14 修改出的一个BUG ，删除掉 

	if (httpParse.GetFieldValue("Content-Length", szContentLength))
	{//POST 
		nContent_Length = atoi(szContentLength);

		/*   ---删除掉 
		//如果出现post ，就不能有 Content-Length 
		if (memcmp(netDataCache, "POST ", 5) == 0)
		{
			WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误1 nClient = %llu ", this, nClient);
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Http Protocol Error \",\"key\":%d}", IndexApiCode_HttpProtocolError, 0);
			ResponseSuccess(szResponseBody);
		}*/

		if (netDataCacheLength - (nHttpHeadEndPos + 4) < nContent_Length || nContent_Length <= 0 )
 			return -2;//数据尚未接收完整 
 		
ABLMediaServer-2021-12-14【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、国标接收端口回复前，修改真实的端口，不管是用户指定的，还是系统自动分配的
		//自动产生端口
		if (atoi(m_openRtpServerStruct.port) == 0)
			sprintf(m_openRtpServerStruct.port, "%d", ABL_nGB28181Port); //记下真实端口 

		//回复Http 请求
		if (nRet == 0)
 		  sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"port\":\"%s\",\"key\":%d}", m_openRtpServerStruct.port, nClient);
		else 
		  sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"bind port %s failed .\",\"port\":\"%s\",\"key\":%d}", IndexApiCode_BindPortError, m_openRtpServerStruct.port, m_openRtpServerStruct.port, 0);
		  
 		ResponseHttp(nClient_http, szResponseBody, false);、
		
2、统一称作为网络类型 networkType 
	if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
	{
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"networkType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

		strcat(szMediaSourceInfo, szTemp2);

		nMediaCount++;
	}

3、各种连接失败是提示IP、端口，这样方便调用者根据错误信息进行解决问题。

	CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
	if (pClient)
	{
		WriteLog(Log_Debug, "clihandle = %llu ,URL: %s ,连接失败 result: %d ", clihandle,pClient->m_httpStruct.szSrchttpPullUrl,result);
		if (pClient->netBaseNetType == NetBaseNetType_httpClientRecv || pClient->netBaseNetType ==  NetBaseNetType_RtmpClientRecv || pClient->netBaseNetType == NetBaseNetType_HttpFlvClientRecv || 
			pClient->netBaseNetType ==  NetBaseNetType_HttpHLSClientRecv || pClient->netBaseNetType ==  NetBaseNetType_httpClientPush || pClient->netBaseNetType == NetBaseNetType_RtmpClientPush ||
			pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect )
		{//http 代理拉流失败
			sprintf(pClient->szResponseBody, "{\"code\":%d,\"memo\":\"Network Connecting [%s : %s] Failed .\",\"key\":%d}", IndexApiCode_ConnectFail,pClient->m_httpStruct.szIP,pClient->m_httpStruct.szPort,0);
			pClient->ResponseHttp(pClient->nClient_http, pClient->szResponseBody, false);
			pDisconnectBaseNetFifo.push((unsigned char*)&pClient->hParent, sizeof(pClient->hParent));
		}
	}

4、记录连接国标的IP，端口 ,用于错误提示 
	strcpy(pClient->m_httpStruct.szIP, m_startSendRtpStruct.dst_url);
	strcpy(pClient->m_httpStruct.szPort, m_startSendRtpStruct.dst_port);

5、国标UDP、TCP推流时，如果30秒内没有视频加入推流，则主动断开推流对象 ，回收资源 	
	((*iterator1).second)->netBaseNetType ==  NetBaseNetType_NetGB28181SendRtpUDP || //国标UDP推流
	((*iterator1).second)->netBaseNetType ==  NetBaseNetType_NetGB28181SendRtpTCP_Connect //国标TCP推流 
	
6、http协议检测，如果出现post ，就不能有 Content-Length 
	if (memcmp(netDataCache, "POST ", 5) == 0)
	{
		WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误1 nClient = %llu ", this, nClient);
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Http Protocol Error \",\"key\":%d}", IndexApiCode_HttpProtocolError, 0);
		ResponseSuccess(szResponseBody);
	}
	
7、增加一个函数获取媒体源 ，没有锁的，在确保媒体源没有删除的情况下调用 
	CMediaStreamSource_ptr GetMediaStreamSourceNoLock(char* szURL)
	{
		CMediaStreamSource_ptrMap::iterator iterator1;
		CMediaStreamSource_ptr   pClient = NULL;

		iterator1 = xh_ABLMediaStreamSourceMap.find(szURL);
		if (iterator1 != xh_ABLMediaStreamSourceMap.end())
		{
			pClient = (*iterator1).second;
			return pClient;
		}
		else
		{
			return NULL;
		}
	}

8、在获取可以的媒体源信息时，需要调用无锁的 GetMediaStreamSourceNoLock ，否则会容易出现卡死 
 	int GetAllMediaStreamSource(char* szMediaSourceInfo,char* szMediaType)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		CNetRevcBase_ptr   pClient = NULL;
		int   nMediaCount = 0;
		char  szTemp2[4096] = { 0 };
		char  szShareMediaURL[256];

		if (xh_ABLMediaStreamSourceMap.size() > 0)
		{
			strcpy(szMediaSourceInfo, "{\"code\":0,\"memo\":\"success\",\"mediaList\":[");
		}

		for (iterator1 = xh_ABLNetRevcBaseMap.begin();iterator1 != xh_ABLNetRevcBaseMap.end();++iterator1)
		{
			pClient = (*iterator1).second;

			if (pClient->netBaseNetType == NetBaseNetType_addStreamProxyControl || pClient->netBaseNetType == NetBaseNetType_httpServerRecvPush || pClient->netBaseNetType == NetBaseNetType_RtmpServerRecvPush ||
				pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy )
			{//代理拉流（http,rtmp,flv,hls ）,http推流，rtmp推流，gb28181，webrtc 
				sprintf(szShareMediaURL, "/%s/%s", pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
				boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSourceNoLock(szShareMediaURL);

				if (tmpMediaSource != NULL )
				{
					if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
					{
						sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"sourceType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
							tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

						strcat(szMediaSourceInfo, szTemp2);

						nMediaCount++;
					}
				}
			}
		}
		
ABLMediaServer-2021-12-12【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、收到的http请求post 过来的json ，先进行去掉空格处理
 
	bool CNetServerHTTP::SplitterJsonParam(char* szJsonParam)
	{
		int    nKeyCount = 0;
		if (szJsonParam == NULL || strlen(szJsonParam) == 0)
			return false;

		char  szValue[512] = { 0 };
		rapidjson::Type nType;

		DeleteAllHttpKeyValue();

        //去掉空格 
		string strJson = szJsonParam;
		boost::trim(strJson);
		strcpy(szJsonParam, strJson.c_str());

2、当以post 方式到底的json字符串，进行切割，如果返回flase，则进行提示json参数错误 。
	else if (strcmp(szModem, "POST") == 0)
	{
		if (!SplitterJsonParam(requestParam))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"json error\",\"key\":%d}", IndexApiCode_HttpJsonError,  0);
			ResponseSuccess(szResponseBody); 
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http json %s 错误 ，httpURL = %s", this, nClient, requestParam, httpURL);
			return false;
		}
	}

ABLMediaServer-2021-12-09【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、在网络基类析构函数中，增加消除拷贝移除，发送移除
	CNetRevcBase::~CNetRevcBase()
	{
		pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
		pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nClient, sizeof(nClient));
	}

2、在所有http类中的析构函数中，把 bRunFlag = false 和  std::lock_guard<std::mutex> lock(netDataLock) 锁的位置 调换，否则容易出现卡死现象 
	CNetClientRecvhttp::~CNetClientRecvhttp()
	{
		bRunFlag = false;
		WriteLog(Log_Debug, "CNetClientRecvhttp 等待任务退出 nTime = %llu, nClient = %llu ",GetTickCount64(), nClient);
		std::lock_guard<std::mutex> lock(netDataLock);
		
		pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nClient,sizeof(nClient)); //从媒体拷贝线程、媒体发送线程移除掉Client  

	总共类有3个 CNethttpServer 、CNetClientRecvhttp 、CNetClientSendhttp 的析构函数的变量位置 都要调整

		
ABLMediaServer-2021-12-08【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1 在转义字符中 ，把原来 + 号更换为 空格的代码，修改为原字符输出即可，否则华为的url有许多+号，造成华为url破坏 ，连接失败 

	// 没有被url编码的数据  
	// '+'特殊处理.它相当于一个空格  
	if (*p != '+')
	{
		url[i] = *p;
	}
	else
	{
		url[i] = *p;//+ 号还是不变输出
	}

ABLMediaServer-2021-12-07【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、增加 单独处理各种代理拉流时，连接超时回复http请求，否则http请求http拉流，由于服务器的原因可能会出现很久
   没有码流到达，造成请求者等待非常久的时间。
		
	if (((*iterator1).second)->netBaseNetType == NetBaseNetType_httpClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpFlvClientRecv || ((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSClientRecv)
	{
		if (!((*iterator1).second)->bResponseHttpFlag && GetTickCount64() - ((*iterator1).second)->nCreateDateTime >= 5000 )
		{//连接超时5秒，尚未回复http请求，一律回复连接超时
			sprintf(((*iterator1).second)->szResponseBody, "{\"code\":%d,\"memo\":\"Network Connnect Timeout .\",\"key\":%d}", IndexApiCode_ConnectTimeout, 0);
			((*iterator1).second)->ResponseHttp(((*iterator1).second)->nClient_http, ((*iterator1).second)->szResponseBody, false);
		}
	}

2、网络短线检测增加 接收http推流 上来的类型检测，遗漏了这个类型 检测  	
	//检测网络断线 ，发送M3u8请求 
	int  CheckNetRevcBaseClientDisconnect()
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		int                           nDiconnectCount = 0;

		ABL_nPrintCheckNetRevcBaseClientDisconnect ++;
		if(ABL_nPrintCheckNetRevcBaseClientDisconnect % 20 == 0)//1分钟打印一次
		  WriteLog(Log_Debug, "CheckNetRevcBaseClientDisconnect() 当前连接总数 nSize = %llu ", xh_ABLNetRevcBaseMap.size());

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); ++iterator1)
		{
			if (((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSServerSendPush || //HLS　发送
				((*iterator1).second)->netBaseNetType == NetBaseNetType_httpServerRecvPush ||   //接收http推流上来
				
				
	
ABLMediaServer-2021-12-06【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、国标启动接入增加参数检测，不能缺少一些必要参数 
	//创建GB28181,接收码流
	bool  CNetServerHTTP::index_api_openRtpServer()
	{

		if (strlen(m_openRtpServerStruct.secret) == 0 || strlen(m_openRtpServerStruct.app) == 0 || strlen(m_openRtpServerStruct.stream_id) == 0 || strlen(m_openRtpServerStruct.port) == 0 ||
			strlen(m_openRtpServerStruct.enable_tcp) == 0 || strlen(m_openRtpServerStruct.payload) == 0 )
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[secret , app , stream_id , port , enable_tcp , payload ] parameter need .\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

2、	启动国标发流函数增加参数检测 
	//创建GB28181,发送rtp
	bool  CNetServerHTTP::index_api_startSendRtp()
	{

		if (strlen(m_startSendRtpStruct.secret) == 0 || strlen(m_startSendRtpStruct.app) == 0 || strlen(m_startSendRtpStruct.stream) == 0 || strlen(m_startSendRtpStruct.ssrc) == 0 ||
			strlen(m_startSendRtpStruct.src_port) == 0 || strlen(m_startSendRtpStruct.dst_url) == 0 || strlen(m_startSendRtpStruct.dst_port) == 0 || strlen(m_startSendRtpStruct.is_udp) == 0 ||
			strlen(m_startSendRtpStruct.payload) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"[secret , app , stream , ssrc , src_port , dst_url ,dst_port, is_udp, payload ] parameter need .\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		
3、http代理拉流报错时，及时返回http响应信息 

	else
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"%s\",\"key\":%d}", IndexApiCode_ConnectFail, pRecvData, 0);
		ResponseHttp(nClient_http, szResponseBody, false);

		bIsInvalidConnectFlag = true; //确认为非法连接 
		WriteLog(Log_Debug, "非法的http 命令，立即执行删除 nClient = %llu, \r\n%s ",nClient, pRecvData);
		DeleteNetRevcBaseClient(nClient);
	}
		
4、更新底层网络库，把设置端口复位代码屏蔽掉 

5、增加close_streams 接口函数说明参数 
			
       根据条件组合，删除任意一个或一组或者全部媒体输入列表
       URL: index/api/close_streams
	   
	   功能
	      删除任意一个或一组或者全部媒体输入列表 
		    
			secret           服务器密码            比如 035c73f7-bb6b-4889-a715-d9eb2d1925cc                           【必填参数】
			vhost                                  比如 _defaultVhost_                                                 【可选参数】
			app              应用名                比如 gb28181 、rtp 等等                                             【可选参数】
			stream           媒体流名              比如 Camera_00001、dsafdsafassdafadsfas、等等                       【可选参数】
			force            是否强制关闭          1 强制关闭，不管是否有人在观看、0 非强制关闭，当有人观看时不关闭。  【必填参数】
			
		 http GET 方式 
            示例1： http://190.168.24.112:8188/index/api/close_streams?secret=035c73f7-bb6b-4889-a715-d9eb2d1925cc&app=live&force=1
		           表示强行关闭 app 等于 live 的码流接入 
            示例2： http://190.168.24.112:8188/index/api/close_streams?secret=035c73f7-bb6b-4889-a715-d9eb2d1925cc&app=live&stream=Camera_00001&force=1
		           表示强行关闭 app 等于 live,stream 等于 Camera_00001  的码流接入 
            示例3： http://190.168.24.112:8188/index/api/close_streams?secret=035c73f7-bb6b-4889-a715-d9eb2d1925cc&force=1
		           表示强行关闭 所有码流 接入 
				   
 		 http pos 方式 
            示例1： http URL:
			          http://190.168.24.112:8188/index/api/close_streams
			        body:
			          {"secret":"035c73f7-bb6b-4889-a715-d9eb2d1925cc","app":"live","force":1}
					
		             【表示强行关闭 app 等于 live 的码流接入】
					 
            示例2： http URL:
			          http://190.168.24.112:8188/index/api/close_streams
			        body:
			          {"secret":"035c73f7-bb6b-4889-a715-d9eb2d1925cc","app":"live","stream":"Camera_00001","force":1}
					  
		           【表示强行关闭 app 等于 live,stream 等于 Camera_00001  的码流接入 】
				   
            示例3： http URL:
			          http://190.168.24.112:8188/index/api/close_streams
			        body:
			          {"secret":"035c73f7-bb6b-4889-a715-d9eb2d1925cc","force":1}
			
		           【 表示强行关闭 所有码流 接入 】
 
6、优化 index_api_startSendRtp() 的tcp 方式，只有 nRet = XHNetSDK_Connect 连接成功才创建rtp推流对象 
	//创建GB28181,发送rtp
	bool  CNetServerHTTP::index_api_startSendRtp()
	{
		char szShareMediaURL[256] = { 0 };
		unsigned short nReturnPort ;
		int  nRet = 0 ;
		memset((char*)&m_startSendRtpStruct, 0x00, sizeof(m_startSendRtpStruct));

			else
			{
				if (atoi(m_startSendRtpStruct.src_port) == 0)
					nRet = XHNetSDK_Connect((int8_t*)m_startSendRtpStruct.dst_url, atoi(m_startSendRtpStruct.dst_port), (int8_t*)(NULL), ABL_nGB28181Port, (uint64_t*)&nMediaClient, onread, onclose, onconnect, 0, 5000, 1);
				else
					nRet = XHNetSDK_Connect((int8_t*)m_startSendRtpStruct.dst_url, atoi(m_startSendRtpStruct.dst_port), (int8_t*)(NULL), atoi(m_startSendRtpStruct.src_port), (uint64_t*)&nMediaClient, onread, onclose, onconnect, 0, 5000, 1);

				if (nRet == 0)
					pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181SendRtpTCP_Connect, 0, nMediaClient, "", 1, szShareMediaURL);
			}

			nReturnPort = ABL_nGB28181Port;
			if (atoi(m_startSendRtpStruct.src_port) > 0)
				nReturnPort = atoi(m_startSendRtpStruct.src_port);

			if (nRet != 0)
			{//网络资源启动失败，需要删除 netGB28181RtpClient 对象
				sprintf(szResponseBody, "{\"code\":%d,\"port\":%d,\"memo\":\"bind port %d Failed .\",\"key\":%d}", IndexApiCode_BindPortError, nReturnPort, nReturnPort, 0);
				ResponseSuccess(szResponseBody);
			 }

			if (pClient != NULL)
			{
				memcpy((char*)&pClient->m_startSendRtpStruct, (char*)&m_startSendRtpStruct, sizeof(m_startSendRtpStruct));

				pClient->nClient_http = nClient; //赋值给http请求连接 
				pClient->nReturnPort = nReturnPort;//国标本地发送端口

				if(nRet == 0)
				 sprintf(szResponseBody, "{\"code\":0,\"port\":%d,\"memo\":\"success\",\"key\":%d}", nReturnPort, pClient->nClient);
				else 
				 sprintf(szResponseBody, "{\"code\":%d,\"port\":%d,\"memo\":\"bind port %d Failed .\",\"key\":%d}", IndexApiCode_BindPortError, nReturnPort, nReturnPort, 0);
				
				ResponseSuccess(szResponseBody);
			}
	 
		
ABLMediaServer-2021-12-05【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、tcp方式国标推流请求成功时的通知，移动到 SendFirstRequst() 函数里面 ;
	else if (result == 1)
	{//如果链接成功，发送第一个请求
		CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
		if (pClient)
		{
			WriteLog(Log_Debug, "clihandle = %llu ,URL: %s , 连接成功 result: %d ", clihandle, pClient->m_httpStruct.szSrchttpPullUrl, result);

			//国标tcp方式推流
			if (pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect)
			{//回复http请求，连接成功，
				sprintf(pClient->szResponseBody, "{\"code\":0,\"port\":%d,\"memo\":\"success\",\"key\":%d}", pClient->nReturnPort, pClient->nClient);
				pClient->ResponseHttp(pClient->nClient_http, pClient->szResponseBody, false);
			}

 			pClient->SendFirstRequst();
		}
	}

    //移动到 SendFirstRequst(); 发送第一个请求
	
	int CNetGB28181RtpClient::SendFirstRequst()
	{//当 gb28181 为tcp时，触发该函数 

		if (netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect)
		{//回复http请求，连接成功，
			sprintf(szResponseBody, "{\"code\":0,\"port\":%d,\"memo\":\"success\",\"key\":%d}", nReturnPort, nClient);
			ResponseHttp(nClient_http, szResponseBody, false);
		}

		boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(m_szShareMediaURL);
		if (pMediaSource != NULL)
		{
			memcpy((char*)&mediaCodecInfo, (char*)&pMediaSource->m_mediaCodecInfo, sizeof(MediaCodecInfo));
			pMediaSource->AddClientToMap(nClient);
		}

		//把nClient 加入Video ,audio 发送线程
		pMediaSendThreadPool->AddClientToThreadPool(nClient);
		return 0;
	}


ABLMediaServer-2021-12-04【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、优化gb28181的推流请求函数，UDP\TCP 网络都要判断网络是否正常才回复http请求 
	boost::shared_ptr<CNetRevcBase> pClient = NULL;
	if (is_udp == 1)
	{
		if (atoi(m_startSendRtpStruct.src_port) == 0)
		{
			do
			{
			   nRet = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);
			   if (nRet != 0)
				  ABL_nGB28181Port ++;
			} while (nRet != 0);
		}
		else
		{
			nRet = XHNetSDK_BuildUdp(NULL, atoi(m_startSendRtpStruct.src_port), NULL, &nMediaClient, onread, 1);
		}
		pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181SendRtpUDP, 0, nMediaClient, "", 0, szShareMediaURL);
	}
	else
	{
		if (atoi(m_startSendRtpStruct.src_port) == 0)
		  XHNetSDK_Connect((int8_t*)m_startSendRtpStruct.dst_url, atoi(m_startSendRtpStruct.dst_port), (int8_t*)(NULL), ABL_nGB28181Port, (uint64_t*)&nMediaClient, onread, onclose, onconnect, 0, 5000, 1);
		else
		  XHNetSDK_Connect((int8_t*)m_startSendRtpStruct.dst_url, atoi(m_startSendRtpStruct.dst_port), (int8_t*)(NULL), atoi(m_startSendRtpStruct.src_port), (uint64_t*)&nMediaClient, onread, onclose, onconnect, 0, 5000, 1);
		pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181SendRtpTCP_Connect, 0, nMediaClient, "", 1, szShareMediaURL);
	}

	if (pClient != NULL)
	{
		memcpy((char*)&pClient->m_startSendRtpStruct, (char*)&m_startSendRtpStruct, sizeof(m_startSendRtpStruct));

		nReturnPort = ABL_nGB28181Port;
		if (atoi(m_startSendRtpStruct.src_port) > 0)
			nReturnPort = atoi(m_startSendRtpStruct.src_port);

		pClient->nClient_http = nClient; //赋值给http请求连接 
		pClient->nReturnPort = nReturnPort;//国标本地发送端口
		if (is_udp == 1)
		{//udp直接回复
		  if(nRet == 0)
		   sprintf(szResponseBody, "{\"code\":0,\"port\":%d,\"memo\":\"success\",\"key\":%d}", nReturnPort, pClient->nClient);
		  else 
		   sprintf(szResponseBody, "{\"code\":%d,\"port\":%d,\"memo\":\"bind port %d Failed .\",\"key\":%d}", IndexApi                        Code_BindPortError, nReturnPort, nReturnPort, 0);
		
		  ResponseSuccess(szResponseBody);
		}
		else
		{//tcp 需要判断是否链接成功

		}
	}
	
	TCP连接成功后再回复http请求//国标tcp方式推流
	
	if (pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect)
	{//回复http请求，连接成功，
		sprintf(pClient->szResponseBody, "{\"code\":0,\"port\":%d,\"memo\":\"success\",\"key\":%d}", pClient->nReturnPort, pClient->nClient);
		pClient->ResponseHttp(pClient->nClient_http, pClient->szResponseBody, false);
	}

2、优化国标代理收流 SendFirstRequst() 函数 
	//发送第一个请求
	int CNetGB28181Proxy::SendFirstRequst()
	{

		if (nNetGB28181ProxyType == NetGB28181ProxyType_RecvStream)
		{//国标收流
			int nTcp_Switch = atoi(m_openRtpServerStruct.tcp_switch);
			int nRet = 2;
			char szTemp[256] = { 0 };
			char szTemp2[128] = { 0 };
			sprintf(szTemp, "/%s/%s", m_openRtpServerStruct.app, m_openRtpServerStruct.stream);

			//给代理拉流结构拷贝app,stream ,查找媒体源流输入时需要
			strcpy(m_addStreamProxyStruct.app, m_openRtpServerStruct.app);
			strcpy(m_addStreamProxyStruct.stream, m_openRtpServerStruct.stream);
			sprintf(m_addStreamProxyStruct.url, "rtp://127.0.0.1:%s/%s/%s", m_openRtpServerStruct.port, m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);

			if (nTcp_Switch == 0)
			{//udp方式
				   if (atoi(m_openRtpServerStruct.port) == 0)
				   {
					  do
					  {
					   nRet = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);
						if(nRet != 0)
						 ABL_nGB28181Port += 1;
					  } while (nRet != 0);
				   }
				   else
				   {
					   nRet = XHNetSDK_BuildUdp(NULL, atoi(m_openRtpServerStruct.port), NULL, &nMediaClient, onread, 1);
				   }

				 if(nRet == 0)
				 {
					 boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerUDP, 0, nMediaClient, "", ABL_nGB28181Port, szTemp);
					 if (pClient != NULL)
					 {
						pClient->hParent     = nClient; //记录国标代理的句柄号，当国标发流、收流断线时，能同时销毁代理句柄资源 
						pClient->m_gbPayload = atoi(m_openRtpServerStruct.payload);//更新为正确的paylad
					 }
				 }
			}
			else if (nTcp_Switch == 1)
			{//如果是TCP
				if (atoi(m_openRtpServerStruct.port) == 0)
				{
					do
					{
						nRet = XHNetSDK_Listen((int8_t*)("0.0.0.0"), ABL_nGB28181Port, &nMediaClient, onaccept, onread, onclose, true);
						if (nRet != 0)
							ABL_nGB28181Port += 1;
					}while (nRet != 0);
				}
				else
				{
					nRet = XHNetSDK_Listen((int8_t*)("0.0.0.0"), atoi(m_openRtpServerStruct.port), &nMediaClient, onaccept, onread, onclose, true);
				}

				if (nRet == 0)
				{
					NetServerHandleParam* param = new NetServerHandleParam;
					param->nNetServerHandleType = NetServerHandleType_GB28181RecvStream;
					param->hParent = nClient;
					sprintf(param->szMediaSource, "/%s/%s", m_openRtpServerStruct.app, m_openRtpServerStruct.stream);

					AddNetServerHandle(nMediaClient,param);
				}
			}

			//回复Http 请求
			if (nRet == 0)
			  sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"port\":\"%s\",\"key\":%d}", m_openRtpServerStruct.port, nClient);
			else 
			  sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"bind port %s failed .\",\"port\":\"%s\",\"key\":%d}", IndexApiCode_BindPortError, m_openRtpServerStruct.port, m_openRtpServerStruct.port, 0);
			ResponseHttp(nClient_http, szResponseBody, false);

			//自动产生端口
			if (atoi(m_openRtpServerStruct.port) == 0)
			   sprintf(m_openRtpServerStruct.port, "%d", ABL_nGB28181Port); //记下真实端口 

			WriteLog(Log_Debug, "CNetGB28181Proxy = %X nClient = %llu ,国标使用的本地端口 port = %s", this, nClient, m_openRtpServerStruct.port);

			ABL_nGB28181Port ++;//需要优化端口 
			if (ABL_nGB28181Port >= 65520)
				ABL_nGB28181Port = 9090;  //端口重新反转

			//绑定端口失败，需要删除
			if (nRet != 0)
				return -1;
			else
				return 0;
		}
		else if (nNetGB28181ProxyType == NetGB28181ProxyType_PushStream)
		{

		}

		 return 0;
	}

3、优化 http读取函数，增加一个条件 data_Length >= 4 ，否则会出现数组访问越界 
	bool   CNetClientRecvhttp::ReadhttpEnd()
	{
		unsigned int nReadLength = 1;
		unsigned int nRet;
		bool     bRet = false;
		bExitProcessFlagArray[1] = false;
		while (!bIsInvalidConnectFlag && bRunFlag)
		{
			nReadLength = 1;
			nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
			if (nRet == 0 && nReadLength == 1)
			{
				data_Length += 1;
				if (data_Length >= 4 &&  data_[data_Length - 4] == '\r' && data_[data_Length - 3] == '\n' && data_[data_Length - 2] == '\r' && data_[data_Length - 1] == '\n')
				{
					bRet = true;
					break;
				}
			}
			else
			{
				WriteLog(Log_Debug, "ReadhttpEnd() ,尚未读取到数据 ！CABLhttpClient =%X ,dwClient=%llu ", this, nClient);
				break;
			}

			if (data_Length >= httpServerRecvDataLength)
			{
				WriteLog(Log_Debug, "ReadhttpEnd() ,找不到 http 结束符号 ！CABLhttpClient =%X ,dwClient = %llu ", this, nClient);
				break;
			}
		}
		bExitProcessFlagArray[1] = true;
		return bRet;
	}
	
ABLMediaServer-2021-12-03【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、启动网络参数可以从配置读取，数量由由用户指定
	ABL_MediaServerPort.nIOContentNumber = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "IOContentNumber", "16"));
	ABL_MediaServerPort.nThreadCountOfIOContent = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "ThreadCountOfIOContent", "16"));
	
	int nRet = XHNetSDK_Init(ABL_MediaServerPort.nIOContentNumber, ABL_MediaServerPort.nThreadCountOfIOContent);

2、限制写入日志文件buffer的大小 

	if (strlen(ABL_writeBuffer) < 4096 )
	   myLogFile.WriteAVFile(ABL_writeBuffer, strlen(ABL_writeBuffer), true);

3、在媒体源增加 app, stream ,方便查找，提供共 close_streams 函数使用
	//获取app ,stream ;
	memset(app, 0x00, sizeof(app));
	memset(stream, 0x00, sizeof(szTSFileSubPath));
	string strURL2 = szURL;
	int    nPos2 = 0;
	nPos2 = strURL2.rfind("/", strlen(szURL));
	if (nPos2 > 0)
	{
		memcpy(app, szURL + 1, nPos2 - 1);
		memcpy(stream, szURL + nPos2 + 1, strlen(szURL) - nPos2 - 1);
	}
		
4、 根据条件删除媒体源
	int  CloseMediaStreamSource(closeStreamsStruct closeStruct)
	{
		std::lock_guard<std::mutex> lock(ABL_CMediaStreamSourceMapLock);
		CMediaStreamSource_ptrMap::iterator iterator1;
		CMediaStreamSource_ptr   pClient = NULL;
		int  nDeleteCount =  0 ;

		for (iterator1 = xh_ABLMediaStreamSourceMap.begin(); iterator1 != xh_ABLMediaStreamSourceMap.end(); ++iterator1)
		{
			pClient = (*iterator1).second;
	 
			if (closeStruct.force == 1 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) > 0)
			{//强制关闭
				if (strcmp(pClient->app, closeStruct.app) == 0 && strcmp(pClient->stream, closeStruct.stream) == 0)
				{
					nDeleteCount ++;
					WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ", pClient->m_szURL, pClient->app, pClient->stream);
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
				}
			}
			else if (closeStruct.force == 1 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) == 0)
			{//强制关闭
				if (strcmp(pClient->app, closeStruct.app) == 0 )
				{
					nDeleteCount++;
					WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ", pClient->m_szURL, pClient->app, pClient->stream);
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
				}
			}
			else if (closeStruct.force == 1 && strlen(closeStruct.app) == 0 && strlen(closeStruct.stream) == 0)
			{//强制关闭
					nDeleteCount++;
					WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ", pClient->m_szURL, pClient->app, pClient->stream);
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
			}
			else if (closeStruct.force == 0 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) > 0)
			{//不强制关闭
				if (pClient->mediaSendMap.size() == 0)
				{
					nDeleteCount ++;
					WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ", pClient->m_szURL, pClient->app, pClient->stream);
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
				}
			}
			else if (closeStruct.force == 0 && strlen(closeStruct.app) > 0 && strlen(closeStruct.stream) == 0)
			{//不强制关闭
				if (pClient->mediaSendMap.size() == 0)
				{
					nDeleteCount++;
					WriteLog(Log_Debug, "CloseMediaStreamSource = %s,准备删除媒体源 app = %s ,stream = %s ", pClient->m_szURL, pClient->app, pClient->stream);
					pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
				}
			}
		}
		return nDeleteCount ;
	}

4、代理http\rtmp\flv 拉流 网络连接失败回复http 	
	if (pClient->netBaseNetType == NetBaseNetType_httpClientRecv || pClient->netBaseNetType ==  NetBaseNetType_RtmpClientRecv || pClient->netBaseNetType == NetBaseNetType_HttpFlvClientRecv || 
		pClient->netBaseNetType ==  NetBaseNetType_HttpHLSClientRecv || pClient->netBaseNetType ==  NetBaseNetType_httpClientPush || pClient->netBaseNetType == NetBaseNetType_RtmpClientPush )
	{//http 代理拉流失败
		sprintf(pClient->szResponseBody, "{\"code\":%d,\"memo\":\"%s\",\"key\":%d}", IndexApiCode_ConnectFail, "Network Connect Failed .", 0);
		pClient->ResponseHttp(pClient->nClient_http, pClient->szResponseBody, false);
		pDisconnectBaseNetFifo.push((unsigned char*)&pClient->hParent, sizeof(pClient->hParent));
	}

5、http、rtmp代理推流，成功、失败后再返回给http请求 

	
ABLMediaServer-2021-11-30【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、修正一个错误
	memset(szMediaSourceInfoBuffer, 0x00, MaxMediaSourceInfoLength);
	
2 、支持拉取ZLMediaKit流媒体服务器输出的http码流，该服务器在Setup命令开始后请求的http url中不能再包含 ? 后面的字符串，否则该服务器立即断开连接
  
   1)、struct httpURLParseStruct
   {
 	  char szhttpURLTrim[512];//去掉？后面的字符串得到的http url 
	  

   2）、url 分析中删除掉 ? 后面的字符串。
   
	else
	{
		nPos5 = strhttpURL.find("?", 0);
		if (nPos5 > 0)
			memcpy(m_httpStruct.szhttpURLTrim, szURL, nPos5);
		else
			strcpy(m_httpStruct.szhttpURLTrim, szURL);

		return true;
	}
 
   在Setup 命令开始使用  m_httpStruct.szhttpURLTrim
	if (nSendSetupCount == 1)
	{
		if (m_httpStruct.szSrchttpPullUrl[strlen(m_httpStruct.szSrchttpPullUrl) - 1] == '/')
			sprintf(szResponseBuffer, "SETUP %s%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_httpStruct.szhttpURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_httpStruct.szUser, m_httpStruct.szRealm, m_httpStruct.szNonce, m_httpStruct.szSrchttpPullUrl, szResponse);
		else
			sprintf(szResponseBuffer, "SETUP %s/%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_httpStruct.szhttpURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_httpStruct.szUser, m_httpStruct.szRealm, m_httpStruct.szNonce, m_httpStruct.szSrchttpPullUrl, szResponse);
	}
	else if (nSendSetupCount == 2)
	{
		if (m_httpStruct.szSrchttpPullUrl[strlen(m_httpStruct.szSrchttpPullUrl) - 1] == '/')
			sprintf(szResponseBuffer, "SETUP %s%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\n\r\n", m_httpStruct.szhttpURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_httpStruct.szUser, m_httpStruct.szRealm, m_httpStruct.szNonce, m_httpStruct.szSrchttpPullUrl, szResponse);
		else
			sprintf(szResponseBuffer, "SETUP %s/%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nAuthorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\n\r\n", m_httpStruct.szhttpURLTrim, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson, m_httpStruct.szUser, m_httpStruct.szRealm, m_httpStruct.szNonce, m_httpStruct.szSrchttpPullUrl, szResponse);
	}
ABLMediaServer-2021-11-29【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、CNetClientSendRtmp对象 rtmp推流，在构造函数中需要赋值 NetBaseNetType_RtmpClientPush ，标识身份
	CNetClientSendRtmp::CNetClientSendRtmp(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
	{

		netBaseNetType = NetBaseNetType_RtmpClientPush;
	 
		WriteLog(Log_Debug, "CNetClientSendRtmp =%X 构造 nClient = %llu ",this, nClient);
	}

2、PS打包时，也需要通过帧速度 ，计算时间戳增量 	ttincre ，不能直接赋值为0 ，否则会默认视频帧速度为25帧每秒 。
	if (psMuxHandle == 0)
	{
		memset(&init, 0, sizeof(init));
		init.cb = (void*)GB28181_Send_mux_callback;
		init.userdata = this;
		init.alignmode = e_psmux_am_4octet;
		init.ttmode = 0;
		init.ttincre = (90000 / mediaCodecInfo.nVideoFrameRate); //根据视频帧速度 计算出 视频时间戳增量 
		init.h = &psMuxHandle;
		int32_t ret = ps_mux_start(&init);

		input.handle = psMuxHandle;

		WriteLog(Log_Debug, "CNetGB28181RtpClient = %X ，创建 ps 打包成功  ,nClient = %llu,  nRet = %d , mediaCodecInfo.nVideoFrameRate = %d ", this, nClient, ret ,mediaCodecInfo.nVideoFrameRate );
	}

3、增加删除往外输出的列表功能函数
	else if (strcmp(httpURL, "/index/api/delOutList") == 0)
	{//删除往外发流的列表
		index_api_delRequest();
	}

4、返回的可以媒体列表、往外输出的媒体列表的json中增加视频帧速度字段  videoFrameSpeed，用户可以查询到视频帧速度 
	if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
	{
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"sourceType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"videoFrameSpeed\":%d,\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.nVideoFrameRate, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

		strcat(szMediaSourceInfo, szTemp2);

		nMediaCount++;
	}

	
ABLMediaServer-2021-11-28【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、增加国标输入码流，也包括在媒体列表中，
	if (pClient->netBaseNetType == NetBaseNetType_addStreamProxyControl || pClient->netBaseNetType == NetBaseNetType_httpServerRecvPush || pClient->netBaseNetType == NetBaseNetType_RtmpServerRecvPush ||
		pClient->netBaseNetType == NetRevcBaseClient__NetGB28181Proxy )
	{//代理拉流（http,rtmp,flv,hls ）,http推流，rtmp推流，gb28181，webrtc 
		sprintf(szShareMediaURL, "/%s/%s", pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
		boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);

		if (tmpMediaSource != NULL )
		{
			if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
			{
				sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"sourceType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
					tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

				strcat(szMediaSourceInfo, szTemp2);

				nMediaCount++;
			}
		}
	}
	
	//给代理拉流结构拷贝app,stream ,查找媒体源流输入时需要
	strcpy(m_addStreamProxyStruct.app, m_openRtpServerStruct.app);
	strcpy(m_addStreamProxyStruct.stream, m_openRtpServerStruct.stream);
	sprintf(m_addStreamProxyStruct.url, "rtp://127.0.0.1:%s/%s/%s", m_openRtpServerStruct.port, m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);

2、国标接入时，计算视频帧速度，更新媒体源的视频帧速度，包括TCP，UDP方式 
	if (!pThis->bUpdateVideoFrameSpeedFlag)
	{//更新视频源的帧速度
		int nVideoSpeed = pThis->CalcFlvVideoFrameSpeed(cb->pts, 90000);
		if (nVideoSpeed > 0 && pThis->pMediaSource != NULL)
		{
			pThis->bUpdateVideoFrameSpeedFlag = true;
			WriteLog(Log_Debug, "nClient = %llu , 更新视频源 %s 是帧速度成功，初始速度为%d ,更新后的速度为%d, ", pThis->nClient, pThis->pMediaSource->m_szURL, pThis->pMediaSource->m_mediaCodecInfo.nVideoFrameRate, nVideoSpeed);
			pThis->pMediaSource->UpdateVideoFrameSpeed(nVideoSpeed);
		}
	}
	
3、 获取所有往外发送的列表
	int GetAllOutList(char* szMediaSourceInfo, char* szOutType)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		CNetRevcBase_ptr   pClient = NULL;
		int   nMediaCount = 0;
		char  szTemp2[1024] = { 0 };
	 
		if (xh_ABLMediaStreamSourceMap.size() > 0)
		{
			strcpy(szMediaSourceInfo, "{\"code\":0,\"memo\":\"success\",\"outList\":[");
		}

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); ++iterator1)
		{
			pClient = (*iterator1).second;

			if (pClient->netBaseNetType == NetBaseNetType_RtmpServerSendPush || pClient->netBaseNetType == NetBaseNetType_httpServerSendPush || pClient->netBaseNetType == NetBaseNetType_HttpFLVServerSendPush ||
				pClient->netBaseNetType == NetBaseNetType_HttpHLSServerSendPush || pClient->netBaseNetType == NetBaseNetType_WsFLVServerSendPush || pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpUDP || 
				pClient->netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect || pClient->netBaseNetType == NetBaseNetType_httpClientPush || pClient->netBaseNetType == NetBaseNetType_RtmpClientPush)
			{
				boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(pClient->szMediaSourceURL);

				if (tmpMediaSource != NULL)
				{
					if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
					{
						sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"videoCodec\":\"%s\",\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d,\"networkType\":%d,\"dst_ip\":\"%s\",\"dst_port\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, 
							tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate, pClient->netBaseNetType, pClient->szClientIP,pClient->nClientPort);

						strcat(szMediaSourceInfo, szTemp2);

						nMediaCount++;
					}
				}
			}
		}

		if (nMediaCount > 0)
		{
			szMediaSourceInfo[strlen(szMediaSourceInfo) - 1] = 0x00;
			strcat(szMediaSourceInfo, "]}");
		}

		if (nMediaCount == 0)
		{
			sprintf(szMediaSourceInfo, "{\"code\":%d,\"memo\":\"success\",\"count\":%d}", IndexApiCode_OK, nMediaCount);
		}

		return nMediaCount;
	}


ABLMediaServer-2021-11-26【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、解决http推流、http流输出 的视频时间戳 
	//拷贝媒体源信息
	memcpy((char*)&mediaCodecInfo, (char*)&pMediaSource->m_mediaCodecInfo, sizeof(MediaCodecInfo));

    //视频时间戳增量
	optionVideo.ttincre = 90000 / mediaCodecInfo.nVideoFrameRate; 
	
2、采用hls 的同步方法 	
	void  CNetRevcBase::SyncVideoAudioTimestamp()
	{
		//500毫秒同步一次 
		if (GetTickCount() - nAsyncAudioStamp >= 1000)
		{
			if (flvPS < flvAACDts)
			{
				nVideoStampAdd = 45;
			}
			else if (flvPS > flvAACDts)
			{
				nVideoStampAdd = 35;
			}
			nAsyncAudioStamp = GetTickCount();

			WriteLog(Log_Debug, "CMediaStreamSource = %X flvPS = %d ,flvAACDts = %d ", this, flvPS, flvAACDts);
		}/**/
	}
	
ABLMediaServer-2021-11-25【 ws_flv 网络协议输出成功、优化所有视频、音频的时间戳】
1、在基类增加rtp计算视频帧速度
 	int  CNetRevcBase::CalcVideoFrameSpeed(unsigned char* pRtpData, int nLength)
	{
		if (pRtpData == NULL)
			return -1 ;
		
		int nVideoFrameSpeed = 25 ;
		memcpy((char*)&rtp_header, pRtpData, sizeof(rtp_header));
		if (oldVideoTimestamp == 0)
		{
			oldVideoTimestamp = ntohl(rtp_header.timestamp);
		}
		else
		{
			if (ntohl(rtp_header.timestamp) != oldVideoTimestamp && ntohl(rtp_header.timestamp) > oldVideoTimestamp )
			{
				//WriteLog(Log_Debug, "this = %X ,nVideoFrameSpeed = %llu ", this,(90000 / (ntohl(rtp_header.timestamp) - oldVideoTimestamp)) );

				nVideoFrameSpeed = 90000 / (ntohl(rtp_header.timestamp) - oldVideoTimestamp) ;
				if (nVideoFrameSpeed > 30)
					nVideoFrameSpeed = 30;

				oldVideoTimestamp = ntohl(rtp_header.timestamp);
				nVideoFrameSpeedOrder ++;
				if (nVideoFrameSpeedOrder < 30)
					return -1;
				else
				   return nVideoFrameSpeed;
			}
			return -1;
		}
		return -1;
	}

	
2、要首先把视频编码格式、视频帧速度拷贝给各个分发对象 
	boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient((*it).second);
	if (pClient != NULL)
	{
		//把视频编码名字拷贝给分发对象
		if (strlen(pClient->mediaCodecInfo.szVideoName) == 0)
		{
			strcpy(pClient->mediaCodecInfo.szVideoName, m_mediaCodecInfo.szVideoName);
			pClient->mediaCodecInfo.nVideoFrameRate = m_mediaCodecInfo.nVideoFrameRate;
		}	
		
		//首先加入SPS、PPS 
		if (pClient->bPushSPSPPSFrameFlag == false)
		{
			if (nSPSPPSLength > 0)
			{
				pClient->PushVideo(pSPSPPSBuffer, nSPSPPSLength, szVideoCodec);
				pClient->bPushSPSPPSFrameFlag = true;
			}
		}

		pClient->PushVideo(szVideo, nLength,szVideoCodec);
	}

3、rtp拉流、接收http推流 更新 媒体源的视频帧速度
	 if (!bUpdateVideoFrameSpeedFlag)
	 {//更新视频源的帧速度
		 int nVideoSpeed = CalcVideoFrameSpeed(netDataCache + nNetStart, nRtpLength);
		 if (nVideoSpeed > 0 && pMediaSource != NULL )
		 {
			 bUpdateVideoFrameSpeedFlag = true;
			 WriteLog(Log_Debug, "nClient = %llu , 更新视频源 %s 是帧速度成功，初始速度为%d ,更新后的速度为%d, ",nClient, pMediaSource->m_szURL, pMediaSource->m_mediaCodecInfo.nVideoFrameRate, nVideoSpeed);
			 pMediaSource->UpdateVideoFrameSpeed(nVideoSpeed);
		 }
	 }	

4、修正往ZLMediaKit 服务器推送http码流 
	void  CNetClientSendhttp::SendSetup(WWW_AuthenticateType wwwType)
	{
		nSendSetupCount++;
		if (wwwType == WWW_Authenticate_None)
		{
			if (nSendSetupCount == 1)
			{
				if (m_httpStruct.szSrchttpPullUrl[strlen(m_httpStruct.szSrchttpPullUrl) - 1] == '/')
					sprintf(szResponseBuffer, "SETUP %s%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_httpStruct.szSrchttpPullUrl, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson);
				else
					sprintf(szResponseBuffer, "SETUP %s/%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=0-1\r\n\r\n", m_httpStruct.szSrchttpPullUrl, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson);
			}
			else if (nSendSetupCount == 2)
			{
				if (m_httpStruct.szSrchttpPullUrl[strlen(m_httpStruct.szSrchttpPullUrl) - 1] == '/')
					sprintf(szResponseBuffer, "SETUP %s%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\n\r\n", m_httpStruct.szSrchttpPullUrl, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson);
				else
					sprintf(szResponseBuffer, "SETUP %s/%s http/1.0\r\nCSeq: %d\r\nUser-Agent: %s\r\nTransport: RTP/AVP/TCP;unicast;interleaved=2-3\r\n\r\n", m_httpStruct.szSrchttpPullUrl, szTrackIDArray[nSendSetupCount], CSeq, MediaServerVerson);
			}
		}
	 

ABLMediaServer-2021-11-24【 ws_flv 网络协议输出成功】
1、增加SyncVideoAudioTimestamp() 来同步http-flv ,rtmp ,ws-flv 
	void  CNetRevcBase::SyncVideoAudioTimestamp()
	{
		//500毫秒同步一次 (0) // 
		if ((flvPS - flvAACDts) >= (12 * (1000 / mediaCodecInfo.nVideoFrameRate)))
		{
			if (bUserNewAudioTimeStamp == false)
			{
				WriteLog(Log_Debug, "视频  大于 音频  nClient = %llu , flvPS = %d , flvAACDts = %d , flvPS -  flvAACDts = %d ,nNewAddAudioTimeStamp = %d ", nClient, flvPS, flvAACDts, flvPS - flvAACDts, nNewAddAudioTimeStamp);
				int  nTimeStampCount = (flvPS - flvAACDts) - (5 * (1000 / mediaCodecInfo.nVideoFrameRate));
				nNewAddAudioTimeStamp = nTimeStampCount / 5;
				bUserNewAudioTimeStamp = true;
				nUseNewAddAudioTimeStamp = 5;
			}
		}
		else
		{
			if (bUserNewAudioTimeStamp == false && ((flvAACDts - flvPS) > (5 * (1000 / mediaCodecInfo.nVideoFrameRate))))
			{
				WriteLog(Log_Debug, "音频大于 视频 nClient = %llu , flvPS = %d , flvAACDts = %d , flvPS -  flvAACDts = %d ,nNewAddAudioTimeStamp = %d ", nClient, flvPS, flvAACDts, flvPS - flvAACDts, nNewAddAudioTimeStamp);

				nNewAddAudioTimeStamp = mediaCodecInfo.nBaseAddAudioTimeStamp / 2;
				nUseNewAddAudioTimeStamp = 12;
				bUserNewAudioTimeStamp = true;
			}
		}

		if (GetTickCount64() - nPrintTime >= 2000)
		{
			WriteLog(Log_Debug, "nClient = %llu , flvPS = %d , flvAACDts = %d , flvPS -  flvAACDts = %d ,nNewAddAudioTimeStamp = %d ", nClient, flvPS, flvAACDts, flvPS - flvAACDts, nNewAddAudioTimeStamp);
			nPrintTime = GetTickCount64();
		}
	}
	
2、优化 http-flv ,rtmp ,ws-flv 的音频时间戳计算 	
	void  CNetServerHTTP_FLV::MuxerAudioFlV(char* codeName, unsigned char* pAudio, int nLength)
	{
		//if (dwAudioFirstTime == 0)
		//	dwAudioFirstTime = GetTickCount();
		//flvAACDts = GetTickCount() - dwAudioFirstTime;
		if (ABL_MediaServerPort.nEnableAudio == 0)
			return;

		if (nAsyncAudioStamp == -1)
			nAsyncAudioStamp = GetTickCount();

		if (strcmp(codeName, "AAC") == 0)
		{
			if (flvMuxer)
				flv_muxer_aac(flvMuxer, pAudio, nLength, flvAACDts, flvAACDts);

			if(bUserNewAudioTimeStamp == false)
			  flvAACDts += mediaCodecInfo.nBaseAddAudioTimeStamp ;
			else
			{
				nUseNewAddAudioTimeStamp --;
				flvAACDts += nNewAddAudioTimeStamp;
				if (nUseNewAddAudioTimeStamp <= 0)
				{
					bUserNewAudioTimeStamp = false;
				}
			}
			//AAC 的时间增量计算 ，以海康的16K采样为例，AAC每1024字节编码一次，那么(1024 / 16000 * 2) * 1000 = 32 毫秒 ，但是海康往往2帧发送一次 ，那么两帧递增 32 * 2 = 64 毫秒 ，64 就是海康摄像头 DTS ,PTS 的增量 
			// 以大华的8K采样为例，AAC每1024字节编码一次，那么(1024 / 8000 * 2) * 1000 = 64 毫秒 ，但是大华往往2帧发送一次 ，那么两帧递增 64 * 2 = 128 毫秒 ，128 就是大华摄像头 DTS ,PTS 的增量 
		}
	 
		//同步音视频 
		SyncVideoAudioTimestamp();
	}

ABLMediaServer-2021-11-16【 ws_flv 网络协议输出成功】
1、调整ws-flv 没有音频输出的条件
	else if (strcmp(pushClient->m_mediaCodecInfo.szVideoName, "H264") == 0 || strcmp(pushClient->m_mediaCodecInfo.szVideoName, "H265") == 0)
	{//H264、H265 只创建视频
		flvWrite = flv_writer_create2(0, 1, NetServerWS_FLV_OnWrite_CB, (void*)this);
		WriteLog(Log_Debug, "创建ws-flv 输出格式为： 视频 %s、音频：无音频  nClient = %llu ", pushClient->m_mediaCodecInfo.szVideoName, nClient);
	}
	
2、ws-CNetServerWS_FLV ，如果不启用音频，则不发送音频 
	int CNetServerWS_FLV::SendAudio()
	{
		std::lock_guard<std::mutex> lock(NetServerWS_FLVLock);
		
		if (nWriteErrorCount >= 30)
		{
			WriteLog(Log_Debug, "发送flv 失败,nClient = %llu ", nClient);
			DeleteNetRevcBaseClient(nClient);
			return -1;
		}

		//不是AAC
		if (strcmp(mediaCodecInfo.szAudioName, "AAC") != 0 || ABL_MediaServerPort.nEnableAudio == 0)
			return -1;
			
3、把切片buffer 的缓存大小打印出来 nMaxTsFileCacheBufferSize ，这样知道内存是否重新分配 
			
	if ((nTsCutFileCount % 30) == 0 )
	{
		if (tsPacketHandle != NULL)
			WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,HLS 视频进行 TS 切片,文件现在长度 fTSFileWriteByteCount = %d , nMaxTsFileCacheBufferSize = %d ", this, m_szURL, fTSFileWriteByteCount, nMaxTsFileCacheBufferSize);
		else if (hlsFMP4 != NULL)
			WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,HLS 视频进行 MP4 切片,文件现在长度 fTSFileWriteByteCount = %d ,nMaxTsFileCacheBufferSize = %d ", this, m_szURL, fTSFileWriteByteCount, nMaxTsFileCacheBufferSize);
	}
			
	
ABLMediaServer-2021-11-13【 ws_flv 网络协议输出成功】
1  flv数据前面增加 websocket头 
	int  CNetServerWS_FLV::WSSendFlvData(unsigned char* pData, int nDataLength)
	{
		if (nDataLength >= 0 && nDataLength <= 125)
		{
			memset(webSocketHead, 0x00, sizeof(webSocketHead));
			webSocketHead[0] = 0x82;
			webSocketHead[1] = nDataLength;
			XHNetSDK_Write(nClient, webSocketHead, 2, true);
			XHNetSDK_Write(nClient, pData, nDataLength, true);
		}
		else if (nDataLength >= 126 && nDataLength <= 0xFFFF)
		{
			memset(webSocketHead, 0x00, sizeof(webSocketHead));
			webSocketHead[0] = 0x82;
			webSocketHead[1] = 0x7E;

			wsLength16 = nDataLength;
			wsLength16 = htons(wsLength16);
			memcpy(webSocketHead + 2, (unsigned char*)&wsLength16, sizeof(wsLength16));
			XHNetSDK_Write(nClient, webSocketHead, 4, true);
			XHNetSDK_Write(nClient, pData, nDataLength, true);
		}
		else if (nDataLength > 0xFFFF)
		{
			memset(webSocketHead, 0x00, sizeof(webSocketHead));
			webSocketHead[0] = 0x82;
			webSocketHead[1] = 0x7F;

			wsLenght64 = nDataLength;
			wsLenght64 = htonl(wsLenght64);
			memcpy(webSocketHead + 2+4, (unsigned char*)&wsLenght64, sizeof(wsLenght64));
			XHNetSDK_Write(nClient, webSocketHead, 10, true);
			XHNetSDK_Write(nClient, pData, nDataLength, true);
		}
		else
			return -1;

		return 0;
	}

2、回复ping 命令，当收到关闭命令时，立即删除	

	else if (nWebSocketCommStatus == WebSocketCommStatus_ShakeHands)
	{//把数据，通过掩码进行解码 

		nCommand = 0x0F & netDataCache[0];
		if (nCommand == 0x08)
		{//关闭命令
			WriteLog(Log_Debug, "CNetServerWS_FLV = %X ,nClient = %d, 收到 websocket 关闭命令 ",nClient);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient,sizeof(nClient));
		}
		else if (nCommand == 0x09)
		{//客户端发送 ping 命令，需要回复 0x0A  {0x8A, 0x80} 
			WriteLog(Log_Debug, "CNetServerWS_FLV = %X ,nClient = %d, 收到 websocket 心跳 ",nClient);
			XHNetSDK_Write(nClient, szPong, 2, true);
		}

		nNetStart = nNetEnd = netDataCacheLength = 0;

    }
   
ABLMediaServer-2021-11-12【 尝试增加 ws_flv 网络协议输出】
1、在hls进行TS、fmp4切片需要扩充内存时，先锁住内存块 ，否则可能出现删除内存时另外一个线程正在使用。
	if (pMediaSource->nMaxTsFileCacheBufferSize - pMediaSource->fTSFileWriteByteCount < bytes)
	{//空间不够，需要扩充
		std::lock_guard<std::mutex> lock(pMediaSource->mediaTsMp4CutLock);//锁住

		unsigned char * pTempData = pMediaSource->pTsFileCacheBuffer;
		WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,最大存储空间,需要扩充 nMaxTsFileCacheBufferSize = %d，现在已经存储 fTSFileWriteByteCount = %d，剩余 %d 字节 ", pMediaSource, pMediaSource->m_szURL, pMediaSource->nMaxTsFileCacheBufferSize, pMediaSource->fTSFileWriteByteCount, pMediaSource->nMaxTsFileCacheBufferSize - pMediaSource->fTSFileWriteByteCount);

		pMediaSource->nMaxTsFileCacheBufferSize = bytes + (1024*1024*2) ;
		pMediaSource->pTsFileCacheBuffer = new unsigned char[pMediaSource->nMaxTsFileCacheBufferSize];

		memcpy(pMediaSource->pTsFileCacheBuffer, pTempData, pMediaSource->fTSFileWriteByteCount);
		SAFE_ARRAY_DELETE(pTempData);
	}


ABLMediaServer-2021-11-10【 尝试增加 ws_flv 网络协议输出】
1、增加音频是否启动参数，支持用户设置是否启动输出音频数据
	ABL_MediaServerPort.nEnableAudio = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "enable_audio", "0"));

2、在http、rtmp、http-flv、http-hls 音频输出时，根据参数来判断是否输出音频数据
	int CNetClientSendhttp::PushAudio(uint8_t* pVideoData, uint32_t nDataLength, char* szAudioCodec, int nChannels, int SampleRate)
	{
		if (ABL_MediaServerPort.nEnableAudio == 0)
			return -1;
	
	    ....
		
	}

ABLMediaServer-2021-11-05【 尝试增加 ws_flv 网络协议输出】
1、增加ws-flv 端口 

2、增加ws-flv 发送类文件 NetServerWS_FLV.cpp、NetServerWS_FLV.h


ABLMediaServer-2021-11-01【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1 、国标发流时，端口自动增加超过 65520 ,端口反转 
		if (atoi(m_startSendRtpStruct.src_port) == 0)
		{
			WriteLog(Log_Debug, "index_api_startSendRtp() nClient = %llu ,is_udp = %s, 使用的端口为 %d ",nClient, m_startSendRtpStruct.is_udp,ABL_nGB28181Port );
			ABL_nGB28181Port ++;
			if (ABL_nGB28181Port >= 65520)
				ABL_nGB28181Port = 9090;  //端口重新反转
		}
		
2 、http拉流、http推流时，如果收到非法命令打印到日志中。
	else
	{
		bIsInvalidConnectFlag = true; //确认为非法连接 
		WriteLog(Log_Debug, "非法的http 命令，立即执行删除 nClient = %llu , \r\n%s ",nClient, pRecvData);
		DeleteNetRevcBaseClient(nClient);
	}
	
3、网络库更换为 2021-11-01 版本 	
		
ABLMediaServer-2021-09-26【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1、在创建gb28181码流发送时，增加一个参数src_port，用于绑定服务器的端口 ，支持udp、tcp 
	boost::shared_ptr<CNetRevcBase> pClient = NULL;
	if (is_udp == 1)
	{
		if (atoi(m_startSendRtpStruct.src_port) == 0)
		  XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);
		else
		  XHNetSDK_BuildUdp(NULL, atoi(m_startSendRtpStruct.src_port), NULL, &nMediaClient, onread, 1);

		pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181SendRtpUDP, 0, nMediaClient, "", 0, szShareMediaURL);
	}
	else
	{
		if (atoi(m_startSendRtpStruct.src_port) == 0)
		  XHNetSDK_Connect((int8_t*)m_startSendRtpStruct.dst_url, atoi(m_startSendRtpStruct.dst_port), (int8_t*)(NULL), ABL_nGB28181Port, (uint64_t*)&nMediaClient, onread, onclose, onconnect, 0, 5000, 1);
		else
		  XHNetSDK_Connect((int8_t*)m_startSendRtpStruct.dst_url, atoi(m_startSendRtpStruct.dst_port), (int8_t*)(NULL), atoi(m_startSendRtpStruct.src_port), (uint64_t*)&nMediaClient, onread, onclose, onconnect, 0, 5000, 1);

	   pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181SendRtpTCP_Connect, 0, nMediaClient, "", 0, szShareMediaURL);
	}

	if (pClient != NULL)
	{
		memcpy((char*)&pClient->m_startSendRtpStruct, (char*)&m_startSendRtpStruct, sizeof(m_startSendRtpStruct));

		nReturnPort = ABL_nGB28181Port;
		if (atoi(m_startSendRtpStruct.src_port) > 0)
			nReturnPort = atoi(m_startSendRtpStruct.src_port);

		sprintf(szResponseBody, "{\"code\":0,\"port\":%d,\"memo\":\"success\",\"key\":%d}", nReturnPort, pClient->nClient);
		ResponseSuccess(szResponseBody);
	}

	if (atoi(m_startSendRtpStruct.src_port) == 0)
	{
		WriteLog(Log_Debug, "index_api_startSendRtp() nClient = %llu ,is_udp = %s, 使用的端口为 %d ",nClient, m_startSendRtpStruct.is_udp,ABL_nGB28181Port );
		ABL_nGB28181Port ++;
	}
	else
	{
		WriteLog(Log_Debug, "index_api_startSendRtp() nClient = %llu ,is_udp = %s, 使用的端口为 %s ", nClient, m_startSendRtpStruct.is_udp, m_startSendRtpStruct.src_port);
	}

ABLMediaServer-2021-09-18【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1、libflv 更换为release 版本

2、 当剩余少量数据时，检测剩余的空间是否够存储网络达到数据 
	if (netDataCacheLength > 0)
	{//如果有少量剩余
		memmove(netDataCache, netDataCache + nNetStart, netDataCacheLength);
		nNetStart = 0;
		nNetEnd = netDataCacheLength;

		//当剩余少量数据时，检测剩余的空间是否够存储网络达到数据 
		if (MaxNetDataCacheCount - nNetEnd < nDataLength)
		{
			nNetStart = nNetEnd = netDataCacheLength = 0;
			WriteLog(Log_Debug, "CNetClientSendhttp = %X nClient = %llu 数据异常 , 执行删除", this, nClient);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return 0;
		}
	}

ABLMediaServer-2021-09-17【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1 优化flv\rtmp 发流类销毁函数代码
	CNetRtmpServerRecv::~CNetRtmpServerRecv()
	{
		std::lock_guard<std::mutex> lock(NetRtmpServerLock);
		
		WriteLog(Log_Debug, "CNetRtmpServerRecv =%X  Step 1 nClient = %llu ",this, nClient);

		XHNetSDK_Disconnect(nClient);
		WriteLog(Log_Debug, "CNetRtmpServerRecv =%X  Step 3 nClient = %llu ",this, nClient);

		//从媒体拷贝线程池移除
		WriteLog(Log_Debug, "CNetRtmpServerRecv =%X  Step 4 nClient = %llu ",this, nClient);

		rtmp_server_destroy(rtmp);
		WriteLog(Log_Debug, "CNetRtmpServerRecv =%X  Step 5 nClient = %llu ",this, nClient);

		if(flvDemuxer)
		  flv_demuxer_destroy(flvDemuxer);

		if (flvMuxer)
			flv_muxer_destroy(flvMuxer);
		WriteLog(Log_Debug, "CNetRtmpServerRecv =%X  Step 6 nClient = %llu ",this, nClient);

	#ifdef  WriteFlvFileByDebug
		flv_writer_destroy(s_flv);
	#endif
	#ifdef  WriteFlvToEsFileFlag
		fclose(fWriteVideo);
		fclose(fWriteAudio);
	#endif

		NetDataFifo.FreeFifo();
		m_videoFifo.FreeFifo();
		m_audioFifo.FreeFifo();

		//如果是接收推流，并且成功接收推流的，则需要删除媒体数据源 szURL ，比如 /Media/Camera_00001 
		if (bPushMediaSuccessFlag && netBaseNetType == NetBaseNetType_RtmpServerRecvPush)
			DeleteMediaStreamSource(szURL);
		
		pRemoveBaseNetFromThreadFifo.push((unsigned char*)&nClient, sizeof(nClient)); //从媒体拷贝线程、媒体发送线程移除掉Client  

		WriteLog(Log_Debug, "CNetRtmpServerRecv = %X 析构 nClient = %llu \r\n", this, nClient);
	}
2、 rtmp 状态，只有大于等于3，才能调用rtmp_client_stop 函数，否则会奔溃 
	int rtmpState = 0;
	if (rtmp != NULL)
	{
		rtmpState = rtmp_client_getstate(rtmp);
		if(rtmpState >= 3)
		  rtmp_client_stop(rtmp);

		rtmp_client_destroy(rtmp);
	}
	
3  Makefile 包含文件的路径修改为相对路径 
	INCLUDES = -I../rapidjson-master/include \
			   -I../media-server-master/libflv/include \
			   -I../media-server-master/librtmp/include \
			   -I../media-server-master/libmpeg/include \
			   -I../media-server-master/libhls/include \
			   -I../media-server-master/libmov/include 
	LIBS = -L../Linux/lib -lboost_system -lboost_thread -lboost_log -lboost_regex -lboost_filesystem -lboost_date_time -lboost_chrono -lboost_atomic -lrtmp -lflv -lmpeg -lhls -lmov -lrtp

ABLMediaServer-2021-09-12【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1 在http、rtmp、flv、gb28181 发送码流、http\rtmp 推流时，网络发送失败，需要立即从媒体源移除，需要从发送线程移除 
	if (pClient->nWriteErrorCount >= 30)
	{
	   pClient->bRunFlag = false;
	   WriteLog(Log_Debug, "rtmp_server_send 发送失败，次数 nWriteErrorCount = %d ", pClient->nWriteErrorCount);

	   pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
	}

ABLMediaServer-2021-10-04【支持windows\Linux两个平台，首次移除成功】
1 首次移植成功 

ABLMediaServer-2021-10-03【支持windows\Linux两个平台】
1 国标接收、发送都要更新为用户设置的payload 
  udp 类型更新方法
	 if (pClient != NULL)
	 {
		pClient->hParent     = nClient; //记录国标代理的句柄号，当国标发流、收流断线时，能同时销毁代理句柄资源 
		pClient->m_gbPayload = atoi(m_openRtpServerStruct.payload);//更新为正确的paylad
	 }
	 
  TCP类型更新方法
	if (GetNetServerTypeByHandle(serverHandle, szMediaSource,hParent) == NetServerHandleType_GB28181RecvStream)
	{//国标TCP方式接收码流
		pXHClient = boost::make_shared<CNetGB28181RtpServer>(serverHandle, CltHandle, szIP, nPort, szMediaSource);
		pXHClient->netBaseNetType = NetBaseNetType_NetGB28181RtpServerTCP_Server;//国标28181 tcp 方式接收码流 
		pXHClient->hParent = hParent;//记录国标代理句柄号

		CNetRevcBase_ptr gb28181RecvProxy = GetNetRevcBaseClientNoLock(hParent);
		if (gb28181RecvProxy != NULL)
			pXHClient->m_gbPayload = atoi(gb28181RecvProxy->m_openRtpServerStruct.payload);//更新paylad 
	}
	
2 Linux平台下面 Sleep 修改为函数方式
	//延时
	void  Sleep(int mMicroSecond)
	{
		if (mMicroSecond > 0)
			usleep(mMicroSecond * 1000);
		else
			usleep(5 * 1000);
	}

3、增加Linux平台下面把某一个路径所有文件删除功能    
	#else
		struct dirent * filename;    // return value for readdir()
		DIR * dir;                   // return value for opendir()
		dir = opendir(szDeletePath);
		if (NULL == dir)
			return ;
	 
		/* read all the files in the dir  */
		while ((filename = readdir(dir)) != NULL)
		{
			if (strcmp(filename->d_name, ".") == 0 ||
				strcmp(filename->d_name, "..") == 0)
				continue;

			sprintf(szDeleteFile, "%s/%s", szHLSPath, filename->d_name);
			DeleteFile(szDeleteFile);
			WriteLog(Log_Debug, "删除异常文件： %s ", szDeleteFile);
		}
		closedir(dir);
	#endif
	
4、把http 主动拉流 的sdp 拷贝给mediaSource

		//把http的SDP 拷贝给媒体源 
		if(pMediaSource)
		  strcpy(pMediaSource->httpSDPContent.szSDPContent, szhttpContentSDP);

		WriteLog(Log_Debug, "RecvData \r\n%s \r\n", pRecvData);

		GetSPSPPSFromDescribeSDP();
		if (m_nSpsPPSLength > 0 && m_nSpsPPSLength <= sizeof(pMediaSource->pSPSPPSBuffer))
		{
 			memcpy(pMediaSource->pSPSPPSBuffer, m_pSpsPPSBuffer, m_nSpsPPSLength);
			pMediaSource->nSPSPPSLength = m_nSpsPPSLength;
 		}
		
		//把视频，音频相关信息拷贝给媒体源
		strcpy(pMediaSource->httpSDPContent.szVideoName, szVideoName);
		pMediaSource->httpSDPContent.nVidePayload = nVideoPayload;
		strcpy(pMediaSource->httpSDPContent.szAudioName, szAudioName);
		pMediaSource->httpSDPContent.nChannels = nChannels;
		pMediaSource->httpSDPContent.nAudioPayload = nAudioPayload;
		pMediaSource->httpSDPContent.nSampleRate = nSampleRate;

	
ABLMediaServer-2021-10-02-2【支持windows\Linux两个平台】
1 修改了一些变量 比如，DWORD ,BOOL, TRUE ,FALSE ,

2 修改了线程创建
	#ifdef OS_System_Windows
			hProcessHandle[nCreateThreadProcessCount] = ::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)OnProcessThread, (LPVOID)this, 0, &dwThread);
	#else 
			pthread_create(&hProcessHandle[nCreateThreadProcessCount], NULL, OnProcessThread, (void*)this);
	#endif

3 class CNetGB28181RtpServer : public CNetRevcBase
  更换为通用锁
  std::mutex              netDataLock;
  
4、实现了Linux下面的GetTickCount(),GetTickCount64() , DeleteFile()，Sleep() 等等函数 
	#ifndef OS_System_Windows
	unsigned long GetTickCount()
	{
		struct timeval tv;
		gettimeofday(&tv, NULL);
		return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
	}
	unsigned long GetTickCount64()
	{
		struct timeval tv;
		gettimeofday(&tv, NULL);
		return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
	}

	//删除文件
	bool   DeleteFile(char* szFileName)
	{
		unlink(szFileName);
	}
	#endif
	
5、重新包括Linux下面的头文件
    #ifdef  OS_System_Windows
	   .....
	#else 
		#include <stdlib.h>
		#include <stdio.h>
		#include <string.h>
		#include <unistd.h>
		#include <float.h>

		#include<sys/types.h> 
		#include<sys/socket.h>
		#include<sys/time.h>
		#include<netinet/in.h>
		#include<arpa/inet.h>
		#include<unistd.h> 

		#include <pthread.h>
		#include <signal.h>
		#include <string>
		#include <list>
		#include <map>
		#include <vector>
		#include <math.h>
		#include <iconv.h>
	#endif

ABLMediaServer-2021-09-28【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1、 http连接失败时，需要立即断开 
	else if (memcmp(szIP, "http://", 7) == 0)
	{//http 
		pXHClient = boost::make_shared<CNetClientRecvhttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL, pCustomerPtr, callbackFunc,hParent);
		CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
		if (CltHandle == 0)
		{//连接失败
			WriteLog(Log_Debug, "CreateNetRevcBaseClient()，连接 http 服务器 失败 szURL = %s , szIP = %s ,port = %d ",szIP,pXHClient->m_httpStruct.szIP, pXHClient->m_httpStruct.szPort);
			pDisconnectBaseNetFifo.push((unsigned char*)&pXHClient->nClient, sizeof(pXHClient->nClient));
		}
	}				

2、rtp长度允许大于 1500 ，最大为 65535 	
	if (nRtpLength > 0 && nRtpLength < 65535 )
	{
		if (data_[1] == 0x00)
		{
			rtp_depacket_input(hRtpHandle[0], netDataCache + nNetStart , nRtpLength );

			//if(nPrintCount % 200 == 0)
			//  printf("this =%X, Video Length = %d \r\n",this, nReadLength);
		}
		
3、	优化查找 @ 的位置，因为http密码可能有@这个字符 ，要从后面开始查找 	
	//查找 @ 的位置
	nPos2 = strhttpURL.rfind("@", strlen(szURL));
	if (nPos2 > 0)
	{

ABLMediaServer-2021-09-08【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】

1  在优化 CNethttpServer rtp 数据读取性能时，需要积累 Content-Length 所包括的内容 
int CNethttpServer::ProcessNetData()
{
	//如果有ContentLength ，需要积累了ContentLength的内容再进行读取 
	if (netDataCacheLength < nContentLength)
	{//剩下的数据不够 ContentLength ,需要重新移动已经读取的字节数 data_Length  
		nNetStart           -= data_Length ;
		netDataCacheLength  += data_Length ;
		bExitProcessFlagArray[2] = true;
		WriteLog(Log_Debug, "ReadDataFunc (), http 的 Content-Length 的数据尚未接收完整  nClient = %llu", nClient);
		return 0;
	}

}	
ABLMediaServer-2021-09-05【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本、gb28181完善版本】
1 把所有http类库的InputNetData函数、ProcessNetData函数都加同一把锁，否则数据会错乱，析构函数也枷锁
    //网络数据拼接 
	int CNetClientRecvhttp::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength)
	{
		std::lock_guard<std::mutex> lock(netDataLock);

        ....
	}
 
	 //处理网络数据
	int CNetClientRecvhttp::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(netDataLock);

        ...
	}
	
	//析构函数 
	CNetClientRecvhttp::~CNetClientRecvhttp()
	{
		std::lock_guard<std::mutex> lock(netDataLock);
		bRunFlag = false;
	  
	    ...
	}
	
2 在读取rtp数据时，不需要重新再读取，直接使用网络拼接数据 
	if (nRtpLength > 0 && nRtpLength < 1500)
	{
		if (data_[1] == 0x00)
		{
		     //直接使用网络拼接数据
			 rtp_depacket_input(hRtpHandle[0], netDataCache + nNetStart, nRtpLength);

			//if(nPrintCount % 200 == 0)
			//  printf("this =%X, Video Length = %d \r\n",this, nReadLength);
		}
		else if (data_[1] == 0x02)
		{
		    //直接使用网络拼接数据
			rtp_depacket_input(hRtpHandle[1], netDataCache + nNetStart , nRtpLength);

			//if(nPrintCount % 100 == 0 )
			//	WriteLog(Log_Debug, "this =%X ,Audio Length = %d ",this,nReadLength);

			nPrintCount ++;
		}
		else if (data_[1] == 0x01)
		{//收到RTCP包，需要回复rtcp报告包
			//SendRtcpReportData(nVideoSSRC, data_[1]);
			//WriteLog(Log_Debug, "this =%X ,收到 视频 的RTCP包，需要回复rtcp报告包，netBaseNetType = %d  收到RCP包长度 = %d ", this, netBaseNetType, nReadLength);
		}
		else if (data_[1] == 0x03)
		{//收到RTCP包，需要回复rtcp报告包
			//SendRtcpReportData(nVideoSSRC+1, data_[1]);
			//WriteLog(Log_Debug, "this =%X ,收到 音频 的RTCP包，需要回复rtcp报告包，netBaseNetType = %d  收到RCP包长度 = %d ", this, netBaseNetType, nReadLength);
		}

		bExitProcessFlagArray[2] = true;
		nNetStart          += nRtpLength; //位置移动
		netDataCacheLength -= nRtpLength; //长度减少 
	}

ABLMediaServer-2021-09-01【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1  http码流接收时，由于丢包，重新查找 $的位置，稳定网络接收 
	//查找rtp包标志 
	bool CNetClientRecvhttp::FindRtpPacketFlag()
	{
		bool bFindFlag = false;

		unsigned char szRtpFlag[2] = { 0x24, 0x00 };
		int  nPos = 0;

		if (netDataCacheLength > 2)
		{
			for (int i = nNetStart; i < nNetEnd; i++)
			{
				if (memcmp(netDataCache + i, szRtpFlag, 2) == 0)
				{
					nPos = i;
					bFindFlag = true;
					break;
				}
			}
		}

		//找到标志，重新计算起点，及长度 
		if (bFindFlag)
		{
			nNetStart = nPos;
			netDataCacheLength = nNetEnd - nNetStart;
			WriteLog(Log_Debug, "CNetClientRecvhttp = %X ,找到RTP位置， nNetStart = %d , nNetEnd = %d , netDataCacheLength = %d ", this, nNetStart, nNetEnd, netDataCacheLength);
		}

		return bFindFlag;
	}
	
	if (FindRtpPacketFlag() == true)
	{//rtp 丢包 ,乱序
		bExitProcessFlagArray[2] = true;
		return 0;
	}

2 、如果剩余的长度，不够rtp指定长度时，需要重新设定位置、总长度，立即返回 ，等待积累够在读取   	
	if (nRtpLength > netDataCacheLength)
	{//剩余rtp长度不够读取，需要退出，等待下一次读取
		bExitProcessFlagArray[2] = true;
		nNetStart -= 4;
		netDataCacheLength += 4;
		return 0;
	}
	
3、删除分配的参数内存
   DeleteNetServerHandle(nMediaClient);
   
4、 国标接收码流时，确保端口成绑定成功    
	if (nTcp_Switch == 0)
	{//udp方式
		do
		{
		   if (atoi(m_openRtpServerStruct.port) == 0)
		   {
			 nRet = XHNetSDK_BuildUdp(NULL, ABL_nGB28181Port, NULL, &nMediaClient, onread, 1);
			 if(nRet != 0)
			   ABL_nGB28181Port += 1;
		   }
		   else
		   {
			 nRet = XHNetSDK_BuildUdp(NULL, atoi(m_openRtpServerStruct.port), NULL, &nMediaClient, onread, 1);
			 if (nRet != 0)
			 {
				strcpy(szTemp2, m_openRtpServerStruct.port);
				sprintf(m_openRtpServerStruct.port, "%d", atoi(szTemp2) + 1);//端口递增 
			 }
		   }
		} while (nRet != 0);

		 boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetBaseNetType_NetGB28181RtpServerUDP, 0, nMediaClient, "", ABL_nGB28181Port, szTemp);
		 if (pClient != NULL)
			pClient->hParent = nClient; //记录国标代理的句柄号，当国标发流、收流断线时，能同时销毁代理句柄资源 
	}
	else if (nTcp_Switch == 1)
	{//如果是TCP
		do
		{
			if (atoi(m_openRtpServerStruct.port) == 0)
			{
				nRet = XHNetSDK_Listen((int8_t*)("0.0.0.0"), ABL_nGB28181Port, &nMediaClient, onaccept, onread, onclose, true);
				if (nRet != 0)
				  ABL_nGB28181Port += 1;
			}
			else
			{
				nRet = XHNetSDK_Listen((int8_t*)("0.0.0.0"), atoi(m_openRtpServerStruct.port), &nMediaClient, onaccept, onread, onclose, true);
				if (nRet != 0)
				{
					strcpy(szTemp2, m_openRtpServerStruct.port);
					sprintf(m_openRtpServerStruct.port, "%d", atoi(szTemp2) + 1);//端口递增 
				}
			}
		} while (nRet != 0);

		NetServerHandleParam* param = new NetServerHandleParam;
		param->nNetServerHandleType = NetServerHandleType_GB28181RecvStream;
		param->hParent = nClient;
		sprintf(param->szMediaSource, "/%s/%s", m_openRtpServerStruct.app, m_openRtpServerStruct.stream);

		AddNetServerHandle(nMediaClient,param);
	}

	//自动产生端口
	if (atoi(m_openRtpServerStruct.port) == 0)
	   sprintf(m_openRtpServerStruct.port, "%d", ABL_nGB28181Port); //记下真实端口 

	ABL_nGB28181Port ++;//需要优化端口 
	if (ABL_nGB28181Port >= 65535)
		ABL_nGB28181Port = 9090;  //端口重新反转


ABLMediaServer-2021-08-30【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1、接收流断线检测增加 国标UDP方式、TCP方式断线检测类型 NetBaseNetType_NetGB28181RtpServerUDP \ NetBaseNetType_NetGB28181RtpServerTCP_Server 
	for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); ++iterator1)
	{
		if (((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSServerSendPush || //HLS　发送
			((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpServerRecvPush ||      //接收RTMP推流

			((*iterator1).second)->netBaseNetType == NetBaseNetType_httpClientRecv ||      //代理接收http推流
			((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpClientRecv ||      //代理接收Rtmp推流
			((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpFlvClientRecv ||   //代理接收HttpFlv推流
			((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSClientRecv ||    //代理接收HttpHLS推流

			((*iterator1).second)->netBaseNetType == NetBaseNetType_NetGB28181RtpServerUDP ||   //GB28181 以UDP方式接收 
			((*iterator1).second)->netBaseNetType == NetBaseNetType_NetGB28181RtpServerTCP_Server //GB28181 以TCP方式接收 
		)
		{//现在检测 HLS 网络断线 ，还可以增加别的类型检测

2、国标UDP、TCP方式接收码流，如果断线同时也要销毁代理的句柄 CNetGB28181Proxy 资源 	
	 if (hParent > 0)
	 {
		 WriteLog(Log_Debug, "CNetGB28181RtpServer = %X 加入清理国标代理句柄号 hParent = %llu, nClient = %llu ,nMediaClient = %llu", this, hParent, nClient, nMediaClient);
		 pDisconnectBaseNetFifo.push((unsigned char*)&hParent, sizeof(hParent));
	 }

3、国标TCP发送，http推流、http发送都要增加一个条件 	 nSendRtpVideoMediaBufferLength > 0 ，否则会造成发送失败，进而造成发送对象被删除 
	if (nStartVideoTimestamp != GB28181VideoStartTimestampFlag &&  nStartVideoTimestamp != nCurrentVideoTimestamp && nSendRtpVideoMediaBufferLength > 0)
	{//产生一帧新的视频 
		nSendRet = XHNetSDK_Write(nClient, szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength, 1);
		if (nSendRet != 0)
		{
			WriteLog(Log_Debug, "CNetGB28181RtpClient = %X, 发送国标RTP码流出错 ，Length = %d ,nSendRet = %d", this, nSendRtpVideoMediaBufferLength, nSendRet);
			DeleteNetRevcBaseClient(nClient);
			return;
		}

		nSendRtpVideoMediaBufferLength = 0;
	}	 

4、国标TCP方式接收码流，读取到rtp数据后，调用 RtpDepacket 进行rtp解包 
  if(nRtpLength > 0 )
	  RtpDepacket(netDataCache + nNetStart, nRtpLength);
	
ABLMediaServer-2021-08-29【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 优化http推流、转发http 码流代码，少拷贝一次，直接拷贝到发送缓冲区上 
	void CNethttpServer::ProcessRtpVideoData(unsigned char* pRtpVideo,int nDataLength)
	{
		if ((MaxRtpSendVideoMediaBufferLength - nSendRtpVideoMediaBufferLength < nDataLength + 4) && nSendRtpVideoMediaBufferLength > 0 )
		{//剩余空间不够存储 ,防止出错 
			SumSendRtpMediaBuffer(szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength);
			nSendRtpVideoMediaBufferLength = 0;
		}

		memcpy((char*)&nCurrentVideoTimestamp, pRtpVideo + 4, sizeof(uint32_t));
		if (nStartVideoTimestamp != VideoStartTimestampFlag &&  nStartVideoTimestamp != nCurrentVideoTimestamp)
		{//产生一帧新的视频 
			//WriteLog(Log_Debug, "CNethttpServer= %X, 发送一帧视频 ，Length = %d ", this, nSendRtpVideoMediaBufferLength);
			SumSendRtpMediaBuffer(szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength);
			nSendRtpVideoMediaBufferLength = 0;
		}
	 
		szSendRtpVideoMediaBuffer[nSendRtpVideoMediaBufferLength + 0] = '$';
		szSendRtpVideoMediaBuffer[nSendRtpVideoMediaBufferLength + 1] = 0;
		nVideoRtpLen = htons(nDataLength);
		memcpy(szSendRtpVideoMediaBuffer + (nSendRtpVideoMediaBufferLength + 2), (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));
		memcpy(szSendRtpVideoMediaBuffer + (nSendRtpVideoMediaBufferLength + 4), pRtpVideo, nDataLength);
	 
		nStartVideoTimestamp = nCurrentVideoTimestamp;
		nSendRtpVideoMediaBufferLength += nDataLength + 4;
	}
	void CNethttpServer::ProcessRtpAudioData(unsigned char* pRtpAudio, int nDataLength)
	{
		if ((MaxRtpSendAudioMediaBufferLength - nSendRtpAudioMediaBufferLength < nDataLength + 4) && nSendRtpAudioMediaBufferLength > 0 )
		{//剩余空间不够存储 ,防止出错 
			SumSendRtpMediaBuffer(szSendRtpAudioMediaBuffer, nSendRtpAudioMediaBufferLength);

			nSendRtpAudioMediaBufferLength = 0;
			nCalcAudioFrameCount = 0;
		}

		szSendRtpAudioMediaBuffer[nSendRtpAudioMediaBufferLength + 0] = '$';
		szSendRtpAudioMediaBuffer[nSendRtpAudioMediaBufferLength + 1] = 2;
		nAudioRtpLen = htons(nDataLength);
		memcpy(szSendRtpAudioMediaBuffer + (nSendRtpAudioMediaBufferLength + 2), (unsigned char*)&nAudioRtpLen, sizeof(nAudioRtpLen));
		memcpy(szSendRtpAudioMediaBuffer + (nSendRtpAudioMediaBufferLength + 4), pRtpAudio, nDataLength);

		nSendRtpAudioMediaBufferLength += nDataLength + 4;
		nCalcAudioFrameCount ++;

		if (nCalcAudioFrameCount >= 5 && nSendRtpAudioMediaBufferLength > 0 )
		{
			SumSendRtpMediaBuffer(szSendRtpAudioMediaBuffer, nSendRtpAudioMediaBufferLength);
			nSendRtpAudioMediaBufferLength = 0;
			nCalcAudioFrameCount = 0;
		}
	}
	
2  修正代理退出的网络类型 NetBaseNetType_addPushProxyControl 
	CNetClientAddPushProxy::CNetClientAddPushProxy(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort,char* szShareMediaURL)
	{
		strcpy(m_szShareMediaURL,szShareMediaURL);
		netBaseNetType = NetBaseNetType_addPushProxyControl;
		nMediaClient = 0;
		WriteLog(Log_Debug, "CNetClientAddStreamProxy =%X 构造 nClient = %llu ", this, nClient);
	}

ABLMediaServer-2021-08-28【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 增加国标28181 TCP 方式的网络数据拼接
	else if (netBaseNetType == NetBaseNetType_NetGB28181RtpServerTCP_Server)
	{//TCP 
		if (netDataCache == NULL)
		{
		   netDataCacheLength = 0;//网络数据缓存大小
		   nNetStart = nNetEnd = 0; //网络数据起始位置\结束位置
		   MaxNetDataCacheCount = MaxNetDataCacheBufferLength;
		   netDataCache = new unsigned char[MaxNetDataCacheBufferLength];
 		}

		EnterCriticalSection(&netDataLock);
 			if (MaxNetDataCacheCount - nNetEnd >= nDataLength)
			{//剩余空间足够
				memcpy(netDataCache + nNetEnd, pData, nDataLength);
				netDataCacheLength += nDataLength;
				nNetEnd += nDataLength;
			}
			else
			{//剩余空间不够，需要把剩余的buffer往前移动
				if (netDataCacheLength > 0)
				{//如果有少量剩余
					memmove(netDataCache, netDataCache + nNetStart, netDataCacheLength);
					nNetStart = 0;
					nNetEnd = netDataCacheLength;
				}
				else
				{//没有剩余，那么 首，尾指针都要复位 
					nNetStart = nNetEnd = netDataCacheLength = 0;
 				}
				memcpy(netDataCache + nNetEnd, pData, nDataLength);
				netDataCacheLength += nDataLength;
				nNetEnd += nDataLength;
			}
		LeaveCriticalSection(&netDataLock);
	}
	
2 	增加国标28181 TCP 方式的网络数据切割成1帧帧的rtp包数据，进行rtp解包 
	else if (netBaseNetType == NetBaseNetType_NetGB28181RtpServerTCP_Server)
	{//TCP 方式的rtp包读取 
		EnterCriticalSection(&netDataLock);
		  while (netDataCacheLength > 1500)
		  {
			  memcpy(rtpHeadOfTCP, netDataCache + nNetStart, 2);
			  if ((rtpHeadOfTCP[0] == 0x24 && rtpHeadOfTCP[1] == 0x00) || (rtpHeadOfTCP[0] == 0x24 && rtpHeadOfTCP[1] == 0x01))
			  {
			      nNetStart += 2;
				  memcpy((char*)&nRtpLength, netDataCache + nNetStart, 2);
				  nNetStart += 2; 
				  netDataCacheLength -= 4;
			  }
			  else
			  {
 				 memcpy((char*)&nRtpLength, netDataCache + nNetStart, 2);
				 nNetStart += 2;
			     netDataCacheLength -= 2;
			  }

			  nRtpLength = ntohs(nRtpLength);
			  if (nRtpLength > 1500)
			  {
				  WriteLog(Log_Debug, "CNetGB28181RtpServer = %X rtp包头长度有误  nClient = %llu ,nRtpLength = %llu", this, nClient, nRtpLength);
				  LeaveCriticalSection(&netDataLock);
				  DeleteNetRevcBaseClient(nClient);
				  return -1;
			  }

			  if(hRtpHandle > 0 )
			    rtp_depacket_input(hRtpHandle, netDataCache + nNetStart, nRtpLength);

			  nNetStart += nRtpLength;
			  netDataCacheLength -= nRtpLength;
		  }
		LeaveCriticalSection(&netDataLock);
	}

4、优化GB28181 TCP方式发送的码流拷贝模块

	if (ABL_MediaServerPort.nGBRtpTCPHeadType == 1)
	{//国标 TCP发送 4个字节方式
		szSendRtpVideoMediaBuffer[nSendRtpVideoMediaBufferLength + 0] = '$';
		szSendRtpVideoMediaBuffer[nSendRtpVideoMediaBufferLength + 1] = 0;
		nVideoRtpLen = htons(nDataLength);
		memcpy(szSendRtpVideoMediaBuffer + (nSendRtpVideoMediaBufferLength + 2), (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));
		memcpy(szSendRtpVideoMediaBuffer + (nSendRtpVideoMediaBufferLength + 4), pRtpVideo, nDataLength);

		nStartVideoTimestamp = nCurrentVideoTimestamp;
 		nSendRtpVideoMediaBufferLength += nDataLength + 4;
	}
	else if (ABL_MediaServerPort.nGBRtpTCPHeadType == 2)
	{//国标 TCP发送 2 个字节方式
		nVideoRtpLen = htons(nDataLength);
		memcpy(szSendRtpVideoMediaBuffer + nSendRtpVideoMediaBufferLength, (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));
		memcpy(szSendRtpVideoMediaBuffer + (nSendRtpVideoMediaBufferLength + 2), pRtpVideo, nDataLength);

		nStartVideoTimestamp = nCurrentVideoTimestamp;
 		nSendRtpVideoMediaBufferLength += nDataLength + 2;
	}
	else
	{
		WriteLog(Log_Debug, "CNetGB28181RtpClient = %X, 非法的国标TCP包头发送方式(必须为 1、2 )nGBRtpTCPHeadType = %d ", this, ABL_MediaServerPort.nGBRtpTCPHeadType);
		DeleteNetRevcBaseClient(nClient);
	}

	
ABLMediaServer-2021-08-27【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 增加TCP国标28181PS码流TCP方式发送 ，支持4、2两个字节头发送
	void  CNetGB28181RtpClient::GB28181SentRtpVideoData(unsigned char* pRtpVideo, int nDataLength)
	{
		if ((MaxRtpSendVideoMediaBufferLength - nSendRtpVideoMediaBufferLength < nDataLength + 4) && nSendRtpVideoMediaBufferLength > 0)
		{//剩余空间不够存储 ,防止出错 
			nSendRet = XHNetSDK_Write(nClient, szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength, 1);
			if (nSendRet != 0)
			{
				WriteLog(Log_Debug, "CNetGB28181RtpClient = %X, 发送国标RTP码流出错 ，Length = %d ,nSendRet = %d", this, nSendRtpVideoMediaBufferLength, nSendRet);
				DeleteNetRevcBaseClient(nClient);
				return;
			}

			nSendRtpVideoMediaBufferLength = 0;
		}

		memcpy((char*)&nCurrentVideoTimestamp, pRtpVideo + 4, sizeof(uint32_t));
		if (nStartVideoTimestamp != GB28181VideoStartTimestampFlag &&  nStartVideoTimestamp != nCurrentVideoTimestamp)
		{//产生一帧新的视频 
			nSendRet = XHNetSDK_Write(nClient, szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength, 1);
			if (nSendRet != 0)
			{
				WriteLog(Log_Debug, "CNetGB28181RtpClient = %X, 发送国标RTP码流出错 ，Length = %d ,nSendRet = %d", this, nSendRtpVideoMediaBufferLength, nSendRet);
				DeleteNetRevcBaseClient(nClient);
				return;
			}

			nSendRtpVideoMediaBufferLength = 0;
		}

		if (ABL_MediaServerPort.nGBRtpTCPHeadType == 1)
		{//国标 TCP发送 4个字节方式
			szRtpDataOverTCP[0] = '$';
			szRtpDataOverTCP[1] = 0;
			nVideoRtpLen = htons(nDataLength);
			memcpy(szRtpDataOverTCP + 2, (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));
			memcpy(szRtpDataOverTCP + 4, pRtpVideo, nDataLength);

			nStartVideoTimestamp = nCurrentVideoTimestamp;
			memcpy(szSendRtpVideoMediaBuffer + nSendRtpVideoMediaBufferLength, szRtpDataOverTCP, nDataLength + 4);
			nSendRtpVideoMediaBufferLength += nDataLength + 4;
		}
		else if (ABL_MediaServerPort.nGBRtpTCPHeadType == 2)
		{//国标 TCP发送 2 个字节方式
			nVideoRtpLen = htons(nDataLength);
			memcpy(szRtpDataOverTCP , (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));
			memcpy(szRtpDataOverTCP + 2, pRtpVideo, nDataLength);

			nStartVideoTimestamp = nCurrentVideoTimestamp;
			memcpy(szSendRtpVideoMediaBuffer + nSendRtpVideoMediaBufferLength, szRtpDataOverTCP, nDataLength + 2);
			nSendRtpVideoMediaBufferLength += nDataLength + 2;
		}
		else
		{
			WriteLog(Log_Debug, "CNetGB28181RtpClient = %X, 非法的国标TCP包头发送方式(必须为 1、2 )nGBRtpTCPHeadType = %d ", this, ABL_MediaServerPort.nGBRtpTCPHeadType);
			DeleteNetRevcBaseClient(nClient);
		}
	}

ABLMediaServer-2021-08-26【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1、 把http api 操作密码大小扩展为256个字节 
	//代理拉流转发参数结构
	struct addStreamProxyStruct
	{
		char  secret[256];//api操作密码 

2、获取媒体源时，需要视频码流出来才统计在列表中 
	if (strlen(tmpMediaSource->m_mediaCodecInfo.szVideoName) > 0)
	{
		sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"sourceType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},", pClient->nClient, pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType, tmpMediaSource->mediaSendMap.size(),
			tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

		strcat(szMediaSourceInfo, szTemp2);

		nMediaCount++;
	}
	
3、连接成功、失败都要打印url 	
  void LIBNET_CALLMETHOD	onconnect(NETHANDLE clihandle,
	uint8_t result)
   {  
	if (result == 0)
	{
		CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
		if (pClient)
 			WriteLog(Log_Debug, "clihandle = %llu ,URL: %s ，连接失败 result: %d ", clihandle,pClient->m_httpStruct.szSrchttpPullUrl,result);
 		 
	   pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));
	}
	else if (result == 1)
	{//如果链接成功，发送第一个请求
		CNetRevcBase_ptr pClient = GetNetRevcBaseClient(clihandle);
		if (pClient)
		{
			WriteLog(Log_Debug, "clihandle = %llu ,URL: %s ，连接成功 result: %d ", clihandle, pClient->m_httpStruct.szSrchttpPullUrl, result);

			pClient->SendFirstRequst();
		}
	}
   }
   
4、在CNetServerHLS 播放hls类库中， 服务器不能主动断开，否则VLC播放不正常 ,ffplay 也经常播放不正常 

#if 0  //服务器不能主动断开，否则VLC播放不正常 ,ffplay 也经常播放不正常
	  //发送完毕,如果是短连接，立即删除
	  if(strcmp(szConnectionType,"Close") == 0 || strcmp(szConnectionType, "close") == 0 || bRequestHeadFlag == true)
	      pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
#endif

   
ABLMediaServer-2021-08-24【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1、国标解包后，把声音加入媒体源，支持aac、g711a、g711u 
	if (cb->streamtype == e_rtpdepkt_st_aac)
	{//aac
		pThis->pMediaSource->PushAudio(cb->data, cb->datasize, "AAC",1,16000);
	}
	else if (cb->streamtype == e_rtpdepkt_st_g711a)
	{// G711A  
		pThis->pMediaSource->PushAudio(cb->data, cb->datasize, "G711_A", 1, 8000);
	}
	else if (cb->streamtype == e_rtpdepkt_st_g711u)
	{// G711U  
		pThis->pMediaSource->PushAudio(cb->data, cb->datasize, "G711_U", 1, 8000);
	}
	
2、修复PS打包时 G711A、G711U 的音频编码器检测
	if ((pData = m_audioFifo.pop(&nLength)) != NULL)
	{
		input.mediatype = e_psmux_mt_audio;
		if (strcmp(mediaCodecInfo.szAudioName, "AAC") == 0)
			input.streamtype = e_psmux_st_aac;
		else if (strcmp(mediaCodecInfo.szAudioName, "G711_A") == 0)
			input.streamtype = e_psmux_st_g711a;
		else if (strcmp(mediaCodecInfo.szAudioName, "G711_U") == 0)
			input.streamtype = e_psmux_st_g711u;
		else
		{
			m_audioFifo.pop_front();
			return 0;
		}

		input.data = pData;
		input.datasize = nLength;
		ps_mux_input(&input);

		m_audioFifo.pop_front();
	}
	
3、国标接入增加 根据AAC音频数据获取AAC媒体信息
	void CNetGB28181RtpServer::GetAACAudioInfo(unsigned char* nAudioData, int nLength)
	{
		if (mediaCodecInfo.nChannels == 0 && mediaCodecInfo.nSampleRate == 0)
		{
			unsigned char nSampleIndex = 1;
			unsigned char  nChannels = 1;

			nSampleIndex = ((nAudioData[2] & 0x3c) >> 2) & 0x0F;  //从 szAudio[2] 中获取采样频率的序号
			if (nSampleIndex >= 15)
				nSampleIndex = 8;
			mediaCodecInfo.nSampleRate = SampleRateArray[nSampleIndex];

			//通道数量计算 pAVData[2]  中有2个位，在最后2位，根 0x03 与运算，得到两位，左移动2位 ，再 或 上 pAVData[3] 的左边最高2位
			//pAVData[3] 左边最高2位获取方法 先 和 0xc0 与运算，再右移6位，为什么要右移6位？因为这2位是在最高位，所以要往右边移动6位
			nChannels = ((nAudioData[2] & 0x03) << 2) | ((nAudioData[3] & 0xc0) >> 6);
			if (nChannels > 2)
				nChannels = 1;
			mediaCodecInfo.nChannels = nChannels;

			strcpy(mediaCodecInfo.szAudioName, "AAC");

			WriteLog(Log_Debug, "CNetGB28181RtpServer = %X ,获取到国标接入 AAC信息 szAudioName = %s,nChannels = %d ,nSampleRate = %d ", this, mediaCodecInfo.szAudioName, mediaCodecInfo.nChannels, mediaCodecInfo.nSampleRate);
		}
	}

	
4、 调整 CNetGB28181RtpClient 类库中，对象nClient 从媒体源移除位置 
	CNetGB28181RtpClient::~CNetGB28181RtpClient()
	{
		//从媒体发送线程移除
		pMediaSendThreadPool->DeleteClientToThreadPool(nClient);

		if (netBaseNetType == NetBaseNetType_NetGB28181SendRtpUDP)
		{
			XHNetSDK_DestoryUdp(nClient);
		}
		else if (netBaseNetType == NetBaseNetType_NetGB28181SendRtpTCP_Connect)
		{
			XHNetSDK_Disconnect(nClient);
		}
		m_videoFifo.FreeFifo();
		m_audioFifo.FreeFifo();
		ps_mux_stop(psDeMuxHandle);
		rtp_packet_stop(hRtpPS);

		//从媒体拷贝线程移除
		boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(m_szShareMediaURL);
		if (pMediaSource != NULL)
			pMediaSource->DeleteClientFromMap(nClient);

ABLMediaServer-2021-08-23【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1、 json格式的数据参数，支持字符串、或者数字。
	if (jKey.IsString())
	{
		string name = jKey.GetString();
		boost::trim(name);

		nType = jValue.GetType();
		if (nType == kStringType)
		{//字符串方式
		  string value = jValue.GetString();
		  boost::trim(value);
		  strcpy(szValue, value.c_str());
		}
		else if (nType == kNumberType)
		{//数字方式 
			sprintf(szValue, "%llu", jValue.GetInt64());
		}

		RequestKeyValue* keyValue = new RequestKeyValue();
		strcpy(keyValue->key, name.c_str());
		strcpy(keyValue->value, szValue);
		requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));

		nKeyCount ++;
	}

2、 http、rtmp推流 ，http、rtmp、flv、hls 拉流 都要把删除媒体源移动到rtp\ps解包后面，否则会崩溃
 	if (hRtpVideo != 0)
	{
		rtp_packet_stop(hRtpVideo);
		hRtpVideo = 0;
	}
	if (hRtpAudio != 0)
	{
		rtp_packet_stop(hRtpAudio);
		hRtpAudio = 0;
	}
	m_videoFifo.FreeFifo();
	m_audioFifo.FreeFifo();

	//要把DeleteMediaStreamSource 移动到 后面 
	if (bPushMediaSuccessFlag && netBaseNetType == NetBaseNetType_httpServerRecvPush)
		DeleteMediaStreamSource(szMediaSourceURL);


ABLMediaServer-2021-08-22【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 申请GB28181 rtp推流时，增加payload参数 
	if (strlen(m_startSendRtpStruct.payload) == 0 || atoi(m_startSendRtpStruct.payload) < 0 )
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"payload parameter error \",\"key\":%d}", IndexApiCode_ParamError, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}

2 GB28181 PS 打包后，需要rtp打包
	if (hRtpPS == 0)
	{
		int nRet = rtp_packet_start(GB28181_rtp_packet_callback_func_send, (void*)this, &hRtpPS);
		if (nRet != e_rtppkt_err_noerror)
		{
			WriteLog(Log_Debug, "CNetGB28181RtpClient = %X ，创建视频rtp打包失败,nClient = %llu,  nRet = %d", this, nClient, nRet);
			return false;
		}
		optionPS.handle = hRtpPS;
		optionPS.mediatype = e_rtppkt_mt_video;
		optionPS.streamtype = e_rtppkt_st_gb28181;
		optionPS.ssrc = atoi(m_startSendRtpStruct.ssrc);
		optionPS.payload = atoi(m_startSendRtpStruct.payload);
		rtp_packet_setsessionopt(&optionPS);

		inputPS.handle = hRtpPS;
		inputPS.ssrc = optionPS.ssrc;

		memset((char*)&gbDstAddr, 0x00, sizeof(gbDstAddr));
		gbDstAddr.sin_family = AF_INET;
		gbDstAddr.sin_addr.s_addr = inet_addr(m_startSendRtpStruct.dst_url);
		gbDstAddr.sin_port = htons(atoi(m_startSendRtpStruct.dst_port));
	}
	
3	增加配置参数 GB28181 TCP 方式发送rtp(负载PS)码流时，包头长度选择（1： 4个字节方式，2：2个字节方式）
	GB28181RtpTCPHeadType=1
	ABL_MediaServerPort.nGBRtpTCPHeadType = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "GB28181RtpTCPHeadType", "0"));


ABLMediaServer-2021-08-21【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1	国标接入增加rtp解包
	bool  CNetGB28181RtpServer::RtpDepacket(unsigned char* pData, int nDataLength) 
	{
		if (pData == NULL || nDataLength > 1600)
			return false;

		if (hRtpHandle == 0)
		{
			 rtp_depacket_start(GB28181_rtppacket_callback_recv, (void*)this, (uint32_t*)&hRtpHandle);
			 rtp_depacket_setpayload(hRtpHandle, m_gbPayload, e_rtpdepkt_st_gbps);

			 ps_demux_start(GB28181_RtpRecv_demux_callback, (void*)this, e_ps_dux_timestamp, &psDeMuxHandle);

			 WriteLog(Log_Debug, "CNetGB28181RtpServer = %X ,创建rtp解包 hRtpHandle = %d ,psDeMuxHandle = %d",this, hRtpHandle, psDeMuxHandle);
		}

		if(hRtpHandle > 0)
		  rtp_depacket_input(hRtpHandle, pData, nDataLength);

		return true;
	}
	
2  	国标接入增加ps解包
	void PS_DEMUX_CALL_METHOD GB28181_RtpRecv_demux_callback(_ps_demux_cb* cb)
	{
		CNetGB28181RtpServer* pThis = (CNetGB28181RtpServer*)cb->userdata;
	 
		if (pThis && cb->streamtype == e_rtpdepkt_st_h264 || cb->streamtype == e_rtpdepkt_st_h265 ||
			cb->streamtype == e_rtpdepkt_st_mpeg4 || cb->streamtype == e_rtpdepkt_st_mjpeg)
		{
			if(cb->streamtype == e_rtpdepkt_st_h264)
			   pThis->pMediaSource->PushVideo(cb->data, cb->datasize, "H264");
			else if (cb->streamtype == e_rtpdepkt_st_h265)
			   pThis->pMediaSource->PushVideo(cb->data, cb->datasize, "H265");
		}
		else if (pThis)
		{
			/*/
			if (strcmp(pThis->szAudioName, "AAC") == 0)
			{//aac
				pThis->SplitterRtpAACData(cb->data, cb->datasize);
			}
			else
			{// G711A 、G711U
				pThis->pMediaSource->PushAudio(cb->data, cb->datasize, pThis->szAudioName, pThis->nChannels, pThis->nSampleRate);
			}*/
		}
	}
	
3  国标输出增加ps 打包 
	int CNetGB28181RtpClient::SendVideo()
	{
		if (psMuxHandle == 0)
		{
			memset(&init, 0, sizeof(init));
			init.cb = GB28181_Send_mux_callback;
			init.userdata = this;
			init.alignmode = e_psmux_am_4octet;
			init.ttmode = 0;
			init.ttincre = 0;
			init.h = &psMuxHandle;
			int32_t ret = ps_mux_start(&init);

			input.handle = psMuxHandle;

			WriteLog(Log_Debug, "CNetGB28181RtpClient = %X ，创建 ps 打包成功  ,nClient = %llu,  nRet = %d", this, nClient, ret);
		}

		unsigned char* pData = NULL;
		int            nLength = 0;
		if ((pData = m_videoFifo.pop(&nLength)) != NULL)
		{
			input.mediatype = e_psmux_mt_video;
			if (strcmp(mediaCodecInfo.szVideoName, "H264") == 0)
				input.streamtype = e_psmux_st_h264;
			else if (strcmp(mediaCodecInfo.szVideoName, "H265") == 0)
				input.streamtype = e_psmux_st_h265;
			else
			{
				m_videoFifo.pop_front();
				return 0;
			}

			input.data = pData;
			input.datasize = nLength;
			ps_mux_input(&input);

			m_videoFifo.pop_front();
		}
		return 0;
	}

	int CNetGB28181RtpClient::SendAudio()
	{
		if (psMuxHandle == 0)
			return 0;

		unsigned char* pData = NULL;
		int            nLength = 0;
		if ((pData = m_audioFifo.pop(&nLength)) != NULL)
		{
			input.mediatype = e_psmux_mt_audio;
			if (strcmp(mediaCodecInfo.szAudioName, "AAC") == 0)
				input.streamtype = e_psmux_st_aac;
			else if (strcmp(mediaCodecInfo.szVideoName, "G711_A") == 0)
				input.streamtype = e_psmux_st_g711a;
			else if (strcmp(mediaCodecInfo.szVideoName, "G711_U") == 0)
				input.streamtype = e_psmux_st_g711u;
			else
			{
				m_audioFifo.pop_front();
				return 0;
			}

			input.data = pData;
			input.datasize = nLength;
			ps_mux_input(&input);

			m_audioFifo.pop_front();
		}
		return 0;
	}

ABLMediaServer-2021-08-20【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 增加删除媒体流接口函数 ，可以删除代理拉流生成的媒体源，也可以删除http、rtmp推流、国标推流上来的媒体源 
	else if (strcmp(httpURL, "/index/api/delMediaStream") == 0)
	{//删除媒体源
		index_api_delRequest();
	}
	
2 完善返回系统参数配置 
	sprintf(szMediaSourceInfoBuffer, "{\"code\":0,\"params\":[{\"httpServerPort\":%d,\"memo\":\"http api port \"},{\"httpPort\":%d,\"memo\":\"http port \"},{\"rtmpPort\":%d,\"memo\":\"rtmp port \"},{\"httpFlvPort\":%d,\"memo\":\"http-flv port \"},{\"hls_enable\":%d,\"memo\":\"hls whether enable \"},{\"hlsPort\":%d,\"memo\":\"hls port\"},{\"hlsCutType\":%d,\"memo\":\"hlsCutType = 1 hls cut to Harddisk,hlsCutType = 2  hls cut Media to memory\"},{\"h265CutType\":%d,\"memo\":\" 1 h265 cut TS , 2 cut fmp4 \"},{\"RecvThreadCount\":%d,\"memo\":\" RecvThreadCount \"},{\"SendThreadCount\":%d,\"memo\":\"SendThreadCount\"},{\"rtpPacketOfhttp\":%d,\"memo\":\"http 1  rtp paylaod ES,2 rtp payload PS\"}]}",
		ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nhttpPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nHLSCutType, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nRtpPacketOfhttp);

3 	在接收http推流时，增加补充完善m_addStreamProxyStruct 结构信息，在返回媒体源时使用到 m_addStreamProxyStruct 这个结构 
    CNethttpServer::GethttpPathCount(char* szhttpURL)
	
	//合法的推流地址 ，记忆代理拉流的信息
	if (nPathCount == 2)
	{
	  memset((char*)&m_addStreamProxyStruct, 0x00, sizeof(m_addStreamProxyStruct));
	  strcpy(m_addStreamProxyStruct.url, szhttpURL);
	  
	  nPos1 = strCurhttpURL.find("//", 0);
	  if (nPos1 > 0)
	  {
		  nPos2 = strCurhttpURL.find("/", nPos1 + 2);
		  if (nPos2 > 0)
		  {
			  nPos3 = strCurhttpURL.find("/", nPos2 + 1);
			  if (nPos3 > 0)
			  {
				  memcpy(m_addStreamProxyStruct.app, szhttpURL + nPos2 + 1, nPos3 - nPos2 - 1);
				  memcpy(m_addStreamProxyStruct.stream, szhttpURL + nPos3 + 1, strlen(szhttpURL) - nPos3 - 1);
			  }
		  }
	  }
 	}

4  接收http推流过来的地址，必须是2级，否则断开推流 	
	if (nPathCount != 2)
	{//限制http推流，需要两级路径
 			WriteLog(Log_Debug, "http推流地址不符合两级的标准，需要推送类似URL: http://190.15.240.11:554/live/Camera_00001 ");
			DeleteNetRevcBaseClient(nClient);
			return false;
 	}
	
	
5  在接收rtmp推流时，//完善代理拉流结构 m_addStreamProxyStruct 在返回媒体源时使用到 m_addStreamProxyStruct 这个结构 
	 
	strcpy(pClient->m_addStreamProxyStruct.app, app);
	strcpy(pClient->m_addStreamProxyStruct.stream, stream);
	sprintf(pClient->m_addStreamProxyStruct.url, "rtmp://%s:%d/%s/%s", pClient->szClientIP, ABL_MediaServerPort.nRtmpPort, app, stream);
 
6   在获取媒体源流列表时，增加http推流，rtmp推流类型，也返回 
	if (pClient->netBaseNetType == NetBaseNetType_addStreamProxyControl || pClient->netBaseNetType == NetBaseNetType_httpServerRecvPush || pClient->netBaseNetType == NetBaseNetType_RtmpServerRecvPush)
	{//代理拉流（http,rtmp,flv,hls ）,http推流，rtmp推流，gb28181，webrtc 
		sprintf(szShareMediaURL, "/%s/%s", pClient->m_addStreamProxyStruct.app, pClient->m_addStreamProxyStruct.stream);
		boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);

		if (tmpMediaSource != NULL)
		{
		   sprintf(szTemp2, "{\"key\":%d,\"app\":\"%s\",\"stream\":\"%s\",\"sourceURL\":\"%s\",\"sourceType\":%d,\"readerCount\":%d,\"videoCodec\":\"%s\",\"audioCodec\":\"%s\",\"audioChannels\":%d,\"audioSampleRate\":%d},",pClient->nClient,pClient->m_addStreamProxyStruct.app,pClient->m_addStreamProxyStruct.stream, pClient->m_addStreamProxyStruct.url, pClient->netBaseNetType,tmpMediaSource->mediaSendMap.size(),
			   tmpMediaSource->m_mediaCodecInfo.szVideoName, tmpMediaSource->m_mediaCodecInfo.szAudioName, tmpMediaSource->m_mediaCodecInfo.nChannels, tmpMediaSource->m_mediaCodecInfo.nSampleRate);

		   strcat(szMediaSourceInfo, szTemp2);

		   nMediaCount++;
		}
	}

 7 对get 方法发送过来的http请求参数进行 替换，处理，& 会被 postman 替换成 %26 ，所以要把 %26 转换为 & 	
	bool CNetServerHTTP::SplitterTextParam(char* szTextParam)
	{//id=1000&name=luoshenzhen&address=广东深圳&age=45
		string strTextParam = szTextParam;
		int    nPos1=0, nPos2=0;
		int    nFind1,nFind2;
		int    nKeyCount = 0;
		char   szValue[1024] = { 0 };

		DeleteAllHttpKeyValue();
		string strValue;

		while (true)
		{
			nFind1 = strTextParam.find("=", nPos1);
			if (nFind1 > 0)
			{
				nFind2 = strTextParam.find("&", nPos1);
				RequestKeyValue* keyValue = new RequestKeyValue();

				memcpy(keyValue->key, szTextParam + nPos1, nFind1 - nPos1);
	 
				memset(szValue, 0x00, sizeof(szValue));
				nKeyCount++;
				if (nFind2 > 0)
				{
					memcpy(szValue, szTextParam + nFind1 + 1, nFind2 - nFind1 - 1);
					nPos1 = nFind2 + 1;

					strValue = szValue;
					replace_all(strValue, "%26", "&");
					strcpy(keyValue->value, strValue.c_str());

					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
					WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
				}
				else
				{
					memcpy(szValue, szTextParam + nFind1 + 1, strlen(szTextParam) - nFind1 - 1);
					strValue = szValue;
					replace_all(strValue, "%26", "&");

					strcpy(keyValue->value, strValue.c_str());

					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
					WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
					break;
				}
			}
			else
				break;//数据非法
		}

		return nKeyCount > 0 ? true:false ;
	}
	
	
ABLMediaServer-2021-08-19【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 优化代理拉流断线检测，重连机制代码。
	else if (((*iterator1).second)->netBaseNetType == NetBaseNetType_addStreamProxyControl)
	{//控制代理拉流,检测代理拉流是否有断线
		CNetRevcBase_ptr pClient = GetNetRevcBaseClientNoLock(((*iterator1).second)->nMediaClient);
		if (pClient == NULL)
		{//已经断线，需要重新连接 
			if (((*iterator1).second)->bRecordProxyDisconnectTimeFlag == false)
			{
			  ((*iterator1).second)->nProxyDisconnectTime = GetTickCount64();
			  ((*iterator1).second)->bRecordProxyDisconnectTimeFlag = true;
			}

			if (GetTickCount64() - ((*iterator1).second)->nProxyDisconnectTime >= 1000 * 8)
			{
				((*iterator1).second)->bRecordProxyDisconnectTimeFlag = false;
				WriteLog(Log_Debug, "nClient = %llu , nMediaClient = %llu 检测到网络异常断开，%s 需要重新连接  ", ((*iterator1).second)->nClient, ((*iterator1).second)->nMediaClient,((*iterator1).second)->m_addStreamProxyStruct.url);
				pReConnectStreamProxyFifo.push((unsigned char*)&((*iterator1).second)->nClient,sizeof(((*iterator1).second)->nClient));
			}
		}
	}

2  在代理拉流，http、rtmp推流时，创建媒体分发库时，不需要增加 nClient 到分发库 
	//创建媒体分发资源
	if (strlen(m_szShareMediaURL) > 0)
	{
		pMediaSource = CreateMediaStreamSource(m_szShareMediaURL, nClient);
 	}

3 增加http响应函数 获取媒体列表
	bool CNetServerHTTP::index_api_getMediaList()
	{
		memset((char*)&m_getMediaListStruct, 0x00, sizeof(m_getMediaListStruct));

		GetKeyValue("secret", m_getMediaListStruct.secret);
		GetKeyValue("mediaType", m_getMediaListStruct.mediaType);
	 
		if (strcmp(m_getMediaListStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, sizeof(MaxMediaSourceInfoLength));
		int nMediaCount = GetAllMediaStreamSource(szMediaSourceInfoBuffer, m_getMediaListStruct.mediaType);
		if (nMediaCount >= 0)
		{
			ResponseSuccess(szMediaSourceInfoBuffer);
		}

		return true;
	}

4 增加http响应函数 获取系统配置
	bool CNetServerHTTP::index_api_getServerConfig()
	{
		memset((char*)&m_getServerConfigStruct, 0x00, sizeof(m_getServerConfigStruct));

		GetKeyValue("secret", m_getServerConfigStruct.secret);
	 
		if (strcmp(m_getServerConfigStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		memset(szMediaSourceInfoBuffer, 0x00, sizeof(MaxMediaSourceInfoLength));
		sprintf(szMediaSourceInfoBuffer, "{\"httpServerPort\":%d,\"httpPort\":%d,\"rtmpPort\":%d,\"httpFlvPort\":%d,\"hls_enable\":%d,\"hlsPort\":%d,\"hlsCutType\":%d,\"h265CutType\":%d,\"RecvThreadCount\":%d,\"SendThreadCount\":%d,\"rtpPacketOfhttp\":%d}",
			ABL_MediaServerPort.nHttpServerPort, ABL_MediaServerPort.nhttpPort, ABL_MediaServerPort.nRtmpPort, ABL_MediaServerPort.nHttpFlvPort, ABL_MediaServerPort.nHlsEnable, ABL_MediaServerPort.nHlsPort, ABL_MediaServerPort.nH265CutType, ABL_MediaServerPort.nRecvThreadCount, ABL_MediaServerPort.nSendThreadCount, ABL_MediaServerPort.nRtpPacketOfhttp);
		ResponseSuccess(szMediaSourceInfoBuffer);

		return true;
	}
	
	
ABLMediaServer-2021-08-18【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 rtmp 、http-flv 打包时，如果音频不是 AAC ，则不加入 fifo 
	int CNetServerHTTP_FLV::PushAudio(uint8_t* pAudioData, uint32_t nDataLength, char* szAudioCodec, int nChannels, int SampleRate)
	{
		if (strlen(mediaCodecInfo.szAudioName) == 0)
		{
			strcpy(mediaCodecInfo.szAudioName, szAudioCodec);
			mediaCodecInfo.nChannels = nChannels;
			mediaCodecInfo.nSampleRate = SampleRate;
		}
		
		//如果音频不是 AAC ，则不加入 fifo  
		if (strcmp(szAudioCodec, "AAC") != 0)
			return 0;

		m_audioFifo.push(pAudioData, nDataLength);

		return 0;
	}
	
2 如果不支持的http请求，返回非法命令，不关闭连接 
 	else
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"Http Request error\",\"key\":%d}", IndexApiCode_ErrorRequest, 0);
		ResponseSuccess(szResponseBody);
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu http 请求命令非法 ，httpURL = %s", this, nClient, httpURL);
		return false;
 	}

3 更新底层rtp解包库 
   rtpdepacket.dll 

ABLMediaServer-2021-08-15【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 增加国标28181 推流类库，支持UDP、TCP 

ABLMediaServer-2021-08-14【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 优化GB代理收流部分

ABLMediaServer-2021-08-07【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1  当媒体源销毁时，需要销毁媒体提供者
	//把媒体源 提供者 加入删除链表 
	pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));

2 所以http请求删除的都统一为一个函数
	//删除所以HTTP请求 
	bool  CNetServerHTTP::index_api_delRequest()
	{
		char szShareMediaURL[256] = { 0 };

		GetKeyValue("secret", m_delRequestStruct.secret);
		GetKeyValue("key", m_delRequestStruct.key);

		if (strcmp(m_delRequestStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//检测Key 的值
		if (strlen(m_delRequestStruct.key) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient(atoi(m_delRequestStruct.key));
		if (pClient == NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key %s Not Found .\"}", IndexApiCode_KeyNotFound, m_delRequestStruct.key, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		else
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 删除Key %s 成功 ", this, nClient, m_delRequestStruct.key);
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"success\"}", IndexApiCode_OK);
			ResponseSuccess(szResponseBody);
			int64_t nDelKey = atoi(m_delRequestStruct.key);
			pDisconnectBaseNetFifo.push((unsigned char*)&nDelKey, sizeof(nDelKey));
			return true;
		}
	}

3 增加GB28181创建接收端口 
	//创建GB28181
	bool  CNetServerHTTP::index_api_openRtpServer()
	{
		char szShareMediaURL[256] = { 0 };

		GetKeyValue("secret", m_openRtpServerStruct.secret);
		GetKeyValue("vhost", m_openRtpServerStruct.vhost);
		GetKeyValue("app", m_openRtpServerStruct.app);
		GetKeyValue("stream", m_openRtpServerStruct.stream);
		GetKeyValue("port", m_openRtpServerStruct.port);
		GetKeyValue("tcp_switch", m_openRtpServerStruct.tcp_switch);

		if (strcmp(m_openRtpServerStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\",\"key\":%d}", IndexApiCode_secretError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//app ,stream 这两个字符串里面不能有 / 
		if (strstr(m_openRtpServerStruct.app, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"app parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		if (strstr(m_openRtpServerStruct.stream, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"stream parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

		int nTcp_Switch = atoi(m_openRtpServerStruct.tcp_switch);
		if ( !(nTcp_Switch >= 0 && nTcp_Switch <= 1))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"tcp_switch parameter error ,tcp_switch in [0 , 1] \",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strlen(m_openRtpServerStruct.app) > 0 && strlen(m_openRtpServerStruct.stream) > 0 )
		{
			//检测 app stream 是否存在
			sprintf(szShareMediaURL, "/%s/%s", m_openRtpServerStruct.app, m_openRtpServerStruct.stream);
			boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);
			if (tmpMediaSource != NULL)
			{
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s Already exists \",\"key\":%d}", IndexApiCode_ParamError, szShareMediaURL, 0);
				ResponseSuccess(szResponseBody);
				return false;
			}

			/*
			boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetRevcBaseClient_addStreamProxyControl, 0, 0, "", 0, szShareMediaURL);
			if (pClient != NULL)
			{
				memcpy((char*)&pClient->m_openRtpServerStruct, (char*)&m_openRtpServerStruct, sizeof(addStreamProxyStruct));
				sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"key\":%d}", pClient->nClient);
				ResponseSuccess(szResponseBody);

				pClient->SendFirstRequst();//执行第一个命令
			}*/
		}
		else
		{//参数错误 
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"parameter error\",\"key\":0}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		return true;
	}

ABLMediaServer-2021-08-06【增加支持(http rtmp flv)代理拉流、（http、rtmp）代理推流 稳定版本】
1 rtmp推流时，必须等等到rtmp交换完毕 ，否则会报错 
	if (pClient->bAddMediaSourceFlag == false)
	{
		pClient->nRtmpState = rtmp_client_getstate(pClient->rtmp);
		if (pClient->nRtmpState == 3)
			pClient->nRtmpState3Count ++;

		WriteLog(Log_Debug, "rtmp_client_pushCB  nRtmpState = %d ", pClient->nRtmpState);
		if (pClient->nRtmpState3Count >= 2)
		{
			pClient->bAddMediaSourceFlag = true;
			boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource(pClient->m_szShareMediaURL);
			if (pMediaSource != NULL)
			{
				pMediaSource->AddClientToMap(pClient->nClient);
				WriteLog(Log_Debug, "rtmp_client_pushCB  把rtmp推流 = %llu ，加入媒体源分发库 ", pClient->nClient);
			}
			else
			{
				WriteLog(Log_Debug, "rtmp_client_pushCB 不存在媒体源 %s ，立即删除 nClient = %llu ", pClient->m_szShareMediaURL,pClient->nClient);
				pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
			}
		}
	}

ABLMediaServer-2021-08-04【增加支持(http rtmp flv)代理拉流稳定版本】
1 http拉流增加发送大华摄像机rtcp接收者报告包

   //发送rtcp包
   if (((*iterator1).second)->netBaseNetType == NetBaseNetType_httpClientRecv)
   {
	   CNetClientRecvhttp* phttpClient = (CNetClientRecvhttp*) (*iterator1).second.get();
	   if (phttpClient->bSendRRReportFlag)
	   {
		   if (GetTickCount64() - phttpClient->nCurrentTime >= 1000*3)
		   {
			   phttpClient->SendRtcpReportData();
		   }
	  }
   }

2  在代理拉流时，切割json参数时，增加去掉空格代码
	//去掉空格 
	boost::trim(name);
	boost::trim(value);
   
3 拉流时的rtp打包方式，1为 rtp 负载 ES流 ， 2为rtp负载 PS 流 
   rtpPacketOfhttp=1
   
	void PS_DEMUX_CALL_METHOD NetClienthttpRecv_demux_callback(_ps_demux_cb* cb)
	{
		CNetClientRecvhttp* pThis = (CNetClientRecvhttp*)cb->userdata;
		//WriteLog(Log_Debug, "cb->type = %d ,Length =%d ", cb->streamtype,cb->datasize);

		if (pThis && cb->streamtype == e_rtpdepkt_st_h264 || cb->streamtype == e_rtpdepkt_st_h265 ||
			cb->streamtype == e_rtpdepkt_st_mpeg4 || cb->streamtype == e_rtpdepkt_st_mjpeg)
		{
			pThis->pMediaSource->PushVideo(cb->data, cb->datasize, pThis->szVideoName);
		}
		else if (pThis)
		{
			if (strcmp(pThis->szAudioName, "AAC") == 0)
			{//aac
				pThis->SplitterRtpAACData(cb->data, cb->datasize);
			}
			else
			{// G711A 、G711U
				pThis->pMediaSource->PushAudio(cb->data, cb->datasize, pThis->szAudioName, pThis->nChannels, pThis->nSampleRate);
			}
		}
	}

   
ABLMediaServer-2021-08-03【增加支持(http rtmp flv)代理拉流稳定版本】
1 删除掉代理拉流的2级限制，拉流地址，不需要两级限制
 
	string strURL = m_addStreamProxyStruct.url;
	int    nSubPathCount = 0 ,nPos=10;
	while (true)
	{
		nPos = strURL.find("/", nPos);
		if (nPos > 0)
		{
			nSubPathCount++;
			nPos += 1;
		}
		else
			break;
	}


ABLMediaServer-2021-08-01【增加支持(http rtmp flv)代理拉流稳定版本】
1 增加查询推流地址是否存在
 
	bool  QueryMediaSource(char* pushURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		bool   bFind = false ;
		CNetRevcBase_ptr   pClient = NULL;

		for(iterator1 = xh_ABLNetRevcBaseMap.begin();iterator1 != xh_ABLNetRevcBaseMap.end(); iterator1++)
		{
			pClient = (*iterator1).second;
			if (pClient->netBaseNetType == NetBaseNetType_addStreamProxyControl)
			{
				if (strcmp(pushURL, pClient->m_addPushProxyStruct.url) == 0)
				{
					bFind = true;
					WriteLog(Log_Debug, "QueryMediaSource() 推流地址已经存在 url = %s ", pushURL);
					break;
				}
			}
		}
		return bFind;
	}
	
2  增加推流函数
	//增加代理http\rtmp 推流 
	bool CNetServerHTTP::index_api_addPushProxy()
	{
		char szShareMediaURL[256] = { 0 };

		GetKeyValue("secret", m_addPushProxyStruct.secret);
		GetKeyValue("vhost", m_addPushProxyStruct.vhost);
		GetKeyValue("app", m_addPushProxyStruct.app);
		GetKeyValue("stream", m_addPushProxyStruct.stream);
		GetKeyValue("url", m_addPushProxyStruct.url);

		if (strcmp(m_addPushProxyStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\",\"key\":%d}", IndexApiCode_secretError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//app ,stream 这两个字符串里面不能有 / 
		if (strstr(m_addPushProxyStruct.app, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"app parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		if (strstr(m_addPushProxyStruct.stream, "/") != NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"stream parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (!(memcmp(m_addPushProxyStruct.url, "http://", 7) == 0 || memcmp(m_addPushProxyStruct.url, "rtmp://", 7) == 0 || memcmp(m_addStreamProxyStruct.url, "http://", 7) == 0))
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"url parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}

		if (strlen(m_addPushProxyStruct.app) > 0 && strlen(m_addPushProxyStruct.stream) > 0 && strlen(m_addPushProxyStruct.url) > 0)
		{
			//检测 app stream 是否存在
			sprintf(szShareMediaURL, "/%s/%s", m_addPushProxyStruct.app, m_addPushProxyStruct.stream);
			boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);
			if (tmpMediaSource == NULL)
			{
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s Not Found \",\"key\":%d}", IndexApiCode_ParamError, szShareMediaURL, 0);
				ResponseSuccess(szResponseBody);
				return false;
			}

			//判断是否已经推流过
			if (QueryMediaSource(m_addPushProxyStruct.url))
			{
				sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"url: %s Already exists \",\"key\":%d}", IndexApiCode_ParamError, m_addPushProxyStruct.url, 0);
				ResponseSuccess(szResponseBody);
				return false;
			}

			boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetRevcBaseClient_addPushProxyControl, 0, 0, m_addPushProxyStruct.url, 0, szShareMediaURL);
			if (pClient != NULL)
			{
				memcpy((char*)&pClient->m_addPushProxyStruct, (char*)&m_addPushProxyStruct, sizeof(m_addPushProxyStruct));
				sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"key\":%d}", pClient->nClient);
				ResponseSuccess(szResponseBody);

				pClient->SendFirstRequst();//执行第一个命令
			}
		}
		else
		{//参数错误 
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"parameter error\",\"key\":0}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}
		return true;
	}

3  增加删除推流函数 	
	bool CNetServerHTTP::index_api_delPushProxy()
	{
		char szShareMediaURL[256] = { 0 };

		GetKeyValue("secret", m_delPushProxyStruct.secret);
		GetKeyValue("key", m_delPushProxyStruct.key);

		if (strcmp(m_delPushProxyStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//检测Key 的值
		if (strlen(m_delPushProxyStruct.key) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient(atoi(m_delPushProxyStruct.key));
		if (pClient == NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key %s Not Found .\"}", IndexApiCode_KeyNotFound, m_delPushProxyStruct.key, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		else
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 删除Key %s 成功 ", this, nClient, m_delPushProxyStruct.key);
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"success\"}", IndexApiCode_OK);
			ResponseSuccess(szResponseBody);
			int64_t nDelKey = atoi(m_delPushProxyStruct.key);
			pDisconnectBaseNetFifo.push((unsigned char*)&nDelKey, sizeof(nDelKey));
			return true;
		}
	}
	
4 	增加url2级别检测
	string strURL = m_addStreamProxyStruct.url;
	int    nSubPathCount = 0 ,nPos=10;
	while (true)
	{
		nPos = strURL.find("/", nPos);
		if (nPos > 0)
		{
			nSubPathCount++;
			nPos += 1;
		}
		else
			break;
	}	
	
5   rtmp推流打包时，需要丢弃 sps\pps 帧，因为I帧里面包含有
	if (nDataLength < 2048)
	{
		if (CheckVideoIsIFrame(szVideoCodec, pVideoData, nDataLength))
		{
			WriteLog(Log_Debug, "CNetClientSendRtmp = %X SPS\PPS nClient = %llu nDataLength = %d \r\n", this, nClient, nDataLength);
			return 0;
		}
	}
	

ABLMediaServer-2021-07-31【增加支持(http rtmp flv)代理拉流稳定版本】
1 增加http推流 

ABLMediaServer-2021-07-30【增加支持(http rtmp flv)代理拉流稳定版本】
1 优化rtmp推流、拉流包头简单判断，否则有连接乱连1935，乱发数据，就会造成程序奔溃 
	#if   1  //增加条件 || (pData[0] == 0x03 ) ，否则obs推流不上来
		if (!bCheckhttpVersionFlag)
		{
			bCheckhttpVersionFlag = true;
			if ( !((pData[0] == 0x03 && pData[1] == 0x00 && pData[2] == 0x00 && pData[3] == 0x00 && pData[4] == 0x00) || (pData[0] == 0x03 )))
			{//简单检测包头是否合法，是否符合rtmp协议
				DeleteNetRevcBaseClient(nClient);
				return -1;
			}
		}
	#endif 

2  增加HLS模块合法性检测，如果不是发GET 命令则立即删除连接 
	int CNetServerHLS::ProcessNetData()
	{
		if (ReadHttpRequest() == false )
		{
			WriteLog(Log_Debug, "CNetServerHLS = %X ,nClient = %llu , 数据尚未接收完整 ",this,nClient);
			if (memcmp(netDataCache, "GET ", 4) != 0)
			{
				WriteLog(Log_Debug, "CNetServerHLS = %X , nClient = %llu , 接收的数据非法 ",this, nClient);
				DeleteNetRevcBaseClient(nClient);
			}
			return -1;
		}
		
3 增加FLV模块合法性检测，如果不是发GET 命令则立即删除连接 
	int CNetServerHTTP_FLV::ProcessNetData()
	{
		if (!bFindFlvNameFlag)
		{
			if (strstr((char*)netDataCache, "\r\n\r\n") == NULL)
			{
				WriteLog(Log_Debug, "数据尚未接收完整 ");
				if (memcmp(netDataCache, "GET ", 4) != 0)
				{
					WriteLog(Log_Debug, "CNetServerHTTP_FLV = %X , nClient = %llu , 接收的数据非法 ", this, nClient);
					DeleteNetRevcBaseClient(nClient);
				}
				return -1;
			}
		}

4 http 命令操作类增加合法性检测
	int CNetServerHTTP::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(NetServerHTTPLock);
		int nHttpHeadEndPos = CheckHttpHeadEnd();

		if ( !(memcmp(netDataCache, "GET ", 4) == 0 || memcmp(netDataCache, "POST ", 5) == 0))
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X , nClient = %llu , 接收的数据非法 ", this, nClient);
			DeleteNetRevcBaseClient(nClient);
		}
	
5 http请求代理拉流时，对url合法性进行简单检测		
	if (!( memcmp(m_addStreamProxyStruct.url,"http://",7) == 0 || memcmp(m_addStreamProxyStruct.url, "rtmp://", 7) == 0 || memcmp(m_addStreamProxyStruct.url, "http://", 7) == 0 ) )
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"url parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}

6   代理拉流重连时间调整为1秒 
	if (nReConnectStreamProxyTimer >= 10)
	{
		nReConnectStreamProxyTimer = 0;
		while ((pData = pReConnectStreamProxyFifo.pop(&nLength)) != NULL)
		{
			if (nLength == sizeof(nClient))
			{
				memcpy((char*)&nClient, pData, sizeof(nClient));
				if (nClient > 0)
				{
					CNetRevcBase_ptr pClient = GetNetRevcBaseClient(nClient);
					if (pClient)
						pClient->SendFirstRequst(); //执行重连
				}
			}

			pReConnectStreamProxyFifo.pop_front();
		}
	}	
		
ABLMediaServer-2021-07-29【彻底解决fmp4切片，AAC声音也正常】
1 解决CNetServerHttp 类库里面的一个死循环
	//对get 方式的参数进行切割
	bool CNetServerHTTP::SplitterTextParam(char* szTextParam)
	{//id=1000&name=luoshenzhen&address=广东深圳&age=45
		string strTextParam = szTextParam;
		int    nPos1=0, nPos2=0;
		int    nFind1,nFind2;
		int    nKeyCount = 0;

		DeleteAllHttpKeyValue();

		while (true)
		{
			nFind1 = strTextParam.find("=", nPos1);
			if (nFind1 > 0)
			{
				nFind2 = strTextParam.find("&", nPos1);
				RequestKeyValue* keyValue = new RequestKeyValue();

				memcpy(keyValue->key, szTextParam + nPos1, nFind1 - nPos1);
				nKeyCount++;
				if (nFind2 > 0)
				{
					memcpy(keyValue->value, szTextParam + nFind1 + 1, nFind2 - nFind1 - 1);
					nPos1 = nFind2 + 1;

					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
					WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
				}
				else
				{
					memcpy(keyValue->value, szTextParam + nFind1 + 1, strlen(szTextParam) - nFind1 - 1);
					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
					WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
					break;
				}
			}
			else
				break;//数据非法 【数据非法，要退出，否则造成死循环 】
		}

		return nKeyCount > 0 ? true:false ;
	}
	
2 把处理代理拉流封装成一个函数
	//执行请求拉流
	bool  CNetServerHTTP::index_api_addStreamProxy()
	{
		char szShareMediaURL[256] = { 0 };

		GetKeyValue("secret", m_addStreamProxyStruct.secret);
		GetKeyValue("vhost", m_addStreamProxyStruct.vhost);
		GetKeyValue("app", m_addStreamProxyStruct.app);
		GetKeyValue("stream", m_addStreamProxyStruct.stream);
		GetKeyValue("url", m_addStreamProxyStruct.url);

		if (strcmp(m_addStreamProxyStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			ResponsePasswordInvalid();
			return false;
		}

		if (strlen(m_addStreamProxyStruct.app) > 0 && strlen(m_addStreamProxyStruct.stream) > 0 && strlen(m_addStreamProxyStruct.url) > 0)
		{
			sprintf(szShareMediaURL, "/%s/%s", m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);
			boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetRevcBaseClient_addStreamProxyControl, 0, 0, m_addStreamProxyStruct.url, 0, szShareMediaURL);
			if (pClient != NULL)
			{
				memcpy((char*)&pClient->m_addStreamProxyStruct, (char*)&m_addStreamProxyStruct, sizeof(addStreamProxyStruct));
				sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"key\":%d}", pClient->nClient);
				ResponseSuccess(szResponseBody);

				pClient->SendFirstRequst();//执行第一个命令
			}
		}
		else
		{//参数错误 
			strcpy(szResponseBody, "{\"code\":1,\"memo\":\"参数错误\",\"key\":0}");
			ResponseSuccess(szResponseBody);
		}

		return true;
	}

3 分别给各个拉流指定类型，	
	//主动拉流对象
	NetBaseNetType_httpClientRecv          = 20 ,//http主动拉流对象 
	NetBaseNetType_RtmpClientRecv          = 21 ,//rtmp主动拉流对象 
	NetBaseNetType_HttpFlvClientRecv       = 22 ,//http-flv主动拉流对象 
	NetBaseNetType_HttpHLSClientRecv       = 23 ,//http-hls主动拉流对象 

	netBaseNetType = NetBaseNetType_httpClientRecv; 
	netBaseNetType = NetBaseNetType_RtmpClientRecv; 
	netBaseNetType = NetBaseNetType_HttpFlvClientRecv; 
	netBaseNetType = NetBaseNetType_HttpHLSClientRecv; 

3 	代理拉流中 两个参数 app ,stream 这两个字符串里面不能有 / ，否则会出现3级以上的rtmp\flv URL ，现在只支持2级 /Media/Camera_0001 
	
	if (strstr(m_addStreamProxyStruct.app, "/") != NULL)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"app parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
		ResponseSuccess(szResponseBody);
		return false;
 	}
	if (strstr(m_addStreamProxyStruct.stream, "/") != NULL)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"stream parameter error\",\"key\":%d}", IndexApiCode_ParamError, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}
	
4  增加检测 app stream 是否存在
	sprintf(szShareMediaURL, "/%s/%s", m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);
	boost::shared_ptr<CMediaStreamSource> tmpMediaSource = GetMediaStreamSource(szShareMediaURL);
	if (tmpMediaSource != NULL)
	{
		sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"MediaSource: %s Already exists \",\"key\":%d}", IndexApiCode_ParamError, szShareMediaURL, 0);
		ResponseSuccess(szResponseBody);
		return false;
	}
	
5 增加4个类型的代理拉流 断线检测功能，如果发现没有码流，立即删除 

	((*iterator1).second)->netBaseNetType == NetBaseNetType_httpClientRecv ||      //代理接收http推流
	((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpClientRecv ||      //代理接收Rtmp推流
	((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpFlvClientRecv ||   //代理接收HttpFlv推流
	((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSClientRecv      //代理接收HttpHLS推流
	
6  代理拉流重连
	while ((pData = pReConnectStreamProxyFifo.pop(&nLength)) != NULL)
	{
		if (nLength == sizeof(nClient))
		{
			memcpy((char*)&nClient, pData, sizeof(nClient));
			if (nClient > 0)
			{
				CNetRevcBase_ptr pClient = GetNetRevcBaseClient(nClient);
				if (pClient)
					pClient->SendFirstRequst(); //执行重连
			}
		}

		pReConnectStreamProxyFifo.pop_front();
	}
	
7  删除代理拉流
	bool  CNetServerHTTP::index_api_delStreamProxy()
	{
		char szShareMediaURL[256] = { 0 };

		GetKeyValue("secret", m_delStreamProxyStruct.secret);
		GetKeyValue("key", m_delStreamProxyStruct.key);

		if (strcmp(m_delStreamProxyStruct.secret, ABL_MediaServerPort.secret) != 0)
		{//密码检测
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"secret error\"}", IndexApiCode_secretError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		//检测Key 的值
		if (strlen(m_delStreamProxyStruct.key) == 0)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key parameter error\"}", IndexApiCode_ParamError);
			ResponseSuccess(szResponseBody);
			return false;
		}

		boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient(atoi(m_delStreamProxyStruct.key));
		if (pClient == NULL)
		{
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"key %s Not Found .\"}", IndexApiCode_KeyNotFound, m_delStreamProxyStruct.key, 0);
			ResponseSuccess(szResponseBody);
			return false;
		}
		else
		{
			WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 删除Key %s 成功 ", this, nClient, m_delStreamProxyStruct.key);
			sprintf(szResponseBody, "{\"code\":%d,\"memo\":\"success\"}", IndexApiCode_OK);
			ResponseSuccess(szResponseBody);
			DeleteNetRevcBaseClient(atoi(m_delStreamProxyStruct.key));
			return true;
		}
	}
		
ABLMediaServer-2021-07-28【彻底解决fmp4切片，AAC声音也正常】
1 增加从rtmp的url里面获取app \ stream 
	bool   CNetClientRecvRtmp::GetAppStreamByURL(char* app, char* stream)
	{
		int nPos1, nPos2;
		if (memcmp(szClientIP, "rtmp://", 7) != 0)
			return false;
		string strURL = szClientIP;
		nPos1 = strURL.find("/", 8);
		if (nPos1 > 0)
		{
			nPos2 = strURL.find("/", nPos1 + 1);
			if (nPos2 > 0)
			{
				memcpy(app, szClientIP + nPos1 + 1, nPos2 - nPos1 - 1);
				memcpy(stream, szClientIP + nPos2 + 1, strlen(szClientIP) - nPos2 - 1);
				return true;
			}
			else
				return false;
		}else 
		  return true;
	}
	
2 增加http操作时，密码验证功能 
   secret=035c73f7-bb6b-4889-a715-d9eb2d1925cc
	if (strcmp(m_addStreamProxyStruct.secret, ABL_MediaServerPort.secret) != 0)
	{//密码检测
		ResponsePasswordInvalid();
		return false;
	}	
	
3 增加回复密码错误
	bool  CNetServerHTTP::ResponsePasswordInvalid()
	{
		WriteLog(Log_Debug, "CNetServerHTTP = %X  nClient = %llu 操作密码错误 secret = %s ", this, nClient, m_addStreamProxyStruct.secret);
		sprintf(szResponseHttpHead, "HTTP/1.0 401 Unauthorized\r\nServer: %s\r\nContent-Type: text/html;charset=utf-8\r\nAccess-Control-Allow-Origin: *\r\n\r\n", MediaServerVerson);
		XHNetSDK_Write(nClient, (unsigned char*)szResponseHttpHead, strlen(szResponseHttpHead), 1);
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		return true;
	}
	
4 回复成功信息
	bool  CNetServerHTTP::ResponseSuccess(char* szSuccessInfo)
	{
		int nLength = strlen(szSuccessInfo);
		sprintf(szResponseHttpHead, "HTTP/1.0 200 OK\r\nServer: %s\r\nContent-Type: text/html;charset=utf-8\r\nAccess-Control-Allow-Origin: *\r\nContent-Length: %d\r\n\r\n", MediaServerVerson, nLength);
		XHNetSDK_Write(nClient, (unsigned char*)szResponseHttpHead, strlen(szResponseHttpHead), 1);
		XHNetSDK_Write(nClient, (unsigned char*)szSuccessInfo, nLength, 1);
		return true;
	}

5  采用代理方式来创建http\rtmp\flv拉流 ，方便断线重连、http发送断开命令控制等等	
	sprintf(szShareMediaURL, "/%s/%s", m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);
	boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetRevcBaseClient_addStreamProxyControl, 0, 0, m_addStreamProxyStruct.url, 0, szShareMediaURL);
	if (pClient != NULL)
	{
		memcpy((char*)&pClient->m_addStreamProxyStruct, (char*)&m_addStreamProxyStruct, sizeof(addStreamProxyStruct));
		sprintf(szResponseBody, "{\"code\":0,\"memo\":\"success\",\"key\":%d}", pClient->nClient);
		ResponseSuccess(szResponseBody);

		pClient->SendFirstRequst();//执行第一个命令
	}
	
6   对json数据进行切割
	bool CNetServerHTTP::SplitterJsonParam(char* szJsonParam)
	{
		int    nKeyCount = 0;
		if (szJsonParam == NULL || strlen(szJsonParam) == 0)
			return false;

		DeleteAllHttpKeyValue();

		if (szJsonParam[0] != '{' || szJsonParam[strlen(szJsonParam) - 1] != '}')
			return false;

		string strJsonTest = szJsonParam;
		Document docTest;
		docTest.Parse<0>(strJsonTest.c_str());

		if (!docTest.HasParseError())
		{
			for (rapidjson::Value::ConstMemberIterator itr = docTest.MemberBegin(); itr != docTest.MemberEnd(); itr++)
			{
				Value jKey;
				Value jValue;
				Document::AllocatorType allocator;
				jKey.CopyFrom(itr->name, allocator);
				jValue.CopyFrom(itr->value, allocator);
				if (jKey.IsString())
				{
					string name = jKey.GetString();
					string value = jValue.GetString();

					RequestKeyValue* keyValue = new RequestKeyValue();
					//printf("name: %s value: %s \r\n", name.c_str(), value.c_str());
					strcpy(keyValue->key, name.c_str());
					strcpy(keyValue->value, value.c_str());
					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));

					nKeyCount ++;
				}
			}
		}

		return nKeyCount > 0 ? true : false;
	}	

ABLMediaServer-2021-07-27【彻底解决fmp4切片，AAC声音也正常】
1 在每个类的构造函数增加一个参数，分享的URL
	CNetClientRecvRtmp(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort, char* szShareMediaURL);
	
2 对get 方式的参数进行切割
	bool CNetServerHTTP::SplitterTextParam(char* szTextParam)
	{//id=1000&name=luoshenzhen&address=广东深圳&age=45
		string strTextParam = szTextParam;
		int    nPos1=0, nPos2=0;
		int    nFind1,nFind2;
		int    nKeyCount = 0;

		DeleteAllHttpKeyValue();

		while (true)
		{
			nFind1 = strTextParam.find("=", nPos1);
			if (nFind1 > 0)
			{
				nFind2 = strTextParam.find("&", nPos1);
				RequestKeyValue* keyValue = new RequestKeyValue();

				memcpy(keyValue->key, szTextParam + nPos1, nFind1 - nPos1);
				nKeyCount ++;
				if (nFind2 > 0)
				{
					memcpy(keyValue->value, szTextParam + nFind1 + 1, nFind2 - nFind1 - 1);
					nPos1 = nFind2 + 1;

					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
					WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
				}
				else
				{
					memcpy(keyValue->value, szTextParam + nFind1 + 1, strlen(szTextParam) - nFind1 - 1);
					requestKeyValueMap.insert(RequestKeyValueMap::value_type(keyValue->key, keyValue));
					WriteLog(Log_Debug, "CNetServerHTTP =%X  nClient = %llu 获取HTTP请求参数 szKey = %s ,szValue = %s", this, nClient, keyValue->key, keyValue->value);
					break;
				}
			}
		}

		return nKeyCount > 0 ? true:false ;
	}

3 响应http请求
	bool CNetServerHTTP::ResponseHttpRequest(char* szModem, char* httpURL, char* requestParam)
	{
		char szShareMediaURL[256] = { 0 };
		if (strcmp(szModem, "GET") == 0)
		{
			SplitterTextParam(requestParam);
		}
		else if (strcmp(szModem, "POST") == 0)
		{

		}
		else
			return false;

		if (strcmp(httpURL, "/index/api/addStreamProxy") == 0)
		{//请求主动拉流
			GetKeyValue("secret", m_addStreamProxyStruct.secret);
			GetKeyValue("vhost", m_addStreamProxyStruct.vhost);
			GetKeyValue("app", m_addStreamProxyStruct.app);
			GetKeyValue("stream", m_addStreamProxyStruct.stream);
			GetKeyValue("url", m_addStreamProxyStruct.url);

			if (strlen(m_addStreamProxyStruct.app) > 0 && strlen(m_addStreamProxyStruct.stream) > 0 && strlen(m_addStreamProxyStruct.url) > 0)
			{
				sprintf(szShareMediaURL, "/%s/%s", m_addStreamProxyStruct.app, m_addStreamProxyStruct.stream);
				boost::shared_ptr<CNetRevcBase> pClient = CreateNetRevcBaseClient(NetRevcBaseClient_addStreamProxy, 0, 0, m_addStreamProxyStruct.url, 0, szShareMediaURL);
				if (pClient != NULL)
					memcpy((char*)&pClient->m_addStreamProxyStruct, (char*)&m_addStreamProxyStruct, sizeof(addStreamProxyStruct));
			}
		}

		return true;
	}
	
4 修改	CreateNetRevcBaseClient 函数 ，增加两个变量 NetRevcBaseClientType netClientType \ char* szShareMediaURL
	CNetRevcBase_ptr CreateNetRevcBaseClient(NetRevcBaseClientType netClientType,NETHANDLE serverHandle, NETHANDLE CltHandle,char* szIP,unsigned short nPort,char* szShareMediaURL)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptr pXHClient = NULL;
		try
		{
			do
			{
				if (netClientType == NetRevcBaseClient_ServerAccept)
				{
					if (serverHandle == srvhandle_8080)
						pXHClient = boost::make_shared<CNetServerHTTP>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
					else if (serverHandle == srvhandle_554)
						pXHClient = boost::make_shared<CNethttpServer>(serverHandle, CltHandle,szIP,nPort, szShareMediaURL);
					else if (serverHandle == srvhandle_1935)
						pXHClient = boost::make_shared<CNetRtmpServerRecv>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
					else if (serverHandle == srvhandle_8088)
						pXHClient = boost::make_shared<CNetServerHTTP_FLV>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
					else if (serverHandle == srvhandle_9088)
						pXHClient = boost::make_shared<CNetServerHLS>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
				}else if(netClientType == NetRevcBaseClient_addStreamProxy)
				{//代理拉流
					if (memcmp(szIP, "http://", 7) == 0 && strstr(szIP,".m3u8") != NULL )
					{//hls
						//在构造函数进行异步连接，会产生一个nClient值 
						pXHClient = boost::make_shared<CNetClientRecvHttpHLS>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
						CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
	#if  0
						CreateMediaStreamSource("/Media/Camera_00002", CltHandle);
	#endif
					}
					else if (memcmp(szIP, "http://", 7) == 0 && strstr(szIP, ".flv") != NULL)
					{//flv 
						pXHClient = boost::make_shared<CNetClientRecvFLV>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
						CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
	#if  0
						CreateMediaStreamSource("/Media/Camera_00002", CltHandle);
	#endif
					}
					else if (memcmp(szIP, "http://", 7) == 0 )
					{//http 
						pXHClient = boost::make_shared<CNetClientRecvhttp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
						CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
					}
					else if (memcmp(szIP, "rtmp://", 7) == 0 )
					{//rtmp
						pXHClient = boost::make_shared<CNetClientRecvRtmp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
						CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
	#if  0
						pXHClient = boost::make_shared<CNetClientSendRtmp>(serverHandle, CltHandle, szIP, nPort, szShareMediaURL);
						CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
	#endif

	#if  0
						CreateMediaStreamSource("/Media/Camera_00002", CltHandle);
	#endif
					}else 
					  return NULL;
				}
				else if (netClientType == NetRevcBaseClient_addPushStreamProxy)
				{

				}
			} while (pXHClient == NULL);
		}
		catch (const std::exception &e)
		{
			return NULL;
		}

		std::pair<boost::unordered_map<NETHANDLE, CNetRevcBase_ptr>::iterator, bool> ret =
			xh_ABLNetRevcBaseMap.insert(std::make_pair(CltHandle, pXHClient));
		if (!ret.second)
		{
			pXHClient.reset();
			return NULL;
		}

		return pXHClient;
	}

ABLMediaServer-2021-07-26【彻底解决fmp4切片，AAC声音也正常】
1 http拉流库增加md5验证
	//需要MD5验证
	if (memcmp(pRecvData, "http/1.0 401", 12) == 0)
	{
	   if (!GetWWW_Authenticate())
		 return;

	   SendDescribe(AuthenticateType);
	   return ;
	}

2 http服务器，切割号请求命令、参数、方法（POST，GET） 等等
	int CNetServerHTTP::ProcessNetData()
	{
	std::lock_guard<std::mutex> lock(NetServerHTTPLock);
	int nHttpHeadEndPos = CheckHttpHeadEnd();

	if (nHttpHeadEndPos < 0 )
		return -1;

	memset(szHttpHead, 0x00, sizeof(szHttpHead));
	memcpy(szHttpHead, netDataCache + nNetStart, nHttpHeadEndPos - nNetStart + 4 );
	httpParse.ParseSipString(szHttpHead);

	nContent_Length = 0;
	memset(szContentLength, 0x00, sizeof(szContentLength));
	if (httpParse.GetFieldValue("Content-Length", szContentLength))
	{//POST 
		nContent_Length = atoi(szContentLength);
		if (netDataCacheLength - (nHttpHeadEndPos + 4) < nContent_Length || nContent_Length <= 0 )
			return -2;//数据尚未接收完整 

		memset(szHttpPath, 0x00, sizeof(szHttpPath));
		if (httpParse.GetFieldValue("POST", szHttpPath) == false)
		{
			WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误 nClient = %llu ", this, nClient);
			DeleteNetRevcBaseClient(nClient);
			return -3;
		}

		//去掉HTTP 1.1 
		string strHttpPath = szHttpPath;
		int    nPos;
		nPos = strHttpPath.find(" HTTP", 0);
		if (nPos > 0)
			szHttpPath[nPos] = 0x00;

		//去掉？号后面的参数
		strHttpPath = szHttpPath;
		nPos = strHttpPath.find("?", 0);
		if (nPos > 0)
			szHttpPath[nPos] = 0x00;

		memset(szHttpBody, 0x00, sizeof(szHttpBody));
		memcpy(szHttpBody, netDataCache + nHttpHeadEndPos + 4, nContent_Length);

		ResponseHttpRequest("POST", szHttpPath, szHttpBody);
	}
	else
	{
		memset(szHttpPath, 0x00, sizeof(szHttpPath));
		memset(szHttpBody, 0x00, sizeof(szHttpBody));
		
		if (httpParse.GetFieldValue("GET", szHttpPath) == false)
		{
			WriteLog(Log_Debug, "CNetServerHTTP =%X 协议错误 nClient = %llu ", this, nClient);
			DeleteNetRevcBaseClient(nClient);
			return -3;
		}
		//去掉HTTP 1.1 
		string strHttpPath = szHttpPath;
		int    nPos;
		nPos = strHttpPath.find(" HTTP", 0);
		if (nPos > 0)
			szHttpPath[nPos] = 0x00;

		//去掉？号,把?后面buffer，作为参数
		strHttpPath = szHttpPath;
		nPos = strHttpPath.find("?", 0);
		if (nPos > 0)
		{
			memcpy(szHttpBody, szHttpPath + nPos + 1, strlen(szHttpPath) - nPos - 1);
			szHttpPath[nPos] = 0x00;
		}

		ResponseHttpRequest("GET", szHttpPath, szHttpBody);
	}

	//把剩余的buff往前移动 
	netDataCacheLength = netDataCacheLength - (nHttpHeadEndPos + 4 + nContent_Length);
	if (netDataCacheLength > 0)
	{
		memmove(netDataCache, netDataCache + (nHttpHeadEndPos + 4 + nContent_Length), netDataCacheLength);
		nNetStart = 0;
		nNetEnd = netDataCacheLength;
	}else
		nNetStart = nNetEnd = netDataCacheLength = 0;

	return 0;
	}

ABLMediaServer-2021-07-25【彻底解决fmp4切片，AAC声音也正常】
1 增加http拉流客户端，为主动拉流做准备 

2 增加http服务器类库 ，为http服务器做准备 

ABLMediaServer-2021-07-23【彻底解决fmp4切片，AAC声音也正常】
1  rtmp 服务器，支持H265推流 

	static int rtmp_server_onvideo(void* param, const void* data, size_t bytes, uint32_t timestamp)
	{//写入视频 
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
		{
			if (flv_demuxer_input(pClient->flvDemuxer, FLV_TYPE_VIDEO, data, bytes, timestamp) < 0)
			{
				if (!pClient->bDeleteRtmpPushH265Flag)
				{
					//pClient->bDeleteRtmpPushH265Flag = true;
					//WriteLog(Log_Debug, "不支持rtmp推送 H265视频【rtmp推流只支持视频H264、音频AAC】，如果要推送H265视频，建议使用http推流。准备删除rtmp推流链接 nClient = %llu ", pClient->nClient);
					//pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
				}
				return 0;
			}
		}

2  增加rtmp推流客户端类库 NetClientSendRtmp.h \ NetClientSendRtmp.cpp ,测试过推送H264\H265正常  

ABLMediaServer-2021-07-22【彻底解决fmp4切片，AAC声音也正常】
1 恢复flv 265的解码 ，否则rtmp ,flv 拉流时，视频H265不支持 
	else if (FLV_VIDEO_H265 == video.codecid)
	{
		//return -2;  //不支持265 推流，update by lsz 
		
2  屏蔽掉老陈的265解包的一些断言 
   有标志字符 update by lsz  
		
ABLMediaServer-2021-07-21【彻底解决fmp4切片，AAC声音也正常】
1 修正读取flv数据函数 
	int CNetClientRecvFLV::ProcessNetData()
	{
		std::lock_guard<std::mutex> lock(NetClientRecvFLVLock);
	 
		if (netDataCacheLength > (1024 * 1024 * 1.256) )
		{//缓存1.256 M数据
			if (reader == NULL)
			   reader = flv_reader_create2(http_flv_netRead, this);
	 
			while (flv_reader_read(reader, &type, &timestamp, &taglen, packet, sizeof(packet)) == 1 )
			{//当剩余 1024 * 1024 时，需要退出 
				flv_demuxer_input(flvDemuxer, type, packet, taglen, timestamp);

				//要剩余些数据，否则当读取到包头时，包头所指的数据长度 大于 缓冲区剩余的数据，就会报错 ,最好大于i帧的长度
				if (netDataCacheLength < 1024 * 768)
					break;
			}
		}

		return 0;
	}

2 增加flv解包函数
	static int NetClientRecvFLVCallBack(void* param, int codec, const void* data, size_t bytes, uint32_t pts, uint32_t dts, int flags)
	{
		CNetClientRecvFLV* pClient = (CNetClientRecvFLV*)param;
		boost::shared_ptr<CMediaStreamSource> pMediaSource = GetMediaStreamSource("/Media/Camera_00002");

		static char s_pts[64], s_dts[64];
		static uint32_t v_pts = 0, v_dts = 0;
		static uint32_t a_pts = 0, a_dts = 0;

		//printf("[%c] pts: %s, dts: %s, %u, cts: %d, ", flv_type(codec), ftimestamp(pts, s_pts), ftimestamp(dts, s_dts), dts, (int)(pts - dts));
		if (pClient == NULL || pMediaSource == NULL)
			return 0;

		if (FLV_AUDIO_AAC == codec)
		{
			a_pts = pts;
			a_dts = dts;

			if (strlen(pMediaSource->m_mediaCodecInfo.szAudioName) == 0 && bytes > 4 && data != NULL)
			{
				unsigned char* pAudioData = (unsigned char*)data;
				strcpy(pMediaSource->m_mediaCodecInfo.szAudioName, "AAC");

				//采样频率序号只占4位，  8 7 6 5 4 3 2 1  在 6 ~ 3 位，共4个位。所以要和0x3c 与运算，把别的位全部置为0 ，再往右移动2位，
				unsigned char nSampleIndex = ((pAudioData[2] & 0x3c) >> 2) & 0x0F;  //从 pb[2] 中获取采样频率的序号
				if (nSampleIndex <= 12)
					pMediaSource->m_mediaCodecInfo.nSampleRate = SampleRateArray[nSampleIndex];

				//通道数量计算 pAVData[2]  中有2个位，在最后2位，根 0x03 与运算，得到两位，左移动2位 ，再 或 上 pAVData[3] 的左边最高2位
				//pAVData[3] 左边最高2位获取方法 先 和 0xc0 与运算，再右移6位，为什么要右移6位？因为这2位是在最高位，所以要往右边移动6位
				pMediaSource->m_mediaCodecInfo.nChannels = ((pAudioData[2] & 0x03) << 2) | ((pAudioData[3] & 0xc0) >> 6);
			}

			if (pMediaSource)
				pMediaSource->PushAudio((unsigned char*)data, bytes, pMediaSource->m_mediaCodecInfo.szAudioName, pMediaSource->m_mediaCodecInfo.nChannels, pMediaSource->m_mediaCodecInfo.nSampleRate);

			//assert(bytes == get_adts_length((const uint8_t*)data, bytes));
		}
		else if (FLV_VIDEO_H264 == codec || FLV_VIDEO_H265 == codec)
		{
			//printf("diff: %03d/%03d %s", (int)(pts - v_pts), (int)(dts - v_dts), flags ? "[I]" : "");
			v_pts = pts;
			v_dts = dts;

			//unsigned char* pVideoData = (unsigned char*)data;
			//WriteLog(Log_Debug, "CNetClientRecvRtmp=%X ,nClient = %llu, rtmp 解包回调 %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X , timeStamp = %d ,datasize = %d ", pClient, pClient->nClient, (unsigned char*)pVideoData[0], pVideoData[1], pVideoData[2], pVideoData[3], pVideoData[4], pVideoData[5], pVideoData[6], pVideoData[7], pVideoData[8], pVideoData[9], pVideoData[10], pVideoData[11], pVideoData[12],dts,bytes);
			 
			if (pMediaSource)
			{
				if (FLV_VIDEO_H264 == codec)
					pMediaSource->PushVideo((unsigned char*)data, bytes, "H264");
				else
					pMediaSource->PushVideo((unsigned char*)data, bytes, "H265");
			}

			//unsigned char* pVideoData = (unsigned char*)data;
			//WriteLog(Log_Debug, "CNethttpServer=%X ,nClient = %llu, rtmp 解包回调 %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X , timeStamp = %d ,datasize = %d ", pClient, pClient->nClient, (unsigned char*)pVideoData[0], pVideoData[1], pVideoData[2], pVideoData[3], pVideoData[4], pVideoData[5], pVideoData[6], pVideoData[7], pVideoData[8], pVideoData[9], pVideoData[10], pVideoData[11], pVideoData[12],dts,bytes);

	#ifdef  WriteHTTPFlvToEsFileFlag
			if (pClient != NULL)
			{
				if (pClient->bStartWriteFlag == false && pClient->CheckVideoIsIFrame("H264",(unsigned char*)data, bytes))
					pClient->bStartWriteFlag = true;

				if (pClient->bStartWriteFlag)
				{
					fwrite(data, 1, bytes, pClient->fWriteVideo);
					fflush(pClient->fWriteVideo);
				}
			}
	#endif
			 
		}
		else if (FLV_AUDIO_MP3 == codec)
		{
		}
		else if (FLV_AUDIO_ASC == codec || FLV_VIDEO_AVCC == codec || FLV_VIDEO_HVCC == codec)
		{
			// nothing to do
		}
		else if ((3 << 4) == codec)
		{
			//fwrite(data, bytes, 1, aac);
		}
		else
		{
			// nothing to do
			//assert(0);
		}
		return 0;
	} 
	
ABLMediaServer-2021-07-19 【彻底解决fmp4切片，AAC声音也正常】
1 增加了 NetClientRecvFLV.cpp、 NetClientRecvFLV.h ,初步实现了flv 拉流 

ABLMediaServer-2021-07-17 【彻底解决fmp4切片，AAC声音也正常】
1 增加了 NetClientRecvRtmp.cpp、 NetClientRecvRtmp.h ,初步实现了rtmp拉流 

ABLMediaServer-2021-07-16 【彻底解决fmp4切片，AAC声音也正常】
1  在切片视频时，最大等待30帧视频，确定没有音频时才开始初始化 fmp4 切片 ，如果有音频则立即进行初始化切片 

   1） 初始化切片函数回调 
	static int hls_init_segment(hls_fmp4_t* hls, void* param)
	{
		CMediaStreamSource* pMediaSource = (CMediaStreamSource*)param;
		if (pMediaSource == NULL)
			return 0;

		int bytes = hls_fmp4_init_segment(hls, pMediaSource->s_packet, Default_TS_MediaFileByteCount);

		//WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,mp4切片文件，现在长度 fMP4FileLength = %d ", pMediaSource, pMediaSource->m_szURL, bytes);

		sprintf(pMediaSource->szOutputName, "%s%d.mp4", pMediaSource->szHLSPath, pMediaSource->nTsFileOrder);
		pMediaSource->fTSFileWriteByteCount = pMediaSource->nFmp4SPSPPSLength = bytes;
		if (bytes > 0 && bytes < 1024 * 128)
			memcpy(pMediaSource->pFmp4SPSPPSBuffer, pMediaSource->s_packet, bytes);

		if (ABL_MediaServerPort.nHLSCutType == 1)
		{
			FILE* fp = fopen(pMediaSource->szOutputName, "wb");
			if (fp != NULL)
			{
			  fwrite(pMediaSource->s_packet, 1, bytes, fp);
			  fclose(fp);
			}
		}

		//必须hls_init_segment 初始化完成才能写视频、音频段，在回调函数里面做标志
		pMediaSource->hls_init_segmentFlag = true;
	 
		return 0;
	}

  2）、切片视频
	//有音频轨道 ，或者 等待视频超过30帧时，还没产生音频轨道证明该码流没有音频 
	if (nMp4BufferLength > 0 && (track_aac >= 0 || (videoDts / 40 > 30 )))
	{
		if (hls_init_segmentFlag == false )
		{
			hls_init_segment(hlsFMP4, this);
		}

		//必须hls_init_segment 初始化完成才能写视频段，在回调函数里面做标志 
		if(hls_init_segmentFlag == true )
		   hls_fmp4_input(hlsFMP4, track_265, pH265Buffer, nMp4BufferLength, videoDts, videoDts, (flags == 1) ? MOV_AV_FLAG_KEYFREAME : 0);
	}

  3）、切片音频 必须hls_init_segment 初始化完成才能写音频段，在回调函数里面做标志 
	else if (strcmp(m_mediaCodecInfo.szAudioName, "AAC") == 0 && hlsFMP4 != NULL && track_265 >= 0 && ABL_MediaServerPort.nH265CutType == 2)
	{
		if (track_aac == -1)
		{		
			nAACLength = mpeg4_aac_adts_frame_length(szAudio, nLength);
			if (nAACLength < 0)
			  return false ;

			  mpeg4_aac_adts_load(szAudio, nLength, &aacHandle);
			  nExtenAudioDataLength = mpeg4_aac_audio_specific_config_save(&aacHandle, szExtenAudioData, sizeof(szExtenAudioData));
			  if (nExtenAudioDataLength > 0)
			  {
				  track_aac = hls_fmp4_add_audio(hlsFMP4, MOV_OBJECT_AAC, nChannels,16, SampleRate, szExtenAudioData, nExtenAudioDataLength);
			  }
		}

		//必须hls_init_segment 初始化完成才能写音频段，在回调函数里面做标志 
		if (track_aac >= 0 && hls_init_segmentFlag)
		{
			hls_fmp4_input(hlsFMP4, track_aac, szAudio+7, nLength-7, audioDts , audioDts , 0);
		}
	}

ABLMediaServer-2021-07-15 【尝试增加fmp4切片 】
1 修正fmp4 切片中，判断是否有音频的条件 有音频轨道 ，或者 等待视频超过10帧时，还没产生音频轨道证明该码流没有音频 
	//有音频轨道 ，或者 等待视频超过10帧时，还没产生音频轨道证明该码流没有音频 
	if(nMp4BufferLength > 0 && ( track_aac >= 0 || ( videoDts / 40  > 10 )))
	   hls_fmp4_input(hlsFMP4, track_265, pH265Buffer, nMp4BufferLength, videoDts, videoDts, (flags == 1) ? MOV_AV_FLAG_KEYFREAME : 0);

2 升级了核心底层库网络库
	   
ABLMediaServer-2021-07-12 【尝试增加fmp4切片 】
1 修复TS方式下，音频打包条件 
	if (strcmp(m_mediaCodecInfo.szAudioName, "AAC") == 0 && tsPacketHandle != NULL )
	{
		mpeg_ts_write(tsPacketHandle, ts_stream(tsPacketHandle, avtype), 0, audioDts * 90, audioDts * 90, szAudio, nLength);
	}

2 	当码流中没有音频时，采用帧速度计算出来的时间戳，否则需要使用音频同步后的时间戳 
	//没有音频时，才启用计算视频帧速度生成时间戳 ，否则用音频同步后的时间戳
	if (strcmp(m_mediaCodecInfo.szAudioName, "AAC") != 0)
		nVideoStampAdd = 1000 / VideoFrameSpeed;

ABLMediaServer-2021-07-11 【尝试增加fmp4切片 】
1 修正I帧检测 ，如果不是I帧，立即退出循环　
	/*
	检测视频是否是I帧
	*/
	bool  CMediaStreamSource::CheckVideoIsIFrame(unsigned char* szPVideoData, int nPVideoLength)
	{
		int nPos = 0;
		bool bVideoIsIFrameFlag = false;
		unsigned char  nFrameType = 0x00;

		for (int i = 0; i < nPVideoLength; i++)
		{
			if (memcmp(szPVideoData+i, szVideoFrameHead, 4) == 0)
			{//找到帧片段
				if (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0)
				{
					nFrameType = (szPVideoData[i+4] & 0x1F);
					if (nFrameType == 7 || nFrameType == 8 || nFrameType == 5)
					{//SPS   PPS   IDR 
						bVideoIsIFrameFlag = true;
						break;
					}
					else
						break;//非I帧 ，立即退出循环　
				}
				else if (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0)
				{
					nFrameType = (szPVideoData[i+4] & 0x7E) >> 1;
					if ((nFrameType >= 16 && nFrameType <= 21) || (nFrameType >= 32 && nFrameType <= 34))
					{//SPS   PPS   IDR 
						bVideoIsIFrameFlag = true;
						break;
					}
					else
						break;//非I帧，立即退出循环
				}
			}
		}
		return bVideoIsIFrameFlag;
	}

2 修正生成切片HLS文件的扩展名（TS、MP4）条件.
	//生成m3u8文件里面的TS文件
	if (tsPacketHandle != NULL && (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0 || (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 1)))
	{
		sprintf(szOutputName, "%d.ts", nTsFileOrder - 1);//上一个文件
		m3u8FileFifo.push((unsigned char*)szOutputName, strlen(szOutputName));
	}
	else if (hlsFMP4 != NULL && strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 2)
	{
		sprintf(szOutputName, "%d.mp4", nTsFileOrder - 1);//上一个文件
		if(nTsFileOrder > 1)//切片mp4的方式，不能删除 0.mp4文件 
		   m3u8FileFifo.push((unsigned char*)szOutputName, strlen(szOutputName));
	}
	else
		return;

3 删除TS 切片方式的一个 nTsFileOrder ++; 这样生成的TS文件序号才正常 
 
4 fmp4切片增加声音支持，但是声音尚未正常 
	else if (strcmp(m_mediaCodecInfo.szAudioName, "AAC") == 0 && hlsFMP4 != NULL && track_265 >= 0 && ABL_MediaServerPort.nH265CutType == 2)
	{
		if (track_aac == -1)
		{		
			nAACLength = mpeg4_aac_adts_frame_length(szAudio, nLength);
			if (nAACLength < 0)
			  return false ;

			  mpeg4_aac_adts_load(szAudio, nLength, &aacHandle);
			  nExtenAudioDataLength = mpeg4_aac_audio_specific_config_save(&aacHandle, szExtenAudioData, sizeof(szExtenAudioData));
			  if (nExtenAudioDataLength > 0)
			  {
				  track_aac = hls_fmp4_add_audio(hlsFMP4, MOV_OBJECT_AAC, nChannels,16, SampleRate, szExtenAudioData, nExtenAudioDataLength);
			  }
		}

		if (track_aac >= 0)
		{
			hls_fmp4_input(hlsFMP4, track_aac, szAudio+7, nLength-7, audioDts, audioDts, 0);
		}
	}


ABLMediaServer-2021-07-09 【尝试增加fmp4切片 】
1 恢复hls 方式的fmp4切片 
	static int hls_init_segment(hls_fmp4_t* hls, void* param)
	{
		CMediaStreamSource* pMediaSource = (CMediaStreamSource*)param;
		if (pMediaSource == NULL)
			return 0;

		int bytes = hls_fmp4_init_segment(hls, pMediaSource->s_packet, Default_TS_MediaFileByteCount);

		WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,mp4切片文件，现在长度 fMP4FileLength = %d ", pMediaSource, pMediaSource->m_szURL, bytes);

		sprintf(pMediaSource->szOutputName, "%s%d.mp4", pMediaSource->szHLSPath, pMediaSource->nTsFileOrder);
		pMediaSource->fTSFileWriteByteCount = bytes;

		FILE* fp = fopen(pMediaSource->szOutputName, "wb");
		if (fp != NULL)
		{
		  fwrite(pMediaSource->s_packet, 1, bytes, fp);
		  fclose(fp);
		}
		return 0;
	}

	static int hls_segment(void* param, const void* data, size_t bytes, int64_t pts, int64_t dts, int64_t duration)
	{	
		CMediaStreamSource* pMediaSource = (CMediaStreamSource*)param;
		if (pMediaSource == NULL)
			return 0;

		//生成m3u8文件 
		pMediaSource->SaveTsMp4M3u8File();

		if (ABL_MediaServerPort.nHLSCutType == 1)
		{//切片到硬盘
			if (pMediaSource->fTSFileWrite != NULL)
			{
				pMediaSource->fTSFileWriteByteCount += bytes;
				fwrite((char*)data,1, bytes, (FILE*)pMediaSource->fTSFileWrite) ? 0 : ferror((FILE*)pMediaSource->fTSFileWrite);
			}
		}
		else if (ABL_MediaServerPort.nHLSCutType == 2)
		{//切片到内存 Default_TS_MediaFileByteCount
			if (pMediaSource->nMaxTsFileCacheBufferSize - pMediaSource->fTSFileWriteByteCount < bytes)
			{//空间不够，需要扩充
				unsigned char * pTempData = pMediaSource->pTsFileCacheBuffer;
				WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,最大存储空间,需要扩充 nMaxTsFileCacheBufferSize = %d，现在已经存储 fTSFileWriteByteCount = %d，剩余 %d 字节 ", pMediaSource, pMediaSource->m_szURL, pMediaSource->nMaxTsFileCacheBufferSize, pMediaSource->fTSFileWriteByteCount, pMediaSource->nMaxTsFileCacheBufferSize - pMediaSource->fTSFileWriteByteCount);

				pMediaSource->nMaxTsFileCacheBufferSize = bytes + 2048 ;
				pMediaSource->pTsFileCacheBuffer = new unsigned char[pMediaSource->nMaxTsFileCacheBufferSize];

				memcpy(pMediaSource->pTsFileCacheBuffer, pTempData, pMediaSource->fTSFileWriteByteCount);
				delete pTempData;
			}

			if (pMediaSource->nMaxTsFileCacheBufferSize - pMediaSource->fTSFileWriteByteCount >= bytes)
			{
				memcpy(pMediaSource->pTsFileCacheBuffer + pMediaSource->fTSFileWriteByteCount, data, bytes);
				pMediaSource->fTSFileWriteByteCount += bytes;
			}
		}

		WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,mp4切片文件，现在长度 fMP4FileLength = %d ", pMediaSource, pMediaSource->m_szURL, bytes);

	#if 0
		pMediaSource->nTsFileOrder ++;
		sprintf(pMediaSource->szOutputName, "%s%d.mp4", pMediaSource->szHLSPath, pMediaSource->nTsFileOrder);

		FILE* fp = fopen(pMediaSource->szOutputName, "w+b");
		fwrite(data, 1, bytes, fp);
		fclose(fp);
	#endif  

		return 0;
	}

 2、当切片方式为切到内存 ，增加特殊发送H265的 fmp4的SPS、PPS文件 0.mp4 
	else if (ABL_MediaServerPort.nHLSCutType == 2)
	{//切片至内存 
		if (ABL_MediaServerPort.nH265CutType == 2)
		{
			if (nTsFileNameOrder == 0)//请求的是 SPS \ PPS 的 0.mp4 文件 
			{
				if(pushClient->nFmp4SPSPPSLength > 0)
				  memcpy(pTsFileBuffer, pushClient->pFmp4SPSPPSBuffer, pushClient->nFmp4SPSPPSLength);
				else
				{
					WriteLog(Log_Debug, "CNetServerHLS=%X, fmp4 切片没有生成 0.mp4 文件 szReadFileName = %s nClient = %llu ", this, szReadFileName, nClient);

					sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: Close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
					nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
					return -1;
				}
			}else
				pushClient->CopyTsFileBuffer(nTsFileNameOrder, pTsFileBuffer);
		}else
		   pushClient->CopyTsFileBuffer(nTsFileNameOrder, pTsFileBuffer);
	}
	
ABLMediaServer-2021-07-08 【尝试增加fmp4切片 】
1 在发送TS、FMP4文件时的内存只分配一次，不用反复创建、删除 
 
	//首次分配内存 
	if (pTsFileBuffer == NULL )
	{
		nCurrentTsFileBufferSize = MaxDefaultTsFmp4FileByteCount;
		pTsFileBuffer = new unsigned char[nCurrentTsFileBufferSize];
	}

	//如果要读取的文件字节数大于  nCurrentTsFileBufferSize
	if (fFileByteCount > nCurrentTsFileBufferSize)
	{
		delete [] pTsFileBuffer;
		nCurrentTsFileBufferSize = fFileByteCount + 1024 * 512 ; //再扩大512K 
		pTsFileBuffer = new unsigned char[nCurrentTsFileBufferSize];
	}

2 把 内存切片方式的内存（pTsFileCacheBuffer、mediaFileBuffer[i]），移动到 删除切片句柄(tsPacketHandle、hlsFMP4) 之后 。	
	//删除TS切片句柄
	if (tsPacketHandle != NULL)
	{
		mpeg_ts_destroy(tsPacketHandle);
		tsPacketHandle = NULL;
	}

	//删除fmp4切片句柄
	if (hlsFMP4 != NULL)
	{
		fmp4_writer_destroy(hlsFMP4);
		hlsFMP4 = NULL;
	}

	if (ABL_MediaServerPort.nHLSCutType == 2)
	{//切片到内存
		if (pTsFileCacheBuffer != NULL)
		{
			delete[] pTsFileCacheBuffer;
			pTsFileCacheBuffer = NULL;
		}

		for (int i = 0; i < MaxStoreTsFileCount; i++)
			mediaFileBuffer[i].FreeFifo();
	}

ABLMediaServer-2021-07-07 【尝试增加fmp4切片 】
1 在媒体源销毁时，增加删除句柄 
	if (tsPacketHandle != NULL)
		mpeg_ts_destroy(tsPacketHandle);

	if (hlsFMP4 != NULL)
		hls_fmp4_destroy(hlsFMP4);

2 增加h265的fmp4切片 		
	static int hls_init_segment(hls_fmp4_t* hls, void* param)
	{
		CMediaStreamSource* pMediaSource = (CMediaStreamSource*)param;
		if (pMediaSource == NULL)
			return 0;
		int bytes = hls_fmp4_init_segment(hls, pMediaSource->s_packet, sizeof(pMediaSource->s_packet));

		FILE* fp = fopen("hls/0.mp4", "wb");
		fwrite(pMediaSource->s_packet, 1, bytes, fp);
		fclose(fp);

		return 0;
		//return hls_m3u8_set_x_map(m3u, "hls/0.mp4");
	}

	static int hls_segment(void* m3u8, const void* data, size_t bytes, int64_t pts, int64_t dts, int64_t duration)
	{
		static int i = 0;
		static char name[128] = { 0 };
		snprintf(name, sizeof(name), "hls/%d.mp4", ++i);
		FILE* fp = fopen(name, "wb");
		fwrite(data, 1, bytes, fp);
		fclose(fp);

		return hls_m3u8_add((hls_m3u8_t*)m3u8, name, dts, duration, 0);
	}

3 增加获取h265的宽、高
	//查找SPS出现的位置
	unsigned  int  CMediaStreamSource::FindSpsPosition(unsigned char* szVideoBuffer, int nBufferLength, bool &bFind)
	{
		unsigned int nPos = 0;
		unsigned char H265HeadFlag[4] = { 0x00,0x00,0x00,0x01 };
		unsigned char nFrameTypeH265, nTempFrame;
		bFind = false;
		for (int i = 0; i < nBufferLength; i++)
		{
			if (memcmp(H265HeadFlag, szVideoBuffer + i, 4) == 0)
			{
				nTempFrame = szVideoBuffer[i + 4];
				nFrameTypeH265 = (nTempFrame & 0x7E) >> 1;
				if (nFrameTypeH265 == 33)
				{//SPS帧
					nPos = i;
					bFind = true;
					break;
				}
			}
		}

		return nPos + 4;
	}

	//获取H265相关信息
	bool  CMediaStreamSource::ParseSequenceParameterSet(BYTE* data, int size, vc_params_t& params)
	{
		if (size < 20)
		{
			return false;
		}
		NALBitstream bs(data, size);
		// seq_parameter_set_rbsp()  
		bs.GetWord(4);// sps_video_parameter_set_id  
		int sps_max_sub_layers_minus1 = bs.GetWord(3);
		if (sps_max_sub_layers_minus1 > 6)
		{
			return false;
		}
		bs.GetWord(1);
		{
			bs.GetWord(2);
			bs.GetWord(1);
			params.profile = bs.GetWord(5);
			bs.GetWord(32);//  
			bs.GetWord(1);//   
			bs.GetWord(1);//   
			bs.GetWord(1);//   
			bs.GetWord(1);//    
			bs.GetWord(44);//   
			params.level = bs.GetWord(8);// general_level_idc  
			uint8 sub_layer_profile_present_flag[6] = { 0 };
			uint8 sub_layer_level_present_flag[6] = { 0 };
			for (int i = 0; i < sps_max_sub_layers_minus1; i++) {
				sub_layer_profile_present_flag[i] = bs.GetWord(1);
				sub_layer_level_present_flag[i] = bs.GetWord(1);
			}
			if (sps_max_sub_layers_minus1 > 0)
			{
				for (int i = sps_max_sub_layers_minus1; i < 8; i++) {
					uint8 reserved_zero_2bits = bs.GetWord(2);
				}
			}
			for (int i = 0; i < sps_max_sub_layers_minus1; i++)
			{
				if (sub_layer_profile_present_flag[i]) {
					bs.GetWord(2);
					bs.GetWord(1);
					bs.GetWord(5);
					bs.GetWord(32);
					bs.GetWord(1);
					bs.GetWord(1);
					bs.GetWord(1);
					bs.GetWord(1);
					bs.GetWord(44);
				}
				if (sub_layer_level_present_flag[i]) {
					bs.GetWord(8);// sub_layer_level_idc[i]  
				}
			}
		}
		UINT32 sps_seq_parameter_set_id = bs.GetUE();
		if (sps_seq_parameter_set_id > 15) {
			return false;
		}
		UINT32 chroma_format_idc = bs.GetUE();
		if (sps_seq_parameter_set_id > 3) {
			return false;
		}
		if (chroma_format_idc == 3) {
			bs.GetWord(1);//    
		}
		params.width = bs.GetUE(); // pic_width_in_luma_samples  
		params.height = bs.GetUE(); // pic_height_in_luma_samples  
		if (bs.GetWord(1)) {
			bs.GetUE();
			bs.GetUE();
			bs.GetUE();
			bs.GetUE();
		}
		UINT32 bit_depth_luma_minus8 = bs.GetUE();
		UINT32 bit_depth_chroma_minus8 = bs.GetUE();
		if (bit_depth_luma_minus8 != bit_depth_chroma_minus8) {
			return false;
		}

		//修正高度  
		if (params.height == 1088)
			params.height = 1080;

		return true;
	}

4 增加H265切片为fmp4 
	bool  CMediaStreamSource::H265FrameToFMP4File(unsigned char* szVideoData, int nLength)
	{
		if (H265Params.width == 0 && H265Params.height == 0)
		{
			bool bFind = false;
			int  nPos = -1;
			nPos = FindSpsPosition(szVideoData, nLength, bFind);
			if (!bFind)
				return false;

			if (bFind && nPos >= 0 )
			{
				ParseSequenceParameterSet(szVideoData + nPos, nLength - nPos, H265Params);
			}
			if (!(H265Params.width > 0 && H265Params.height > 0))
				return false;

			int vcl = 0;
			int update = 0;
			pH265Buffer = new unsigned char[MediaStreamSource_VideoFifoLength];
			int n = h265_annexbtomp4(&hevc, szVideoData, nLength, pH265Buffer, MediaStreamSource_VideoFifoLength, &vcl, &update);

			if (track_265 < 0)
			{
				if (hevc.numOfArrays < 1)
				{
					delete [] pH265Buffer;
					pH265Buffer = NULL;
					return false; // waiting for vps/sps/pps
				}

				memset(szExtenVideoData,0x00, sizeof(szExtenVideoData));
				extra_data_sizeH265 = mpeg4_hevc_decoder_configuration_record_save(&hevc, szExtenVideoData, sizeof(szExtenVideoData));
				if (extra_data_sizeH265 <= 0)
				{
					delete[] pH265Buffer;
					pH265Buffer = NULL;

					return false;
				}

				if (extra_data_sizeH265 > 0)
				{
				   track_265 = hls_fmp4_add_video(hlsFMP4, MOV_OBJECT_HEVC, H265Params.width, H265Params.height, szExtenVideoData, extra_data_sizeH265);
				   hls_init_segment(hlsFMP4, this);
				}
			}

			delete[] pH265Buffer;
			pH265Buffer = NULL;
		}

		if (track_265 >= 0)
		{
			if (CheckVideoIsIFrame(szVideoData, nLength) == true)
				flags = 1;
			else
				flags = 0;

			hls_fmp4_input(hlsFMP4, track_265, szVideoData, nLength, videoDts, videoDts, (flags == 1) ? MOV_AV_FLAG_KEYFREAME : 0);
		}
	 
		return true;
	}


ABLMediaServer-2021-07-06 【增加HLS切片，修改为直接切换、自己生成m3u8文件内容 】
1 完善RTMP、FLV、HLS 常见几种分辨率的时间戳 
	if (m_mediaCodecInfo.nSampleRate == 48000)
		audioDts += 21;
	else if (m_mediaCodecInfo.nSampleRate == 44100)
		audioDts += 23;
	else if (m_mediaCodecInfo.nSampleRate == 32000)
		audioDts += 32;
	else if (m_mediaCodecInfo.nSampleRate == 24000)
		audioDts += 42;
	else if (m_mediaCodecInfo.nSampleRate == 22050)
		audioDts += 49;
	else if (m_mediaCodecInfo.nSampleRate == 16000)
		audioDts += 64;
	else if (m_mediaCodecInfo.nSampleRate == 12000)
		audioDts += 85;
	else if (m_mediaCodecInfo.nSampleRate == 11025)
		audioDts += 92;
	else if (m_mediaCodecInfo.nSampleRate == 8000)
		audioDts += 128;

2 增加当视频为H265时，HLS的两种切片方式
	;当视频为h265切片方式 ，1 切片为TS 文件，2 切片为mp4 文件 
	h265CutType=1

	ABL_MediaServerPort.nH265CutType = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "h265CutType", "1"));
		
3  切片为TS时，增加条件限制 
	bool CMediaStreamSource::PushVideo(unsigned char* szVideo, int nLength, char* szVideoCodec)
	{//直接拷贝给每个网络发送对象 
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		//计算帧视频速度 
		CalcVideoFrameSpeed();

		//记录视频格式
		if (strlen(m_mediaCodecInfo.szVideoName) == 0)
			strcpy(m_mediaCodecInfo.szVideoName,(char*)szVideoCodec);
		
		if (ABL_MediaServerPort.nHlsEnable == 1 && tsPacketHandle == NULL)
		{
			tsFileNameFifo.InitFifo(1024 * 512);
			m3u8FileFifo.InitFifo(1025 * 256);

			if (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0 || (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 1) )
			{//h264 切片为 TS ,或者 H265 选择切片为TS 
				tshandler.alloc = ts_alloc;
				tshandler.write = ts_write;
				tshandler.free = ts_free;

				srand(GetTickCount());
				sprintf(szOutputName, "%s%d.ts", szHLSPath, nTsFileOrder);
				if(ABL_MediaServerPort.nHLSCutType == 1) //切片至硬盘
				  fTSFileWrite = fopen(szOutputName, "wb");

				tsPacketHandle = mpeg_ts_create(&tshandler, (void*)this);

				nTsFileOrder++;

				tsFileNameFifo.push((unsigned char*)szOutputName, strlen(szOutputName));
			} 
			else if (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 2)
			{//H265 切片为 mp4 
	 
			}
		}

		if (ABL_MediaServerPort.nHlsEnable == 1 )
		{
			int nPutRet;
			if (tsPacketHandle != NULL && (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0 || (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 1)))
			{//H264
				H264H265FrameToTSFile(szVideo, nLength);
			}
			else if (hlsFMP4 != NULL && strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0 && ABL_MediaServerPort.nH265CutType == 2)
			{//H265

			}

			videoDts += nVideoStampAdd;
		}

		
ABLMediaServer-2021-07-05 【增加HLS切片，修改为直接切换、自己生成m3u8文件内容 】
1 修正 else if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName, "H265") == 0) ，忘记写 == 0 
	//根据媒体信息拼装 SDP 信息
	bool CNethttpServer::GethttpSDPFromMediaStreamSource(httpSDPContentStruct sdpContent, bool bGetFlag)
	{
		memset(szhttpSDPContent, 0x00, sizeof(szhttpSDPContent));

		//视频
		nVideoSSRC = rand();
		memset((char*)&optionVideo, 0x00, sizeof(optionVideo));
		if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName,"H264") == 0)
		{
			optionVideo.streamtype = e_rtppkt_st_h264;
			if (bGetFlag)
				nVideoPayload = sdpContent.nVidePayload;
			else
				nVideoPayload = 96;
			sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\nm=video 6000 RTP/AVP %d\r\nb=AS:832\r\na=rtpmap:%d H264/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n", nVideoPayload, nVideoPayload, nVideoPayload);
		}
		else if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName, "H265") == 0)
		{
		
		
2  切片回调函数一定要返回 0 ，否则切片会失败，只切了256K字节 
	static int ts_write(void* param, const void* packet, size_t bytes)
	{
		if (param != NULL)
		{
			CMediaStreamSource* handle = (CMediaStreamSource*)param;
			if (handle != NULL)
			{
				if (ABL_MediaServerPort.nHLSCutType == 1)
				{//切片到硬盘
					if (handle->fTSFileWrite != NULL)
					{
						handle->fTSFileWriteByteCount += bytes;
						return 1 == fwrite(packet, bytes, 1, (FILE*)handle->fTSFileWrite) ? 0 : ferror((FILE*)handle->fTSFileWrite);
					}
					else
						return 0;
				}
				else if (ABL_MediaServerPort.nHLSCutType == 2)
				{//切片到内存 
					if (Default_TS_MediaFileByteCount - handle->fTSFileWriteByteCount >= bytes)
					{
						memcpy(handle->pTsFileCacheBuffer + handle->fTSFileWriteByteCount, packet, bytes);
						handle->fTSFileWriteByteCount += bytes;
					}
					return 0;
				}
		   }
		}
		else
			return 0;
	}	
	
3 把自研的h264切片集成进来 		
 
	bool  CMediaStreamSource::H264FrameToTSFile(unsigned char* szVideo, int nLength)
	{
		if (szVideo == NULL || nLength <= 0)
			return false;

		if (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0)
			avtype = PSI_STREAM_H264;
		else if (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0)
			avtype = PSI_STREAM_H265;

		if (CheckVideoIsIFrame(szVideo, nLength) == true)
			flags = 1;
		else
			flags = 0;

		ptsVideo = videoDts * 90;
		if (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0)
			mpeg_ts_write(tsPacketHandle, ts_stream(tsPacketHandle, avtype), flags, ptsVideo, ptsVideo, szVideo, nLength);
		else
		{

		}
		nVideoOrder++;

		if (nVideoOrder % 75 == 0)
		{//1秒切片1次
		 //生成m3u8文件里面的TS文件
			sprintf(szOutputName, "%d.ts", nTsFileOrder - 1);//上一个文件
			m3u8FileFifo.push((unsigned char*)szOutputName, strlen(szOutputName));
			if (m3u8FileFifo.GetSize() > 3)
				m3u8FileFifo.pop_front();//删除掉最老的一个文件名字
			if (m3u8FileFifo.GetSize() >= 3)
			{
				sprintf(szOutputName, "%shls.m3u8",szHLSPath);

				FILE* m3u8File = fopen(szOutputName, "w+b");
				if (m3u8File != NULL)
				{
					memset(szH264TempBuffer, 0x00, sizeof(szH264TempBuffer));
					memset(szM3u8Buffer, 0x00, sizeof(szM3u8Buffer));
					
					sprintf(szH264TempBuffer, "#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:3\n#EXT-X-MEDIA-SEQUENCE:%d\n#EXT-X-ALLOW-CACHE:NO\n", m3u8FileOrder);
					
					fprintf(m3u8File, szH264TempBuffer);
					strcpy(szM3u8Buffer, szH264TempBuffer);
	 
					unsigned char* pData;
					int            nLength;
					for (int i = 0; i < 3; i++)
					{
						pData = m3u8FileFifo.pop(&nLength);
						if (pData)
						{
							memset(szOutputName, 0x00, sizeof(szOutputName));
							memcpy(szOutputName, pData, nLength);
							sprintf(szH264TempBuffer, "#EXTINF:3.000,\n%s/%s\n",szTSFileSubPath,szOutputName);
							
							fprintf(m3u8File, szH264TempBuffer);
							strcat(szM3u8Buffer, szH264TempBuffer);

							m3u8FileFifo.pop_front();
							m3u8FileFifo.push((unsigned char*)szOutputName, strlen(szOutputName));//回收TS文件名字
						}
					}

					fclose(m3u8File);
				}

				//更新m3u8内容
				CopyM3u8Buffer(szM3u8Buffer);

				m3u8FileOrder++;
			}

			nTsFileSizeArray[nTsFileOrder % MaxStoreTsFileCount] = fTSFileWriteByteCount;
			fTSFileWriteByteCount = 0;
			if (fTSFileWrite != NULL)
			{
				fclose(fTSFileWrite);
				fTSFileWrite = NULL;
			}

			nTsFileOrder ++;
			sprintf(szOutputName, "%s%d.ts", szHLSPath, nTsFileOrder);
			fTSFileWrite = fopen(szOutputName, "w+b");

			tsFileNameFifo.push((unsigned char*)szOutputName, strlen(szOutputName));

			//定期删除历史TS文件
			if (GetTickCount() - tsDeleteTime >= 1000 * 5)
			{
				unsigned char* pData;
				int           nLength;
				while (tsFileNameFifo.GetSize() > 15)
				{
					memset(szOutputName, 0x00, sizeof(szOutputName));
					pData = tsFileNameFifo.pop(&nLength);
					if (pData != NULL)
					{
						memcpy(szOutputName, pData, nLength);
						::DeleteFile(szOutputName);

						tsFileNameFifo.pop_front();
					}
				}
				tsDeleteTime = GetTickCount();
			}
		}
		return true;
	}

4 调整HLS 内存切片时的两个参数
	#define   Default_TS_MediaFileByteCount       1024*1024*6  //缺省的切片文件大小 
	#define   MaxStoreTsFileCount                 4            //最大允许保持TS文件数量　,经过测试发现，只有4帧足够 
	
5  当切片到内存时，存储空间不够，需要自动扩充，每次扩充2兆空间 
	else if (ABL_MediaServerPort.nHLSCutType == 2)
	{//切片到内存 Default_TS_MediaFileByteCount
		if (handle->nMaxTsFileCacheBufferSize - handle->fTSFileWriteByteCount < bytes)
		{//空间不够，需要扩充
			unsigned char * pTempData = handle->pTsFileCacheBuffer;
			WriteLog(Log_Debug, "CMediaStreamSource= %X ,媒体源 = %s ,最大存储空间,需要扩充 nMaxTsFileCacheBufferSize = %d，现在已经存储 fTSFileWriteByteCount = %d，剩余 %d 字节 ", handle, handle->m_szURL, handle->nMaxTsFileCacheBufferSize, handle->fTSFileWriteByteCount, handle->nMaxTsFileCacheBufferSize - handle->fTSFileWriteByteCount);

			handle->nMaxTsFileCacheBufferSize += 1024 * 1024 * 2;//增加2兆
			handle->pTsFileCacheBuffer = new unsigned char[handle->nMaxTsFileCacheBufferSize];

			memcpy(handle->pTsFileCacheBuffer , pTempData, handle->fTSFileWriteByteCount);
			delete pTempData;
		}

		if (handle->nMaxTsFileCacheBufferSize - handle->fTSFileWriteByteCount >= bytes)
		{
			memcpy(handle->pTsFileCacheBuffer + handle->fTSFileWriteByteCount, packet, bytes);
			handle->fTSFileWriteByteCount += bytes;
		}

		return 0;
	}

ABLMediaServer-2021-06-30 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 修正http接收视频时写入视频文件的I帧检测　　pUserHandle->szVideoName
	#ifdef WriteRtpDepacketFileFlag
					  if (pUserHandle->CheckVideoIsIFrame(pUserHandle->szVideoName, cb->data, cb->datasize))
					  {
						  fwrite(pUserHandle->m_pSpsPPSBuffer, 1, pUserHandle->m_nSpsPPSLength, pUserHandle->fWriteRtpVideo);
						  fflush(pUserHandle->fWriteRtpVideo);
						  pUserHandle->bStartWriteFlag = true;
					  }

					if (pUserHandle->bStartWriteFlag)
					{
						fwrite(cb->data, 1, cb->datasize, pUserHandle->fWriteRtpVideo);
						fflush(pUserHandle->fWriteRtpVideo);
					}
	#endif  	

2、rtmp、flv、HLS 视频输出 当音频格式不为 AAC 时，不输出音频码流 
	int CNetServerHTTP_FLV::SendAudio()
	{
		if (nWriteErrorCount >= 30)
		{
			WriteLog(Log_Debug, "发送flv 失败,nClient = %llu ", nClient);
			DeleteNetRevcBaseClient(nClient);
			return -1;
		}

		//不是AAC，不再输出音频 
		if (strcmp(mediaCodecInfo.szAudioName, "AAC") != 0)
			return -1;

		unsigned char* pData = NULL;
		int            nLength = 0;
		if((pData = m_audioFifo.pop(&nLength)) != NULL)
		{
			MuxerAudioFlV(mediaCodecInfo.szAudioName, pData, nLength);

			m_audioFifo.pop_front();
		}
		if (nWriteErrorCount >= 30)
		{
			DeleteNetRevcBaseClient(nClient);
			WriteLog(Log_Debug, "发送flv 失败,nClient = %llu ", nClient);
		}

		return 0;
	}

3 在接收rtmp推流时，屏蔽掉包头检测，否则obs推流不上来 	
	#if 0    //屏蔽掉 ，否则 obs推不上来 
			if (!bCheckhttpVersionFlag)
			{
				bCheckhttpVersionFlag = true;
				if (!(pData[0] == 0x03 && pData[1] == 0x00 && pData[2] == 0x00 && pData[3] == 0x00 && pData[4] == 0x00))
				{//简单检测包头是否合法，是否符合rtmp协议
					DeleteNetRevcBaseClient(nClient);
					return -1;
				}
			}
	#endif 	
	
ABLMediaServer-2021-06-29 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 FLV、Rtmp\HLS  增加支持 48000 采样的
		if (m_mediaCodecInfo.nSampleRate == 48000)
			audioDts += 21;

ABLMediaServer-2021-06-28 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 修正 采样频率 44100、和每次增量 23 毫秒
		if (mediaCodecInfo.nSampleRate == 44100)
			nAudioDTS += 23;
  		else if (mediaCodecInfo.nSampleRate == 16000)
			nAudioDTS += 64;
		else if (mediaCodecInfo.nSampleRate == 8000)
			nAudioDTS += 128;

2 、对rtmp 进行音视频同步
  int CNetRtmpServerRecv::SendAudio()
  {
	//500毫秒同步一次 
	if (GetTickCount() - nAsyncAudioStamp >= 500)
	{
		WriteLog(Log_Debug, "CNetRtmpServerRecv = %X nVideoDTS = %d ,nAudioDTS = %d ",this, nVideoDTS, nAudioDTS);
		if (nVideoDTS < nAudioDTS)
		{
			nVideoStampAdd = 50;
		}
		else if (nVideoDTS > nAudioDTS)
		{
			nVideoStampAdd = 20;
		}
		nAsyncAudioStamp = GetTickCount();
	}
  }	
  
ABLMediaServer-2021-06-27 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1  增加老陈的获取SPS、PPS代码 
	int CNethttpServer::sdp_h264_load(uint8_t* data, int bytes, const char* config)
	{
		int n, len, off;
		const char* p, *next;
		const uint8_t startcode[] = { 0x00, 0x00, 0x00, 0x01 };

		off = 0;
		p = config;
		while (p)
		{
			next = strchr(p, ',');
			len = next ? (int)(next - p) : (int)strlen(p);
			if (off + (len + 3) / 4 * 3 + (int)sizeof(startcode) > bytes)
				return -1; // don't have enough space

			memcpy(data + off, startcode, sizeof(startcode));
			n = (int)base64_decode(data + off + sizeof(startcode), p, len);
			assert(n <= (len + 3) / 4 * 3);
			off += n + sizeof(startcode);

			p = next ? next + 1 : NULL;
		}

		return off;
	}

	//从 SDP中获取  SPS，PPS 信息
	bool  CNethttpServer::GetSPSPPSFromDescribeSDP()
	{
		m_bHaveSPSPPSFlag = false;
		int  nPos1, nPos2;
		char  szSprop_Parameter_Sets[512] = { 0 };

		m_nSpsPPSLength = 0;
		string strSDPTemp = szhttpContentSDP;
		nPos1 = strSDPTemp.find("sprop-parameter-sets=", 0);
		memset(m_szSPSPPSBuffer, 0x00, sizeof(m_szSPSPPSBuffer));
		nPos2 = strSDPTemp.find("\r\n", nPos1 + 1);

		if (nPos1 > 0 && nPos2 > 0)
		{
			memcpy(szSprop_Parameter_Sets, szhttpContentSDP + nPos1, nPos2 - nPos1 + 2);
			strSDPTemp = szSprop_Parameter_Sets;
			nPos1 = strSDPTemp.find("sprop-parameter-sets=", 0);

			nPos2 = strSDPTemp.find(";", nPos1 + 1);
			if (nPos2 > nPos1)
			{//后面还有别的项
				memcpy(m_szSPSPPSBuffer, szSprop_Parameter_Sets + nPos1 + strlen("sprop-parameter-sets="), nPos2 - nPos1 - strlen("sprop-parameter-sets="));
			}
			else
			{//后面没有别的项
				nPos2 = strSDPTemp.find("\r\n", nPos1 + 1);
				if (nPos2 > nPos1)
					memcpy(m_szSPSPPSBuffer, szSprop_Parameter_Sets + nPos1 + strlen("sprop-parameter-sets="), nPos2 - nPos1 - strlen("sprop-parameter-sets="));
			}
		}

		if (strlen(m_szSPSPPSBuffer) > 0)
		{
			m_nSpsPPSLength = sdp_h264_load((unsigned char*)m_pSpsPPSBuffer, sizeof(m_pSpsPPSBuffer), m_szSPSPPSBuffer);
			m_bHaveSPSPPSFlag = true;
		}

		return m_bHaveSPSPPSFlag;
	}

2 、 在视频分发时，首先加入一次SPS、PPS 帧 
	MediaSendMap::iterator it;
	uint64_t               nClient;
	for (it = mediaSendMap.begin(); it != mediaSendMap.end(); ++it)
	{
		boost::shared_ptr<CNetRevcBase> pClient = GetNetRevcBaseClient((*it).second);
		if (pClient != NULL)
		{
			//首先加入SPS、PPS 
			if (pClient->bPushSPSPPSFrameFlag == false)
			{
				if (nSPSPPSLength > 0)
				{
					pClient->PushVideo(pSPSPPSBuffer, nSPSPPSLength, szVideoCodec);
					pClient->bPushSPSPPSFrameFlag = true;
				}
			}

			pClient->PushVideo(szVideo, nLength,szVideoCodec);
		}
		else
		{//加入失败，证明该链接已经断开 
			nClient = (*it).second;
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		}
	}

 
3	把http的SDP 拷贝给媒体源 
	strcpy(pMediaSource->httpSDPContent.szSDPContent, szhttpContentSDP);

ABLMediaServer-2021-06-20 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 CNetClientRecvHttpHLS 类修改为 网络数据先到达 InputNetData ,然后让多线程执行 ProcessNetData()
	int CNetClientRecvHttpHLS::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength)
	{
		std::lock_guard<std::mutex> lock(netDataLock);

		if (nDataLength <= 0)
			return 0;

		NetDataFifo.push(pData, nDataLength);
		return 0;
	}

ABLMediaServer-2021-06-19 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 修改了查找 http 结束符的方法   
  unsigned char  szReturnFlag[4] = { 0x0d,0x0a,0x0d,0x0a };

  if (!bRecvHttpHeadFlag) 
  {
	if (MaxNetDataCacheCount - nNetEnd >= nDataLength)
	{//剩余空间足够
		memcpy(netDataCache + nNetEnd, pData, nDataLength);
		netDataCacheLength += nDataLength;
		nNetEnd += nDataLength;
	}
	netDataCache[nNetEnd] = 0x00;
	//WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X,  收到数据 = %s, nClient = %llu ", this, netDataCache, nClient);
	nPos = -1;
	for (int i = 0;i< netDataCacheLength;i++)
	{
		if(memcmp(netDataCache+i, szReturnFlag, 4) ==0 ) 
		{
			nPos = i;
			break;
		}
	}
	if (nPos == -1)
	{
		WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, http头尚未接收完整 szRequestFileName = %s, nClient = %llu ", this, szRequestFile, nClient);
		return -1;
	}

2 增加TS解包功能 （TS 解包不正常 ）
	int  nMaxLenght = nRecvContentLength;
	nPos = 0 ;
	while (nMaxLenght > TsStreamBlockBufferLength)
	{
		ts_demuxer_input(ts, pContentBody + nPos , TsStreamBlockBufferLength);
		nPos         +=    TsStreamBlockBufferLength;
		nMaxLenght   -=    TsStreamBlockBufferLength;
	}

3 增加请求文件不存在判断 
	//请求的文件不存在
	if (httpParse.GetFieldValue("Content-Length", szContentValue) == false )
	{
		nHLSRequestFileStatus = HLSRequestFileStatus_RequestSuccess ;
		nNetStart = nNetEnd = netDataCacheLength = nRecvContentLength = 0;
		WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X,请求的文件不存在 szRequestFileName = %s, nClient = %llu ", this, szRequestFile, nClient);
		return -1;
	}
	
4  增加TS解包，视频正常，AAC声音不正常 	
	static int on_hls_ts_packet(void* param, int program, int stream, int avtype, int flags, int64_t pts, int64_t dts, const void* data, size_t bytes)
	{
		static char s_pts[64], s_dts[64];
		CNetClientRecvHttpHLS* pHLS = (CNetClientRecvHttpHLS*)param;
		if (pHLS == NULL)
			return 0;
		boost::shared_ptr<CMediaStreamSource> pSource =  GetMediaStreamSource(pHLS->szSourceURL);
		if (pSource == NULL)
		{
			pDisconnectBaseNetFifo.push((unsigned char*)&pHLS->nClient, sizeof(pHLS->nClient));
			return -1 ;
		}

		if (PSI_STREAM_AAC == avtype || PSI_STREAM_AUDIO_OPUS == avtype)
		{
			static int64_t a_pts = 0, a_dts = 0;
			if (PTS_NO_VALUE == dts)
				dts = pts;
			//assert(0 == a_dts || dts >= a_dts);
			//printf("[A][%d:%d] pts: %s(%lld), dts: %s(%lld), diff: %03d/%03d, bytes: %u\n", program, stream, ftimestamp(pts, s_pts), pts, ftimestamp(dts, s_dts), dts, (int)(pts - a_pts) / 90, (int)(dts - a_dts) / 90, (unsigned int)bytes);
			a_pts = pts;
			a_dts = dts;

			//pSource->PushAudio((unsigned char*)data,bytes,"AAC",1,16000);
			//fwrite(data, 1, bytes, afp);
		}
		else if (PSI_STREAM_H264 == avtype || PSI_STREAM_H265 == avtype)
		{
			static int64_t v_pts = 0, v_dts = 0;
			//assert(0 == v_dts || dts >= v_dts);
			//printf("[V][%d:%d] pts: %s(%lld), dts: %s(%lld), diff: %03d/%03d, bytes: %u%s\n", program, stream, ftimestamp(pts, s_pts), pts, ftimestamp(dts, s_dts), dts, (int)(pts - v_pts) / 90, (int)(dts - v_dts) / 90, (unsigned int)bytes, flags ? " [I]" : "");
			v_pts = pts;
			v_dts = dts;

			if (PSI_STREAM_H264 == avtype)
				pSource->PushVideo((unsigned char*)data, bytes, "H264");
			else if(PSI_STREAM_H265 == avtype)
				pSource->PushVideo((unsigned char*)data, bytes, "H265");

			//fwrite(data, 1, bytes, vfp);
		}
		else
		{
			static int64_t x_pts = 0, x_dts = 0;
			//assert(0 == x_dts || dts >= x_dts);
			//printf("[%d][%d:%d] pts: %s(%lld), dts: %s(%lld), diff: %03d/%03d%s\n", avtype, program, stream, ftimestamp(pts, s_pts), pts, ftimestamp(dts, s_dts), dts, (int)(pts - x_pts) / 90, (int)(dts - x_dts) / 90, flags ? " [I]" : "");
			x_pts = pts;
			x_dts = dts;
			//assert(0);
		}
		return 0;
	}

ABLMediaServer-2021-06-17 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1  HLS客户端能完全正常接收自研服务器 ABLMediaServer 

ABLMediaServer-2021-06-16 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 增加HLS请求文件状态 
	enum HLSRequestFileStatus
	{
		HLSRequestFileStatus_NoRequsetFile   = 0, //未执行请求
		HLSRequestFileStatus_SendRequest     = 1,//已经发出请求
		HLSRequestFileStatus_RecvHttpHead    = 2,//收到Http头
		HLSRequestFileStatus_RequestSuccess  = 3,//接收完整
	};

2、增加请求TS \ mp4文件失败后，重新请求 
	//请求m3u8文件
	bool  CNetClientRecvHttpHLS::RequestM3u8File()
	{
		//如果文件FIFO为空，证明TS文件全部请求完毕，需要增加m3u8文件到FIFO 
		if (requestFileFifo.GetSize() == 0)
		{
			//不够2秒
			if (GetTickCount() - nSendM3u8Time < 3000)
				return false;

			requestFileFifo.push((unsigned char*)szRequestM3u8File, strlen(szRequestM3u8File));
			SendFirstRequst(); 
			return true;
		}
		else
		{//重新请求 TS 文件 
			if (GetTickCount() - nSendTsFileTime > 1000 * 3    &&
				nHLSRequestFileStatus !=  HLSRequestFileStatus_RequestSuccess )
			{//接收TS，mp4文件超时，重新请求
				WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, 接收TS文件超时，需要重新请求 , szRequestFileName = %s, nClient = %llu \r\n", this, szRequestFile, nClient);
				SendFirstRequst();
				return true;
			}

			return false;
		}
	} 
	
3、 如果推流地址不存在，立即删除连接，否则由于删除过慢，造成内存暴涨
	//根据推流名字找到
	boost::shared_ptr<CMediaStreamSource> pushClient = GetMediaStreamSource(szPushName);
	if (pushClient == NULL)
	{
		WriteLog(Log_Debug, "CNetServerHLS=%X, 没有推流对象的地址 %s nClient = %llu ", this, szPushName, nClient);

		sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: Close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
		nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

		DeleteNetRevcBaseClient(nClient);  //立即删除 
		return -1;
	}
	
4、实现ts文件在历史记录中查找，如果查找到，不能加入请求文件列表中
	//查找m3u8文件是否在历史list里面
	bool   CNetClientRecvHttpHLS::FindM3u8FileAtHistoryList(char* szTsFile)
	{
		bool  bFind = false;
		HistoryM3u8List::iterator it;
		for (it = historyM3u8List.begin(); it != historyM3u8List.end();)
		{
			if (strstr((*it).szM3u8Data, szTsFile) != NULL)
			{//找到
				bFind = true;
				WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, 找到TS文件 szTsFile = %s, nClient = %llu ", this, szTsFile, nClient);
				break;
			}
			else
			{
				if (GetTickCount() - (*it).nRecvTime > 1000 * 30)
				{
					historyM3u8List.erase(it++);
				}else
					++it;
			}
		}
		return bFind;
	}
 	
	
ABLMediaServer-2021-06-15 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1  CNethttpServer 回复为以前版本 

2  修改CNetClientRecvHttpHLS 网络接收处理模块
int CNetClientRecvHttpHLS::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength)
{
	std::lock_guard<std::mutex> lock(netDataLock);

	//网络断线检测
	nRecvDataTimerBySecond = 0;
	int nPos;

	char szContentValue[64] = { 0 };

	if (!bRecvHttpHeadFlag)
	{
		if (MaxNetDataCacheCount - nNetEnd >= nDataLength)
		{//剩余空间足够
			memcpy(netDataCache + nNetEnd, pData, nDataLength);
			netDataCacheLength += nDataLength;
			nNetEnd += nDataLength;
		}
		netDataCache[nNetEnd] = 0x00;
		WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X,  收到数据 = %s, nClient = %llu ", this, netDataCache, nClient);

		string  strHttpHead = (char*)netDataCache;
		nPos = strHttpHead.find("\r\n\r\n", nNetStart);
		if (nPos < 0)
		{
			WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, http头尚未接收完整 szRequestFileName = %s, nClient = %llu ", this, szRequestFile, nClient);
			return -1;
		}

		bRecvHttpHeadFlag = true;
		memset(szResponseHead, 0x00, sizeof(szResponseHead));
		memcpy((char*)szResponseHead, (char*)netDataCache + nNetStart, nPos - nNetStart + 4);
		netDataCacheLength -= (nPos - nNetStart + 4);
		nNetStart = nPos + 4;

		httpParse.ParseSipString((char*)szResponseHead);

		httpParse.GetFieldValue("Content-Length", szContentValue);
		nContentLength = atoi(szContentValue);
		nRecvContentLength = 0;
		if (nContentLength > nContentBodyLength)
		{//如果内容大于默认值，需要从新分配内存
			delete[] pContentBody;
			pContentBody = NULL;

			nContentBodyLength = nContentLength;
			pContentBody = new unsigned char[nContentBodyLength + 4];
		}

		if (netDataCacheLength >= nContentLength )
		{
			memcpy(pContentBody + nRecvContentLength, netDataCache + nNetStart, nContentLength);

			nRecvContentLength += nContentLength;
			nNetStart += netDataCacheLength;
			netDataCacheLength = 0;
		}
	}
	else
	{
		if (nContentBodyLength - nRecvContentLength > nDataLength)
		{//拼接Content 
			memcpy(pContentBody + nRecvContentLength, pData, nDataLength);

			nRecvContentLength += nDataLength;
 		}
	}

	if (nRecvContentLength >= nContentLength)
	{//接收完毕
		pContentBody[nRecvContentLength] = 0x00;
		if (strstr(szRequestFile, ".m3u8") != NULL)
		{//解析m3u8文件，把TS文件 加入fifo 
			AddM3u8ToFifo((char*)pContentBody, strlen((char*)pContentBody));
		}
		else
		{//TS 
#ifdef  SaveTSBufferToFile
			char szTsFile[256] = { 0 };
			sprintf(szTsFile, "%s%X_%09llu.ts", ABL_MediaSeverRunPath, this, nTsFileOrder);
			FILE* fTsFile = fopen(szTsFile, "wb");
			if (fTsFile)
			{
				fwrite(pContentBody, 1, nContentLength, fTsFile);
				fclose(fTsFile);
			}
			nTsFileOrder ++;
#endif
		}

		requestFileFifo.pop_front(); //移除掉已经接收完毕的文件

		WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, 接收文件完毕，字节大小为%d , szRequestFileName = %s, nClient = %llu ", this, nRecvContentLength, szRequestFile, nClient);

		nNetStart = nNetEnd = nRecvContentLength = 0;
		bRecvHttpHeadFlag = false;

		//请求下一个文件
		SendFirstRequst();
	}
	return 0;

}

3 增加单独请求m3u8纯函数 
   virtual bool  RequestM3u8File() = 0 ;
   
	//请求m3u8文件
	bool  CNetClientRecvHttpHLS::RequestM3u8File()
	{
		//如果文件FIFO为空，证明TS文件全部请求完毕，需要增加m3u8文件到FIFO 
		if (requestFileFifo.GetSize() == 0)
		{
			//不够2秒
			if (GetTickCount() - nSendM3u8Time < 3000)
				return false;

			requestFileFifo.push((unsigned char*)szRequestM3u8File, strlen(szRequestM3u8File));
			SendFirstRequst(); 
			return true;
		}
		else
			return false;
	}

ABLMediaServer-2021-06-13 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 增加把M3u8文件加入下载文件 
	bool   CNetClientRecvHttpHLS::AddM3u8ToFifo(char* szM3u8Data, int nDataLength)
	{
		string strM3u8Data = szM3u8Data;
		int    nStart = 0;
		int    nPos,nPos2;
		char   szLine[256];
		string strLine;
		bool   bEndFlag = false;
		char   szTemp[256] = { 0 };
		int64_t  nNumberTemp;

		while (!bEndFlag)
		{
			nPos = strM3u8Data.find("\n", nStart);
			memset(szLine, 0x00, sizeof(szLine));
			if (nPos > 0)
			{
				memcpy(szLine, szM3u8Data + nStart, nPos - nStart);
				nStart = nPos + 1;
			}
			else
			{
				bEndFlag = true;
				memcpy(szLine, szM3u8Data + nStart, strlen(szM3u8Data) - nStart);
			}

			if (strlen(szLine) > 0)
			{
				memset(szTemp, 0x00, sizeof(szTemp));
				strLine = szLine;
				nPos2 = strLine.find("SEQUENCE:", 0);
				if (nPos2 > 0)
				{
					memcpy(szTemp, szLine + nPos2 + strlen("SEQUENCE:"), strlen(szLine) - nPos2);
					nNumberTemp = atoi(szTemp);
				}
				else
				{
					nPos2 = strLine.find("#EXT", 0);
					if (nPos2 < 0)
					{
						if (nOldRequestM3u8Number != nNumberTemp)
						{
						  sprintf(szTemp, "/Media/%s", szLine);
						  requestFileFifo.push((unsigned char*)szTemp, strlen(szTemp));
						  WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, 加入请求TS文件 szLine = %s, nClient = %llu ", this, szTemp, nClient);
						}
					}
				}
			}
		}

		//更新m3u8序号
		if (nOldRequestM3u8Number != nNumberTemp)
		  nOldRequestM3u8Number = nNumberTemp;

		return true;
	}


ABLMediaServer-2021-06-12-2 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 网络基类增加一个纯虚函数
	//发送第一个请求
	int CNethttpServer::SendFirstRequst()
	{
		return 0;
	}

2  HLS主动拉流客户端增加发送文件请求 函数
	//发送第一个请求
	int CNetClientRecvHttpHLS::SendFirstRequst()
	{
		memset(szRequestBuffer, 0x00, sizeof(szRequestBuffer));
		unsigned char* pData;
		int            nLength;
		char           szRequestFile[256] = { 0 };
		int            nWriteRet;

		pData = requestFileFifo.pop(&nLength);
		if (pData != NULL && nLength > 0)
		{
			memcpy(szRequestFile, (char*)pData, nLength);
			sprintf(szRequestBuffer, "GET %s HTTP/1.1\r\nHost: 10.0.0.239:9088\r\nAccept: */*\r\nConnection: keep-alive\r\nAccept-Language: zh_CN\r\nUser-Agent: %s\r\nRange: bytes=0-\r\n\r\n",
				szRequestFile,
				MediaServerVerson);

			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)szRequestBuffer, strlen(szRequestBuffer), 1);
			if (nWriteRet != 0 )
			{
				WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, 发送请求文件失败 szRequestFileName = %s, nClient = %llu ", this, szRequestFile, nClient);
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				return -1;
			}
		}

		return 0;
	}
	
3 完善 HLS 拉流的业务处理 
	
  int CNetClientRecvHttpHLS::ProcessNetData() 
  {
	std::lock_guard<std::mutex> lock(netDataLock);
	char szContentValue[64] = { 0 };

	int nPos;
	if (!bRecvHttpHeadFlag)
	{
		string  strHttpHead = (char*)netDataCache + nNetStart;
		nPos = strHttpHead.find("\r\n\r\n");
		if (nPos < 0)
		{
			WriteLog(Log_Debug, "CNetClientRecvHttpHLS=%X, http头尚未接收完整 szRequestFileName = %s, nClient = %llu ", this, szRequestFile, nClient);
			return -1;
		}

		bRecvHttpHeadFlag = true;
		memset(szResponseHead, 0x00, sizeof(szResponseHead));
		memcpy((char*)szResponseHead, (char*)netDataCache + nNetStart, nPos - nNetStart + 4);
		netDataCacheLength -= (nPos - nNetStart + 4);
		nNetStart = nPos + 4;

		httpParse.ParseSipString((char*)szResponseHead);

	    httpParse.GetFieldValue("Content-Length", szContentValue);
		nContentLength = atoi(szContentValue);
		nRecvContentLength = 0;
		if (nContentLength > nContentBodyLength)
		{//如果内容大于默认值，需要从新分配内存
			delete[] pContentBody;
			pContentBody = NULL;

			nContentBodyLength = nContentLength;
			pContentBody = new unsigned char[nContentBodyLength+4];
		}

		if (netDataCacheLength > 0)
		{
		   memcpy(pContentBody + nRecvContentLength, netDataCache + nNetStart , netDataCacheLength );

		   nRecvContentLength  += netDataCacheLength ;
		   nNetStart           += netDataCacheLength ;
		   netDataCacheLength  =  0;
		}
	}
	else
	{
		if (nContentBodyLength - nRecvContentLength > netDataCacheLength)
		{//拼接Content 
			memcpy(pContentBody + nRecvContentLength, netDataCache + nNetStart, netDataCacheLength);

			nRecvContentLength += netDataCacheLength;
			nNetStart          += netDataCacheLength;
			netDataCacheLength  = 0;
 		}
	}

	if (nRecvContentLength >= nContentLength)
	{//接收完毕
		requestFileFifo.pop_front(); //移除掉已经接收完毕的文件

		pContentBody[nRecvContentLength] = 0x00;
		if (strstr(szRequestFile, ".m3u8") != NULL)
		{//解析m3u8文件，把TS文件 加入fifo 

		}

		//如果文件FIFO为空，证明TS文件全部请求完毕，需要增加m3u8文件到FIFO 
		if (requestFileFifo.GetSize() == 0)
		{
			requestFileFifo.push((unsigned char*)szRequestM3u8File, strlen(szRequestM3u8File));
		}

		//请求下一个文件
		SendFirstRequst();
	}
	return 0 ;
}
	

ABLMediaServer-2021-06-12 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1 完善m3u8文件内容，h264切片为ts ， H265切片为mp4 
	if (strcmp(pClient->m_mediaCodecInfo.szVideoName, "H264") == 0)
	{//H264切片为TS
	  snprintf(pClient->szTempName, sizeof(pClient->szTempName), "%s/%d.ts", pClient->szTSFileSubPath, pClient->nTsFileOrder);
	  hls_m3u8_add((hls_m3u8_t*)pClient->m3u, pClient->szTempName, pts, duration, discontinue); //szTempName 没有全部路径
 	}
	else if (strcmp(pClient->m_mediaCodecInfo.szVideoName, "H265") == 0)
	{//H265 切片为 mp4
	  snprintf(pClient->szTempName, sizeof(pClient->szTempName), "%s/%d.mp4", pClient->szTSFileSubPath, pClient->nTsFileOrder);
 	  hls_m3u8_add((hls_m3u8_t*)pClient->m3u, pClient->szTempName, dts, duration, 0);
	}
	else
		return -1;//不支持的视频格式
		
2、优化 CNethttpServer 类库的网络接收部分
	//读取网络数据 ，模拟原来底层网络库读取函数 
	int32_t  CNethttpServer::XHNetSDKRead(NETHANDLE clihandle, uint8_t* buffer, uint32_t* buffsize, uint8_t blocked, uint8_t certain)
	{
		std::lock_guard<std::mutex> lock(netDataLock);

		int nWaitCount = 0;
		bExitProcessFlagArray[0] = false;
		while (!bIsInvalidConnectFlag && bRunFlag)
		{
			if (netDataCacheLength >= *buffsize)
			{
				memcpy(buffer, netDataCache + nNetStart, *buffsize);
				nNetStart += *buffsize;
				netDataCacheLength -= *buffsize;
				
				bExitProcessFlagArray[0] = true;
				return 0;
			}
			Sleep(5);
			
			nWaitCount ++;
			if (nWaitCount >= 8)
				break;
		}
		bExitProcessFlagArray[0] = true;

		return -1;  
	}

		
ABLMediaServer-2021-06-11_2 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1  增加HLS切片的二级补充路径
  //获取TS文件的二级补充路径
	string strURL = szURL;
	int    nPos = 0;
	nPos = strURL.rfind("/", strlen(szURL));
	if (nPos > 0)
	{
		memset(szTSFileSubPath, 0x00, sizeof(szTSFileSubPath));
		memcpy(szTSFileSubPath, szURL + nPos + 1, strlen(szURL) - nPos - 1);
	}

2 为修改HLS的路径 优化查找 .m3u8 文件 http://190.15.240.11:9088/Media/Camera_00001.m3u8
	nPos = strRequestFileName.rfind(".m3u8",strlen(szRequestFileName));
	if (nPos > 0)
	{
		memcpy(szPushName,szRequestFileName,nPos);
 	}else 
	{
		nPos = strRequestFileName.rfind("/", strlen(szRequestFileName));
		if(nPos > 0)
		   memcpy(szPushName, szRequestFileName, nPos);
	}

3 优化函数 根据TS文件名字 ，获取文件序号 
	int64_t  CNetServerHLS::GetTsFileNameOrder(char* szTsFileName)
	{
		string strTsFileName = szTsFileName;
		int    nPos1, nPos2;
		char   szTemp[128] = { 0 };

		nPos1 = strTsFileName.rfind("/", strlen(szTsFileName));
		nPos2 = strTsFileName.find(".ts", 0);
		if (nPos1 > 0 && nPos2 > 0)
		{//ts 
			memcpy(szTemp, szTsFileName + nPos1 + 1, nPos2 - nPos1 - 1);
			return atoi(szTemp);
		}
		else
		{//mp4 
			nPos2 = strTsFileName.find(".mp4", 0);
			if (nPos1 > 0 && nPos2 > 0)
			{
			  memcpy(szTemp, szTsFileName + nPos1 + 1, nPos2 - nPos1 - 1);
			  return atoi(szTemp);
			}
		}
		return  -1 ;
	}

ABLMediaServer-2021-06-11 【增加HLS切片，H264浏览器播放首次正常版本\稳定版本】
1、增加网络异常断线检测，现在只增加 HLS发送、RTMP推流接收  进行网络异常清理 
	//检测网络断线 
	int  CheckNetRevcBaseClientDisconnect()
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;
		int                           nDiconnectCount = 0;

		for (iterator1 = xh_ABLNetRevcBaseMap.begin(); iterator1 != xh_ABLNetRevcBaseMap.end(); ++iterator1)
		{
			if (((*iterator1).second)->netBaseNetType == NetBaseNetType_HttpHLSServerSendPush || //HLS　发送
				((*iterator1).second)->netBaseNetType == NetBaseNetType_RtmpServerRecvPush       //接收RTMP推流
				)   
			{//现在检测 HLS 网络断线 ，还可以增加别的类型检测
				((*iterator1).second)->nRecvDataTimerBySecond ++;

			   if (((*iterator1).second)->nRecvDataTimerBySecond >= MaxRecvDataTimerBySecondDiconnect )
			   {
				   nDiconnectCount ++;
				   pDisconnectBaseNetFifo.push((unsigned char*)&((*iterator1).second)->nClient, sizeof((unsigned char*)&((*iterator1).second)->nClient));
			   }
			}
		}
	 
		return nDiconnectCount;
	}

ABLMediaServer-2021-06-10 【增加HLS切片，H264浏览器播放首次正常版本】
1  在InputData 函数，需要清空历史废旧数据 ，因为里面有废旧的 \r\n\r\n 
	//清空历史废旧数据
	memset(netDataCache + nNetEnd, 0x00, sizeof(netDataCache) - nNetEnd);

	int CNetServerHLS::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength)
	{
		std::lock_guard<std::mutex> lock(netDataLock);

		WriteLog(Log_Debug, "CNetServerHLS= %X , nClient = %llu ,收到片段数据\r\n%s",this,nClient,pData);
	 
		if (MaxNetDataCacheCount - nNetEnd >= nDataLength)
		{//剩余空间足够
			memcpy(netDataCache + nNetEnd, pData, nDataLength);
			netDataCacheLength += nDataLength;
			nNetEnd += nDataLength;
		}
		else
		{//剩余空间不够，需要把剩余的buffer往前移动
			if (netDataCacheLength > 0 && netDataCacheLength == (nNetEnd - nNetStart) )
			{//如果有少量剩余
				memmove(netDataCache, netDataCache + nNetStart, netDataCacheLength);
				nNetStart = 0;
				nNetEnd = netDataCacheLength;

				//清空历史废旧数据
				memset(netDataCache + nNetEnd, 0x00, sizeof(netDataCache) - nNetEnd);
			}
			else
			{//没有剩余，那么 首，尾指针都要复位 
				nNetStart = 0;
				nNetEnd = 0;
				netDataCacheLength = 0;

				//清空历史废旧数据
				memset(netDataCache + nNetEnd, 0x00, sizeof(netDataCache) - nNetEnd);
			}
			memcpy(netDataCache + nNetEnd, pData, nDataLength);
			netDataCacheLength += nDataLength;
			nNetEnd += nDataLength;
		}
		return true;
	}

2  把加入拷贝链表的代码删除掉，HLS视频不需要拷贝 
	nRequestFileCount ++;
	//把客户端 加入源流媒体拷贝队列 ，但是HLS 协议，不需要拷贝
	if(nRequestFileCount == 1)
	  pushClient->AddClientToMap(nClient);
	
3  在HLS析构函数中，删除掉 	 DeleteClientMediaStreamSource(nClient);
	//从媒体拷贝线程池移除
	DeleteClientMediaStreamSource(nClient);

ABLMediaServer-2021-06-09 【增加HLS切片，H264浏览器播放首次正常版本】
1 修正读取http头函数 ，copy 头文件要移动初始位置  nNetStart
	//读取http请求buffer 
	bool  CNetServerHLS::ReadHttpRequest()
	{
		std::lock_guard<std::mutex> lock(netDataLock);

		if (netDataCacheLength <= 0 || nNetStart <  0)
			return false;
	 
		string strNetData = (char*)netDataCache ;
		int    nPos;
		nPos = strNetData.find("\r\n\r\n", nNetStart);

		if (nPos <= 0 || (nPos - nNetStart) + 4 > sizeof(szHttpRequestBuffer))
			return false;
	 
		memset(szHttpRequestBuffer, 0x00, sizeof(szHttpRequestBuffer));
		memcpy(szHttpRequestBuffer, netDataCache + nNetStart , (nPos - nNetStart) + 4);

		nNetStart             =   nPos  + 4 ; //这个4 ，就是 "\r\n\r\n"， 已经拷贝走了。
		netDataCacheLength   -=   (nPos - nNetStart) + 4 ; //这个4 ，就是 "\r\n\r\n" , 已经拷贝走了。

		return true;
	}


2、修正	短连接 的判断错误BUG 

	//发送完毕,如果是短连接，立即删除
	if(strcmp(szConnectionType,"Close") == 0 || strcmp(szConnectionType, "close") == 0 || bRequestHeadFlag == true)
	  pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
	
	
3 修正从HTTP头中获取请求的文件名
	
	bool CNetServerHLS::GetHttpRequestFileName(char* szGetRequestFile,char* szHttpHeadData)
	{
		string  strHttpHead = (char*)szHttpHeadData;
		int     nPos1, nPos2;
		char    szFindHead[64] = { 0 };
		int     nHeadLength = 4 ;

		strcpy(szFindHead, "HEAD ");
		nPos1 = strHttpHead.find(szFindHead, 0);
		if (nPos1 < 0)
		{
			memset(szFindHead, 0x00, sizeof(szFindHead));
			strcpy(szFindHead, "GET ");
			nPos1 = strHttpHead.find(szFindHead, 0);
		}
		else//采用head 请求m3u8 文件 
			bRequestHeadFlag = true;

		nHeadLength = strlen(szFindHead);

		if (nPos1 >= 0)
		{
			nPos2 = strHttpHead.find(" HTTP/", 0);
			if (nPos2 > 0)
			{
				memcpy(szGetRequestFile, szHttpHeadData + nPos1 + nHeadLength, nPos2 - nPos1 - nHeadLength);
				WriteLog(Log_Debug, "CNetServerHLS=%X ,nClient = %llu ,拷贝出HTTP 请求 文件名字 %s ", this, nClient, szGetRequestFile);
				return true;
			}
		}
		return false;
	}

ABLMediaServer-2021-06-08 【增加HLS切片】
1 调用boost 产生 uuid,再删除 - ,作为 Cookie 
	//更新Cookie 
 	memset(szCookieNumber, 0x00, sizeof(szCookieNumber));
	boost::uuids::uuid a_uuid = boost::uuids::random_generator()(); // 这里是两个() ，因为这里是调用的 () 的运算符重载
	string tmp_uuid = boost::uuids::to_string(a_uuid); //产生uuid
	boost::algorithm::erase_all(tmp_uuid, "-");//删除 - 
	strcpy(szCookieNumber,tmp_uuid.c_str());

ABLMediaServer-2021-06-07 【增加HLS切片】
1 完善 media-server-master\Example\httpDemo-2021-03-17 录像例子
  增加支持 h264 + g711a 、h264+g711u 、 h265+g711a 、h265+g711u

2 修正HLS客户端的创建，否则HLS刚刚创建，就被删除 
	if (memcmp(szIP, "http://", 7) == 0 && strstr(szIP,".m3u8") != NULL )
	{
		pXHClient = boost::make_shared<CNetClientRecvHttpHLS>(serverHandle, CltHandle, szIP, nPort);
	}
	else if (memcmp(szIP, "http://", 7) == 0 )
	{

	}
	else if (memcmp(szIP, "http://", 7) == 0 )
	{

	}
	else if (memcmp(szIP, "rtmp://", 7) == 0 )
	{

	}else //修正 这个BUG   
	  return NULL;

3  HLS 构造函数时，要把nClient赋值给CltHandle ，如果连接失败，回调函数有通知，再删除掉即可 
	if (memcmp(szIP, "http://", 7) == 0 && strstr(szIP,".m3u8") != NULL )
	{
		//在构造函数进行异步连接，会产生一个nClient值 
		pXHClient = boost::make_shared<CNetClientRecvHttpHLS>(serverHandle, CltHandle, szIP, nPort);
		CltHandle = pXHClient->nClient; //把nClient赋值给 CltHandle ,作为关键字 ，如果连接失败，会收到回调通知，在回调通知进行删除即可 
	}
	  
4 修改了底层网络库，这样连接失败时，才有回调通知 

	  
ABLMediaServer-2021-06-06 【增加HLS切片】
1 增加url分析

2 增加htt-hls 接收 

ABLMediaServer-2021-06-03 【增加HLS切片】
1 增加视频帧类型判断 
	/*
	检测视频是否是I帧
	*/
	bool  CMediaStreamSource::CheckVideoIsIFrame(unsigned char* szPVideoData, int nPVideoLength)
	{
		int nPos = 0;
		bool bVideoIsIFrameFlag = false;
		unsigned char  nFrameType = 0x00;

		if (memcmp(szPVideoData, szVideoFrameHead, 4) == 0)
		{//找到帧片段
			if (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0)
			{
				nFrameType = (szPVideoData[4] & 0x1F);
				if (nFrameType == 7 || nFrameType == 8 || nFrameType == 5)
				{//SPS   PPS   IDR 
					bVideoIsIFrameFlag = true;
				}
			}
			else if (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0)
			{
				nFrameType = (szPVideoData[ 4] & 0x7E) >> 1;
				if ((nFrameType >= 16 && nFrameType <= 21) || (nFrameType >= 32 && nFrameType <= 34))
				{//SPS   PPS   IDR 
					bVideoIsIFrameFlag = true;
				}
			}
		}

		return bVideoIsIFrameFlag;
	}

2 增加http拉流、写mp4文件 

ABLMediaServer-2021-05-31 【增加HLS切片】
1 优化回复包，EasyPlayer.js 播放hls,基本正常 ，不完全正常  

ABLMediaServer-2021-05-24 【增加HLS切片】
1 采用SRS的通信格式 

2 优化TS 文件发送
	else if (strstr(szRequestFileName, ".ts") != NULL)
	{//请求TS文件 
		nTsFileNameOrder = GetTsFileNameOrder(szRequestFileName);
		if (nTsFileNameOrder == -1)
		{
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1;
		}

		//TS文件总字节数
		fFileByteCount = pushClient->GetTsFileSizeByOrder(nTsFileNameOrder);
		if (fFileByteCount <= 0)
		{//TS文件字节数量有误
			WriteLog(Log_Debug, "CNetServerHLS=%X, 文件打开失败 szReadFileName = %s nClient = %llu ", this, szReadFileName, nClient);

			sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: Close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1;
		}
		unsigned char*  pTsFileBuffer = new unsigned char[fFileByteCount];

		if (ABL_MediaServerPort.nHLSCutType == 1)
		{//切片到硬盘
			sprintf(szReadFileName, "%s\\%s", ABL_wwwMediaPath, szRequestFileName);
			WriteLog(Log_Debug, "CNetServerHLS=%X, 开始读取TS文件 szReadFileName = %s nClient = %llu ", this, szReadFileName, nClient);
			FILE* tsFile = fopen(szReadFileName,"rb");
			if (tsFile == NULL)
			{//打开TS文件失败
				WriteLog(Log_Debug, "CNetServerHLS=%X, 文件打开失败 szReadFileName = %s nClient = %llu ", this, szReadFileName, nClient);

				sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: Close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
				nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				return -1;
			}
    		fread(pTsFileBuffer,1, fFileByteCount, tsFile);
 			fclose(tsFile);
		}
		else if (ABL_MediaServerPort.nHLSCutType == 2)
		{
  			pushClient->CopyTsFileBuffer(nTsFileNameOrder, pTsFileBuffer);
   		}

		//发送http头
		sprintf(httpResponseData, "HTTP/1.1 200 OK\r\nAccess-Control-Allow-Headers: origin,range,accept-encoding,referer,Cache-Control,X-Proxy-Authorization,X-Requested-With,Content-Type\r\nAccess-Control-Allow-Methods: GET, POST, HEAD, PUT, DELETE, OPTIONS\r\nAccess-Control-Allow-Origin: *\r\nAccess-Control-Expose-Headers: Server,range,Content-Length,Content-Range\r\nConnection: %s\r\nContent-Length: %d\r\nContent-Type: video/MP2T\r\nServer: %s\r\n\r\n",
			szConnectionType,
			fFileByteCount,
			MediaServerVerson);
		nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

		//发送TS码流 
		int             nPos = 0;
 		while (fFileByteCount > 0 && pTsFileBuffer != NULL)
		{
			if (fFileByteCount > Send_TsFile_MaxPacketCount)
			{
				nWriteRet2 = XHNetSDK_Write(nClient, (unsigned char*)pTsFileBuffer + nPos, Send_TsFile_MaxPacketCount, 1);
				fFileByteCount -= Send_TsFile_MaxPacketCount;
				nPos += Send_TsFile_MaxPacketCount;
			}
			else
			{
				nWriteRet2 = XHNetSDK_Write(nClient, (unsigned char*)pTsFileBuffer + nPos, fFileByteCount, 1);
				nPos += fFileByteCount;
				fFileByteCount = 0;
			}

			if (nWriteRet2 != 0)
			{//发送出错
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				break;
			}
		}
		delete[] pTsFileBuffer;
		pTsFileBuffer = NULL;
	}

ABLMediaServer-2021-05-23 【增加HLS切片】
1 增加H265切片 
	if (ABL_MediaServerPort.nHlsEnable == 1 && m3u == NULL)
	{
		if (strcmp(m_mediaCodecInfo.szVideoName, "H264") == 0)
		{
		    m3u =   hls_m3u8_create(0, 3);
		    hls =   hls_media_create(HLS_DURATION * 1000, hls_handler, (void*)this);
		} 
		else if (strcmp(m_mediaCodecInfo.szVideoName, "H265") == 0)
		{
			m3u     =  hls_m3u8_create(0, 7);
			hlsFMP4 =  hls_fmp4_create(HLS_DURATION * 1000, hls_handler, (void*)this);

			szExtenAudioData[0] = 0x14;
			szExtenAudioData[1] = 0x08;

			char szExFile[256] = { 0 };
			sprintf(szExFile, "%s%s", ABL_MediaSeverRunPath,"h265_1920.sps");
			FILE* fFile = fopen(szExFile, "rb");
			fread(szExtenVideoData, 1, 1091, fFile);
			track_265 = hls_fmp4_add_video(hlsFMP4, MOV_OBJECT_HEVC, 1920, 1080, szExtenVideoData, 1091);
			fclose(fFile);

			track_aac = hls_fmp4_add_audio(hlsFMP4, MOV_OBJECT_AAC, 1, 16,16000, szExtenAudioData, 2);

			// write init segment
			int bytes = hls_fmp4_init_segment(hlsFMP4, s_packet, sizeof(s_packet));

			sprintf(szExFile, "%s%s", szHLSPath, "0.mp4");
			FILE* fp = fopen(szExFile, "wb");
			fwrite(s_packet, 1, bytes, fp);
			fclose(fp);

			hls_m3u8_set_x_map(m3u, "0.mp4");
		}
	}

2 如果发送TS流报错，立即退出循环 ，加入关闭链表 
	if (nWriteRet2 != 0)
	{//发送出错
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		break;
	}

ABLMediaServer-2021-05-21 【增加HLS切片】
1 增加获取hls 的http 连接方式，是否为Close ，Keep-live ,如果是短连接，则需要交互完成后，立即删除 
	//获取Connection 连接方式： Close ,Keep-Live  
	memset(szConnectionType, 0x00, sizeof(szConnectionType));
	if (!httpParse.GetFieldValue("Connection", szConnectionType))
		strcpy(szConnectionType, "Close");

2 限制m3u8文件尚未生成，即刚刚开始切片，但是还不够3个文件 
	if (strlen(pushClient->szDataM3U8) == 0)
	{//m3u8文件尚未生成，即刚刚开始切片，但是还不够3个文件 
		WriteLog(Log_Debug, "CNetServerHLS=%X, m3u8文件尚未生成，即刚刚开始切片，但是还不够3个TS文件 %s nClient = %llu ", this, szPushName, nClient);

		sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: Close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
		nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		return -1;
	}

ABLMediaServer-2021-05-20 【增加HLS切片】
1 媒体源的m3u8更新、拷贝需要枷锁 
	//更新m3u8
	void CMediaStreamSource::CopyM3u8Buffer(char* szM3u8Buffer)
	{
		std::lock_guard<std::mutex> lock(mediaTsFileLock);
		memset(szDataM3U8, 0x00, sizeof(szDataM3U8));
		strcpy(szDataM3U8, szM3u8Buffer);
	}

	//外部读取m3u8数据
	bool   CMediaStreamSource::ReturnM3u8Buffer(char* szOutM3u8)
	{
		std::lock_guard<std::mutex> lock(mediaTsFileLock);
		if (strlen(szDataM3U8) == 0)
			return false;
		strcpy(szOutM3u8, szDataM3U8);
		return true;
	}
	
2 完善m3u8媒体文件发送、TS文件发送 
	int CNetServerHLS::ProcessNetData()
	{
		if (strstr((char*)netDataCache, "\r\n\r\n") == NULL)
		{
			WriteLog(Log_Debug, "数据尚未接收完整 ");
			return -1;
		}

		netDataCache[netDataCacheLength] = 0x00;
		WriteLog(Log_Debug, "CNetServerHLS=%X ,收到HLS协议\r\n %s ", this, netDataCache);

		//获取出HTTP请求的文件名字 
		memset(szRequestFileName, 0x00, sizeof(szRequestFileName));
		if (!GetHttpRequestFileName(szRequestFileName))
		{
			WriteLog(Log_Debug, "CNetServerHLS=%X, 获取http 请求文件失败！ nClient = %llu ", this, nClient);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1;
		}  

		string strRequestFileName = szRequestFileName;
		int    nPos;
		nPos = strRequestFileName.rfind( "/",strlen(szRequestFileName));
		if (nPos > 0)
		{
			memset(szPushName, 0x00, sizeof(szPushName));
			memcpy(szPushName,szRequestFileName,nPos);
		}
	 
		WriteLog(Log_Debug, "CNetServerHLS=%X, 获取到HLS的推流源名字 szPushName = %s , nClient = %llu ", this, szPushName, nClient);
	  
		//根据推流名字找到
		boost::shared_ptr<CMediaStreamSource> pushClient = GetMediaStreamSource(szPushName);
		if (pushClient == NULL)
		{
			WriteLog(Log_Debug, "CNetServerHLS=%X, 没有推流对象的地址 %s nClient = %llu ", this, szPushName, nClient);

			sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1;
		}

		nRequestFileCount ++;
		//把客户端 加入源流媒体拷贝队列 ，但是HLS 协议，不需要拷贝
		if(nRequestFileCount == 1)
		   pushClient->AddClientToMap(nClient);

		if (strstr(szRequestFileName, ".m3u8") != NULL)
		{//请求M3U8文件
			memset(szM3u8Content, 0x00, sizeof(szM3u8Content));
			strcpy(szM3u8Content, pushClient->szDataM3U8);
			sprintf(httpResponseData, "HTTP/1.1 206 Partial Content\r\nConnection: close\r\nContent-Length: %d\r\nContent-Range: bytes 0-%d/%d\r\nContent-Type: application/vnd.apple.mpegurl; charset=utf-8\r\nDate: Fri, May 21 2021 01:41:53 GMT\r\nServer: %s\r\nSet-Cookie: ABL_COOKIE=48a95efc235fa43fb4ec0582637616c4;expires=Fri, May 21 2021 01:42:53 GMT;path=%s\r\n\r\n", 
				strlen(szM3u8Content),strlen(szM3u8Content)-1,strlen(szM3u8Content), MediaServerVerson, szPushName);
			nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);
			nWriteRet2 = XHNetSDK_Write(nClient, (unsigned char*)szM3u8Content, strlen(szM3u8Content), 1);
			if (nWriteRet != 0 || nWriteRet2 != 0)
			{
				WriteLog(Log_Debug, "CNetServerHLS=%X, 回复http失败 szRequestFileName = %s, nClient = %llu ", this, szRequestFileName, nClient);
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				return -1;
			}

			WriteLog(Log_Debug, "CNetServerHLS=%X, nClient = %llu 发出http回复：\r\n%s", this, nClient, httpResponseData);
			WriteLog(Log_Debug, "CNetServerHLS=%X, nClient = %llu 发出http回复：\r\n%s", this, nClient, szM3u8Content);
		}
		else if (strstr(szRequestFileName, ".ts") != NULL)
		{//请求TS文件 
			if (ABL_MediaServerPort.nHLSCutType == 1)
			{//切片到硬盘
				sprintf(szReadFileName, "%s\\%s", ABL_wwwMediaPath, szRequestFileName);
				WriteLog(Log_Debug, "CNetServerHLS=%X, 开始读取TS文件 szReadFileName = %s nClient = %llu ", this, szReadFileName, nClient);
				HANDLE hReadHandle = ::CreateFile(szReadFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
				if (hReadHandle == INVALID_HANDLE_VALUE)
				{
					WriteLog(Log_Debug, "CNetServerHLS=%X, 文件打开失败 szReadFileName = %s nClient = %llu ", this, szReadFileName, nClient);

					sprintf(httpResponseData, "HTTP/1.1 404 Not Found\r\nConnection: close\r\nDate: Thu, Feb 18 2021 01:57:15 GMT\r\nKeep-Alive: timeout=30, max=100\r\nAccess-Control-Allow-Origin: *\r\nServer: %s\r\n\r\n", MediaServerVerson);
					nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
					return -1;
				}
				//总字节数
				fFileByteCount = GetFileSize(hReadHandle, NULL);
				sprintf(httpResponseData, "HTTP/1.1 206 Partial Content\r\nConnection: close\r\nContent-Length: %d\r\nContent-Range: bytes 0-%d/%d\r\nContent-Type: video/mp2t; charset=utf-8\r\nDate: Fri, May 21 2021 01:41:53 GMT\r\nServer: %s\r\n\r\n",
					fFileByteCount, fFileByteCount - 1, fFileByteCount, MediaServerVerson);
				nWriteRet = XHNetSDK_Write(nClient, (unsigned char*)httpResponseData, strlen(httpResponseData), 1);

				char*  pTsFileBuffer = new char[fFileByteCount];
				unsigned long dwReadLength;
				ReadFile(hReadHandle, pTsFileBuffer, fFileByteCount, &dwReadLength, NULL);
				int nPos = 0 ;
				while (fFileByteCount > 0)
				{
					if (fFileByteCount > Send_TsFile_MaxPacketCount)
					{
					   nWriteRet2 = XHNetSDK_Write(nClient, (unsigned char*)pTsFileBuffer + nPos, Send_TsFile_MaxPacketCount, 1);
					   fFileByteCount -= Send_TsFile_MaxPacketCount;
					   nPos           += Send_TsFile_MaxPacketCount;
					}
					else
					{
					   nWriteRet2 = XHNetSDK_Write(nClient, (unsigned char*)pTsFileBuffer + nPos , fFileByteCount, 1);
					   nPos += fFileByteCount;
					   fFileByteCount = 0 ;
					}
				}
				CloseHandle(hReadHandle);
				delete[] pTsFileBuffer;
				pTsFileBuffer = NULL;
			}
		}
		else
		{
			WriteLog(Log_Debug, "CNetServerHLS=%X, 请求 http 文件类型有误 szRequestFileName = %s, nClient = %llu ", this, szRequestFileName, nClient);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1;
		}

		//发送完毕
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		return 0;
	}

ABLMediaServer-2021-05-20 【增加HLS切片】
1 创建www子路径 
	sprintf(ABL_wwwMediaPath, "%s\\www", ABL_MediaSeverRunPath);
	::CreateDirectory(ABL_wwwMediaPath,NULL);
	WriteLog(Log_Error, "www 路径为 %s ", ABL_wwwMediaPath);

2 HLS 切片 子路径 
	//根据URL /Media/Camera_00001 创建子路径  
	void  CMediaStreamSource::CreateSubPathByURL(char* szMediaURL)
	{
		memset(szHLSPath, 0x00, sizeof(szHLSPath));

		strcpy(szHLSPath, ABL_wwwMediaPath);

		string strMediaURL = szMediaURL;
		int               nPos = 1, nFind;
		char              szTemp[256] = { 0 };

		while (true)
		{
			memset(szTemp, 0x00, sizeof(szTemp));
			nFind = strMediaURL.find("/", nPos + 1);
			if (nFind > 0)
			{
				memcpy(szTemp, szMediaURL + nPos, nFind - nPos);
				nPos = nFind ;

				strcat(szHLSPath, "\\");
				strcat(szHLSPath, szTemp);

				::CreateDirectory(szHLSPath, NULL);
				WriteLog(Log_Debug, "创建HLS子路径 %s ", szHLSPath);
			}
			else
			{
				memcpy(szTemp, szMediaURL + nPos+1, strlen(szMediaURL) - nPos);
	 
				strcat(szHLSPath, "\\");
				strcat(szHLSPath, szTemp);
				::CreateDirectory(szHLSPath, NULL);
				WriteLog(Log_Debug, "创建HLS子路径 %s ", szHLSPath);
				break;
			}
		}
		strcat(szHLSPath, "\\");
	}

3  增加删除一个目录下面所有文件，在删除路径之前要确保该路径里面所有文件都被删除 
	void CMediaStreamSource::ABLDeletePath(char* szDeletePath)
	{
		HANDLE  hFile = INVALID_HANDLE_VALUE;
		WIN32_FIND_DATA    pNextInfo;
		bool               bFind = true;
		char               szDeleteFile[256];

		hFile = FindFirstFile(szDeletePath, &pNextInfo);
		while (bFind)
		{
			if (pNextInfo.cFileName[0] != '.')
			{
				sprintf(szDeleteFile, "%s%s", szHLSPath, pNextInfo.cFileName);
				DeleteFile(szDeleteFile);
				WriteLog(Log_Debug, "删除异常文件： %s ", szDeleteFile);
			}

			bFind = FindNextFile(hFile, &pNextInfo);
		}
		if(hFile != INVALID_HANDLE_VALUE)
		  FindClose(hFile);
	}

4、增加HLS端口请求类库
    NetServerHLS.cpp
    NetServerHLS.h
	
ABLMediaServer-2021-05-19 【增加HLS切片】
1  视频源增加计算帧速度 
	void CMediaStreamSource::CalcVideoFrameSpeed()
	{
		if (nCalcFrameSpeedCount >= 60)
			return; //视频帧速度已经平稳，不需要再计算 

		nPushVideoFrameCount++;//单位时间内加入视频帧总数 
		if (abs(nCalcFrameSpeedStartTime - 0) < 0.001)
			nCalcFrameSpeedStartTime = ::GetTickCount();//计算帧速度开始时间
														//够5秒 ，计算视频帧速度 												
		if (nPushVideoFrameCount >= 25 * 5)
		{
			nCalcFrameSpeedEndTime = ::GetTickCount();  //计算帧速度结束时间
			TempVideoFrameSpeed = (nPushVideoFrameCount / (nCalcFrameSpeedEndTime - nCalcFrameSpeedStartTime)) * 1000.00;
			
			//修正帧速度
			if (TempVideoFrameSpeed >= 23 && TempVideoFrameSpeed <= 24)
				TempVideoFrameSpeed = 25; 

			if (abs(TempVideoFrameSpeed - VideoFrameSpeed) >= 5)
			{//帧速度误差有5帧时，才修正视频帧速度，否则会操作VLC播放声音丢失 
				VideoFrameSpeed = TempVideoFrameSpeed;
				m_mediaCodecInfo.nVideoFrameRate = VideoFrameSpeed;
				WriteLog(Log_Debug, "CMediaStreamSource= %X,视频帧速度有变化，前后速度误差超过5帧，需要修正视频帧速度 nClient = %llu,TempVideoFrameSpeed = %d,  VideoFrameSpeed = %d ", this, nClient, TempVideoFrameSpeed, VideoFrameSpeed);
			}

			nPushVideoFrameCount = 0;
			nCalcFrameSpeedStartTime = 0;
			nCalcFrameSpeedCount ++;//累计 计算视频帧速度次数 
		}
	}

2 删除多余的TS切片文件
	//删除多余的TS文件　
	if (pClient->tsFileFifo.GetSize() > MaxStoreTsFileCount)
	{
		unsigned char* pData = NULL;
		int            nLength = 0;
		char           szDelName[256] = { 0 };
		while(pClient->tsFileFifo.GetSize() > MaxStoreTsFileCount && (pData = pClient->tsFileFifo.pop(&nLength)) != NULL)
		{
			memset(szDelName, 0x00, sizeof(szDelName));
			memcpy(szDelName, pData, nLength);

			::DeleteFile(szDelName);
			WriteLog(Log_Debug, "媒体源：m_szURL = %s 执行删除文件：%s  ", pClient->m_szURL, szDelName );

			pClient->tsFileFifo.pop_front();
		}
	}

3、在视频源销毁时，增加删除TS文件 
	//最后删除文件　
	if (tsFileFifo.GetSize() > 0 )
	{
		unsigned char* pData = NULL;
		int            nLength = 0;
		char           szDelName[256] = { 0 };
		while (tsFileFifo.GetSize() > 0 && (pData = tsFileFifo.pop(&nLength)) != NULL)
		{
			memset(szDelName, 0x00, sizeof(szDelName));
			memcpy(szDelName, pData, nLength);

			::DeleteFile(szDelName);
			WriteLog(Log_Debug, "媒体源销毁时删除TS切片文件 ：m_szURL = %s 执行删除文件：%s  ", m_szURL, szDelName);

			tsFileFifo.pop_front();
		}
	}
	tsFileFifo.FreeFifo();
	
4、在视频源销毁时，增加删除m3u8文件 	
	//删除M3U8 文件 
	if (strlen(szM3u8Name) > 0)
	{
		::DeleteFile(szM3u8Name);
		WriteLog(Log_Debug, "媒体源销毁时删除m3u8文件 ：m_szURL = %s 执行删除M3U8文件：%s  ", m_szURL, szM3u8Name);
	}
	
ABLMediaServer-2021-05-18 【增加HLS切片】
1 增加H264的切片 	
	static int hls_handler(void* m3u8, const void* data, size_t bytes, int64_t pts, int64_t dts, int64_t duration)
	{
		CMediaStreamSource* pClient = (CMediaStreamSource*)m3u8;

		if (pClient == NULL)
			return -1;

		int discontinue = -1 != pClient->s_dts ? 0 : (dts > pClient->s_dts + HLS_DURATION / 2 ? 1 : 0);
		pClient->s_dts = dts;

		snprintf(pClient->szTempName, sizeof(pClient->szTempName), "%d.ts", pClient->nTsFileOrder);
		hls_m3u8_add((hls_m3u8_t*)pClient->m3u, pClient->szTempName, pts, duration, discontinue); //szTempName 没有全部路径
		
		memset(pClient->szTsName, 0x00, sizeof(pClient->szTsName));//szTsName  包括全部路径
		snprintf(pClient->szTsName, sizeof(pClient->szTsName), "%s%d.ts", ABL_MediaSeverRunPath, pClient->nTsFileOrder);
		pClient->nTsFileOrder ++;//递增

		FILE* fp = fopen(pClient->szTsName, "wb");
		if (fp)
		{
			fwrite(data, 1, bytes, fp);
			fclose(fp);
			pClient->nTsFileCount++;
		}

		if (pClient->nTsFileCount >= 3)
		{//重新切片 
			pClient->nTsFileCount = 0;

			memset(pClient->szDataM3U8, 0x00, sizeof(pClient->szDataM3U8));
			memset(pClient->szTsName, 0x00, sizeof(pClient->szTsName));

			hls_m3u8_playlist(pClient->m3u, 1, pClient->szDataM3U8, sizeof(pClient->szDataM3U8));
			snprintf(pClient->szTsName, sizeof(pClient->szTsName), "%splaylist.m3u8", ABL_MediaSeverRunPath);
			FILE* fp = fopen(pClient->szTsName, "wb");
			if (fp)
			{
				fwrite(pClient->szDataM3U8, 1, strlen(pClient->szDataM3U8), fp);
				fclose(fp);
			} 

			//更新文件列表的seq 
			hls_m3u8_setSeq(pClient->m3u, hls_m3u8_count(pClient->m3u));

			hls_m3u8_clearFileList(pClient->m3u); //增加清除文件列表函数，不需要删除m3u8，不需要删除hls切片句柄 
		}

		return 0;
	}

ABLMediaServer-2021-04-25 【超强压测，服务器稳定版本、解决CPU暴涨BUG】
1 NethttpServer 类中增加响应 GET_PARAMETER ，否则会切断客户端的连接 
	else if (memcmp(pRecvData, "GET_PARAMETER", 13) == 0 && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
	{
		memset(szCSeq, 0x00, sizeof(szCSeq));
		GetFieldValue("CSeq", szCSeq);

		sprintf(szResponseBuffer, "http/1.0 200 OK\r\nCSeq: %s\r\nPublic: %s\r\nx-Timeshift_Range: clock=20100318T021915.84Z-20100318T031915.84Z\r\nx-Timeshift_Current: clock=20100318T031915.84Z\r\n\r\n", szCSeq, httpServerPublic);
		nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		if (nSendRet != 0)
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));

	}

ABLMediaServer-2021-04-22 【超强压测，服务器稳定版本、解决CPU暴涨BUG】
1 只是把代码整合在一起，
2 整合rtp打包、解包、网络，flv ,rtmp 不需要依赖VC2015运行库 

ABLMediaServer-2021-04-20 【超强压测，服务器稳定版本、解决CPU暴涨BUG】
1 、增加客户端存储最大下标字段  nMaxClientArraySize
	//每个线程所包含的客户端ID  
	struct ThreadContainClient
	{
		int          nThreadOrder; //线程序号 0 、1、2、3、4 .... N  
		int          nTrueClientsCount; //记录该线程真正包括的客户端个数 
		uint64_t     nClients[MaxMediaSendThreadCount];//记录该线程的客户端ID数组 ,预分配4096个 ，但是实际以 nTrueClientsCount 为准 
		int          nMaxClientArraySize; //存放在数组中最大的下标 

		ThreadContainClient()
		{
			nThreadOrder = 0;
			nTrueClientsCount = 0;
			nMaxClientArraySize = 0;
			for (int i = 0; i < MaxMediaSendThreadCount; i++)
				nClients[i] = 0;
		}
	};


	//已经找到客户端数量最少的线程ID
	if (nMinThreadContainClientThread >= 0 && nMinThreadContainClientThread < nCreateThreadProcessCount)
	{
		bool FillArrayPositionFlag = false; //是否已经成功占位
		int  nMaxArraySize = 1;//最大数组下标 ，重新计算存储位置最大下标值  

		for (int i = 0; i < nCreateThreadProcessCount; i++)
		{
			if (!FillArrayPositionFlag)
			{
			   if (threadContainClient[nMinThreadContainClientThread].nClients[i] == 0)
			   {
				 threadContainClient[nMinThreadContainClientThread].nClients[i] = nClient; //把ClientID 放置在空缺的位置上 
				 threadContainClient[nMinThreadContainClientThread].nTrueClientsCount += 1; //客户端总数加1  

				 FillArrayPositionFlag = true; //占位成功 
				 //WriteLog(Log_Debug, "把客户端 nClient = %llu 成功加入到媒体发送线程池 ,nThreadID = %d ", nClient, i);
				}
			 }

			if (threadContainClient[nMinThreadContainClientThread].nClients[i] > 0)
			{
				nMaxArraySize = i + 1;
			}
		 }

		threadContainClient[nMinThreadContainClientThread].nMaxClientArraySize = nMaxArraySize;//更新nClient 存储位置的最大数组下标 
	}

2、在网络关闭回调函数中，增加立即从线程池移除、从拷贝线程移除操作。达到快速不发送、快速不拷贝 
	void LIBNET_CALLMETHOD	onclose(NETHANDLE srvhandle,
		NETHANDLE clihandle)
	{ //从何这里断开的话，如果大量链接同时断开，会造成卡住，从而造成视频卡顿，要先加入链表，然后定期（500毫秒断开一路） 
		//DeleteNetRevcBaseClient(clihandle);

		pMediaSendThreadPool->DeleteClientToThreadPool(clihandle);//移除发送线程 
		DeleteClientMediaStreamSource(clihandle);//移除媒体拷贝

		pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));
	}
	

ABLMediaServer-2021-04-19 【超强压测，服务器稳定版本】
1  网络断开，不能直接删除，否则会卡住接收的入口 ，先把 nClient 加入 pDisconnectBaseNetFifo 
	void LIBNET_CALLMETHOD	onclose(NETHANDLE srvhandle,
		NETHANDLE clihandle)
	{ //从何这里断开的话，如果大量链接同时断开，会造成卡住，从而造成视频卡顿，要先加入链表，然后定期（500毫秒断开一路） 
		//DeleteNetRevcBaseClient(clihandle);
		pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));
	}

2  发送线程，如果找不到 nClient ,则进行清理 
	void CMediaSendThreadPool::ProcessFunc()
	{
		int nCurrentThreadID = nCreateThreadProcessCount;
		bExitProcessThreadFlag[nCurrentThreadID] = false;
		bCreateThreadFlag = true; //创建线程完毕
		int i;
		int nVideoFrameCount, nAudioFrameCount;

		while (bRunFlag)
		{
			if (threadContainClient[nCurrentThreadID].nTrueClientsCount > 0)
			{
				for (i = 0; i < threadContainClient[nCurrentThreadID].nTrueClientsCount; i++)
				{
					if (threadContainClient[nCurrentThreadID].nClients[i] > 0)
					{
					   boost::shared_ptr<CNetRevcBase> pClient= GetNetRevcBaseClient(threadContainClient[nCurrentThreadID].nClients[i]);
					   if (pClient != NULL )
					   {
						   nVideoFrameCount = pClient->m_videoFifo.GetSize();
						   nAudioFrameCount = pClient->m_audioFifo.GetSize();
						   if (nVideoFrameCount == 0 && nAudioFrameCount == 0)
						   {
							  if(threadContainClient[nCurrentThreadID].nTrueClientsCount == 1 )
							  {//如果该线程只有1个连接，可以等待5毫秒
								Sleep(5);
								continue;
							  }
							  else //如果该线程超过2个连接，本次循环不能等待时间 ，因为还需要发送下一个链接的数据 
							  {
								Sleep(2); //防止死循环
								continue ;  
							  }
						   }
	  
						   for (i = 0; i < nVideoFrameCount;i++)
							   pClient->SendVideo();

						   for (i = 0; i < nAudioFrameCount;i++)
							   pClient->SendAudio();
					   }
					   else
					   {//找不到客户端 ，进行清理操作  
						   threadContainClient[nCurrentThreadID].nClients[i] = 0; //把该通道设置为 0 ，
						   threadContainClient[nCurrentThreadID].nTrueClientsCount -= 1;//链接数减少1 

						   if (threadContainClient[nCurrentThreadID].nTrueClientsCount < 0)
							   threadContainClient[nCurrentThreadID].nTrueClientsCount = 0 ;
					   }
					}
				}
			}else 
			  Sleep(5);
		}
		bExitProcessThreadFlag[nCurrentThreadID] = true;
	}
	
3  把客户端 nClient 在发送线程中移除，需要 扩大搜索范围，否则会漏掉 移除操作，造成发送线程死循环  
  
	bool  CMediaSendThreadPool::DeleteClientToThreadPool(uint64_t nClient)
	{
		std::lock_guard<std::mutex> lock(threadLock);

		for (int i = 0; i < MaxMediaSendThreadCount; i++) //扩大搜索范围 
		{
			for (int j = 0; j < MaxMediaSendThreadCount; j++) //扩大搜索范围
			{
				if (threadContainClient[i].nClients[j] == nClient)
				{
					threadContainClient[i].nClients[j] = 0;
					threadContainClient[i].nTrueClientsCount -= 1;

					if (threadContainClient[i].nTrueClientsCount < 0) //保护，防止意外 
						threadContainClient[i].nTrueClientsCount = 0;

					WriteLog(Log_Debug, "把客户端 nClient = %llu 从媒体发送线程池移除 ", nClient);
					return true;
				}
			}
		}
		return false;
	}
	
void LIBNET_CALLMETHOD	onclose(NETHANDLE srvhandle,
	NETHANDLE clihandle)
{ //从何这里断开的话，如果大量链接同时断开，会造成卡住，从而造成视频卡顿，要先加入链表，然后定期（500毫秒断开一路） 
	//DeleteNetRevcBaseClient(clihandle);
	pDisconnectBaseNetFifo.push((unsigned char*)&clihandle, sizeof(clihandle));
}


ABLMediaServer-2021-04-18 【ｒｔｓｐ输出正常、初步验证解决卡住问题、增加RTCP回复】
1 根据视频，音频格式来创建http-flv ,支持 H264\H265 + AAC ,或者只有 H264、H265
	if ((strcmp(pushClient->m_mediaCodecInfo.szVideoName, "H264") == 0 || strcmp(pushClient->m_mediaCodecInfo.szVideoName, "H265") == 0) &&
		strcmp(pushClient->m_mediaCodecInfo.szAudioName, "AAC") == 0)
	{//H264、H265  && AAC，创建音频，视频
	  flvWrite = flv_writer_create2(1, 1, NetServerHTTP_FLV_OnWrite_CB, (void*)this);
	}
	else if ((strcmp(pushClient->m_mediaCodecInfo.szVideoName, "H264") == 0 || strcmp(pushClient->m_mediaCodecInfo.szVideoName, "H265") == 0) &&
		strcmp(pushClient->m_mediaCodecInfo.szAudioName, "AAC") != 0)
	{//H264、H265 只创建视频
		flvWrite = flv_writer_create2(0, 1, NetServerHTTP_FLV_OnWrite_CB, (void*)this);
	}
	else
	{
		WriteLog(Log_Debug, "视频 %s、音频 %s 格式有误，不支持http-flv 输出,即将删除 nClient = %llu ",pushClient->m_mediaCodecInfo.szVideoName,pushClient->m_mediaCodecInfo.szAudioName,nClient);
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		return -1;
	}
		
ABLMediaServer-2021-04-17 【ｒｔｓｐ输出正常、初步验证解决卡住问题、增加RTCP回复】
1 视频拼接成1帧时，再发送，不再采样积累16K再发送，这样视频实时性更好，更流畅。
	void CNethttpServer::ProcessRtpVideoData(unsigned char* pRtpVideo,int nDataLength)
	{
		if (MaxRtpSendVideoMediaBufferLength - nSendRtpVideoMediaBufferLength < nDataLength + 4)
		{//剩余空间不够存储 ,防止出错 
			SumSendRtpMediaBuffer(szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength);
			nSendRtpVideoMediaBufferLength = 0;
		}

		memcpy((char*)&nCurrentVideoTimestamp, pRtpVideo + 4, sizeof(uint32_t));
		if (nStartVideoTimestamp != VideoStartTimestampFlag &&  nStartVideoTimestamp != nCurrentVideoTimestamp)
		{//产生一帧新的视频 ，产生一个新的帧，因为时间戳不相同 
			WriteLog(Log_Debug, "CNethttpServer= %X, 发送一帧视频 ，Length = %d ", this, nSendRtpVideoMediaBufferLength);
			SumSendRtpMediaBuffer(szSendRtpVideoMediaBuffer, nSendRtpVideoMediaBufferLength);
			nSendRtpVideoMediaBufferLength = 0;
		}
	 
		szRtpDataOverTCP[0] = '$';
		szRtpDataOverTCP[1] = 0;
		nVideoRtpLen = htons(nDataLength);
		memcpy(szRtpDataOverTCP + 2, (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));
		memcpy(szRtpDataOverTCP + 4, pRtpVideo, nDataLength);
	 
		nStartVideoTimestamp = nCurrentVideoTimestamp;
		memcpy(szSendRtpVideoMediaBuffer + nSendRtpVideoMediaBufferLength, szRtpDataOverTCP, nDataLength + 4);
		nSendRtpVideoMediaBufferLength += nDataLength + 4;
	}
	
2  音频拼接到5帧时，立即发送，不再和视频拼接在一起，这样更合理 	
	void CNethttpServer::ProcessRtpAudioData(unsigned char* pRtpAudio, int nDataLength)
	{
		if (MaxRtpSendAudioMediaBufferLength - nSendRtpAudioMediaBufferLength < nDataLength + 4)
		{//剩余空间不够存储 ,防止出错 
			SumSendRtpMediaBuffer(szSendRtpAudioMediaBuffer, nSendRtpAudioMediaBufferLength);

			nSendRtpAudioMediaBufferLength = 0;
			nCalcAudioFrameCount = 0;
		}

		szAudioRtpDataOverTCP[0] = '$';
		szAudioRtpDataOverTCP[1] = 2;
		nAudioRtpLen = htons(nDataLength);
		memcpy(szAudioRtpDataOverTCP + 2, (unsigned char*)&nAudioRtpLen, sizeof(nAudioRtpLen));
		memcpy(szAudioRtpDataOverTCP + 4, pRtpAudio, nDataLength);

		memcpy(szSendRtpAudioMediaBuffer + nSendRtpAudioMediaBufferLength, szAudioRtpDataOverTCP, nDataLength + 4);
		nSendRtpAudioMediaBufferLength += nDataLength + 4;
		nCalcAudioFrameCount ++;

		if (nCalcAudioFrameCount >= 5 && nSendRtpAudioMediaBufferLength > 0 )
		{
			SumSendRtpMediaBuffer(szSendRtpAudioMediaBuffer, nSendRtpAudioMediaBufferLength);
			nSendRtpAudioMediaBufferLength = 0;
			nCalcAudioFrameCount = 0;
		}
	}

3  在CNethttpServer 中，增加一变量  nSendRtpFailCount ，用于累计发送rtp失败次数，当累计失败30次，即将销毁该链接 
	//累积rtp包，发送
	void CNethttpServer::SumSendRtpMediaBuffer(unsigned char* pRtpMedia, int nRtpLength)
	{
		std::lock_guard<std::mutex> lock(MediaSumRtpMutex);
	 
		nSendRet = XHNetSDK_Write(nClient, pRtpMedia, nRtpLength, 1);
		if (nSendRet != 0)
		{
		    nSendRtpFailCount ++;
			
			WriteLog(Log_Debug, "发送rtp 包失败 ,累计次数 nSendRtpFailCount = %d 次 ，nClient = %llu ", nSendRtpFailCount, nClient);
			if (nSendRtpFailCount >= 30)
			{
				WriteLog(Log_Debug, "发送rtp 包失败 ,累计次数 已经达到 nSendRtpFailCount = %d 次，即将删除 ，nClient = %llu ", nSendRtpFailCount, nClient);
				DeleteNetRevcBaseClient(nClient);
			}
		}
		else
			nSendRtpFailCount = 0;
	}

4 增加回复http的rtcp回复包
	 else if (data_[1] == 0x01 || data_[1] == 0x03)
	 {//收到RTCP包，需要回复rtcp报告包
		SendRtcpReportData();
		WriteLog(Log_Debug, "this =%X ,收到RTCP包，需要回复rtcp报告包，netBaseNetType = %d  收到RCP包长度 = %d ", this, netBaseNetType, nReadLength);
	 }

	//发送rtcp 报告包
	void  CNethttpServer::SendRtcpReportData(unsigned int nSSRC, int nChan)
	{
		memset(szRtcpSRBuffer, 0x00, sizeof(szRtcpSRBuffer));
		rtcpSR.BuildRtcpPacket(szRtcpSRBuffer, rtcpSRBufferLength, nSSRC);

		ProcessRtcpData((char*)szRtcpSRBuffer, rtcpSRBufferLength, nChan);
	}

	//发送rtcp 报告包 接收端
	void  CNethttpServer::SendRtcpReportDataRR(unsigned int nSSRC, int nChan)
	{
		memset(szRtcpSRBuffer, 0x00, sizeof(szRtcpSRBuffer));
		rtcpRR.BuildRtcpPacket(szRtcpSRBuffer, rtcpSRBufferLength, nSSRC);

		ProcessRtcpData((char*)szRtcpSRBuffer, rtcpSRBufferLength, nChan);
	}

	void  CNethttpServer::ProcessRtcpData(char* szRtcpData, int nDataLength, int nChan)
	{
		std::lock_guard<std::mutex> lock(MediaSumRtpMutex);

		szRtcpDataOverTCP[0] = '$';
		szRtcpDataOverTCP[1] = nChan;
		unsigned short nRtpLen = htons(nDataLength);
		memcpy(szRtcpDataOverTCP + 2, (unsigned char*)&nRtpLen, sizeof(nRtpLen));

		memcpy(szRtcpDataOverTCP + 4, szRtcpData, nDataLength);
		XHNetSDK_Write(nClient, szRtcpDataOverTCP, nDataLength + 4, 1);
	}

ABLMediaServer-2021-04-16 【ｒｔｓｐ输出正常、初步验证解决卡住问题】
1、在DeleteNetRevcBaseClient 函数中，删除线程移除两个函数，把nClient 加入FIFO，在另一个线程进行移除，解决卡住问题 
	bool  DeleteNetRevcBaseClient(NETHANDLE CltHandle)
	{
		std::lock_guard<std::mutex> lock(ABL_CNetRevcBase_ptrMapLock);

		CNetRevcBase_ptrMap::iterator iterator1;

		iterator1 = xh_ABLNetRevcBaseMap.find(CltHandle);
		if (iterator1 != xh_ABLNetRevcBaseMap.end())
		{
		    【 删除这两行 】
			//DeleteClientMediaStreamSource(CltHandle); //从拷贝线程中移除
			//pMediaSendThreadPool->DeleteClientToThreadPool(CltHandle); //从发送线程移除 
			
		    pRemoveBaseNetFromThreadFifo.push((unsigned char*)&CltHandle, sizeof(uint64_t)); //加入FIFO，在另一个线程进行移除 

			xh_ABLNetRevcBaseMap.erase(iterator1);
			return true;
		}
		else
		{
			return false;
		}
	}
	
2 、增加从两个线程移除nClient的FIFO pRemoveBaseNetFromThreadFifo，增加定期从两个线程移除nClient 

    1）、定义 
	     CMediaFifo     pRemoveBaseNetFromThreadFifo;       //从媒体拷贝线程、媒体发送线程移除掉Client  

	2）、先做移除
		if (pRemoveBaseNetFromThreadFifo.GetSize() > 0)
		{//定期移除掉拷贝线程、发送线程 
			while ((pData = pRemoveBaseNetFromThreadFifo.pop(&nLength)) != NULL)
			{
				if (nLength == sizeof(nClient))
				{
					memcpy((char*)&nClient, pData, sizeof(nClient));
					if (nClient > 0)
					{
						DeleteClientMediaStreamSource(nClient);//移除媒体拷贝
						pMediaSendThreadPool->DeleteClientToThreadPool(nClient);//移除发送线程 
					}
				}

				pRemoveBaseNetFromThreadFifo.pop_front();
			}
		}

3、增加CConfigFile 读取配置文件，运行端口从配置文件读取 		
	GetMediaServerCurrentPath(ABL_MediaSeverRunPath);
	sprintf(szConfigFileName, "%s%s", ABL_MediaSeverRunPath, "ABLMediaServer.ini");
	if (ABL_ConfigFile.FindFile(szConfigFileName) == false)
	{
		WriteLog(Log_Error, "没有找到配置文件 ：%s ",szConfigFileName);
		Sleep(3000);
		return -1;
	}
	ABL_MediaServerPort.nhttpPort    = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "httpPort", "554"));
	ABL_MediaServerPort.nRtmpPort    = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "rtmpPort", "1935"));
	ABL_MediaServerPort.nHttpFlvPort = atoi(ABL_ConfigFile.ReadConfigString("ABLMediaServer", "httpFlvPort", "8088"));
	
4、增加http推流URL两级路径检测 http://190.15.240.11:554/live/Camera_00001
	nPathCount = GethttpPathCount(szCurhttpURL);
	if (nPathCount <= 1)
	{//限制http推流，需要两级路径
 			WriteLog(Log_Debug, "http推流地址不符合两级的标准，需要推送类似URL: http://190.15.240.11:554/live/Camera_00001 ");
			DeleteNetRevcBaseClient(nClient);
			return false;
 	}

 	
5、 增加http推流URL两级路径检测 rtmp://190.15.240.11:1935/live/Camera_00001 
	if ( !(strlen(app) > 0 && strlen(stream) > 0 ))
	{//限制rtmp推流，需要两级路径 
		WriteLog(Log_Debug, "rtmp推流地址不符合两级的标准，需要推送类似URL: rtmp://190.15.240.11:1935/live/Camera_00001 ");
		DeleteNetRevcBaseClient(pClient->nClient);
		return 0;
	}

ABLMediaServer-2021-04-15 【ｒｔｓｐ输出正常、压力沦陷卡住】
1、 在CNethttpServer 中，如果音频为G711A 、G711U 也加入音频FIFO,
	else
	{// G711A 、G711U
		pUserHandle->pMediaSource->PushAudio(cb->data, cb->datasize, pUserHandle->szAudioName, pUserHandle->nChannels, pUserHandle->nSampleRate);
	}

2、加入日志文件系统，方法调试、查找问题 

3、收到断开 TEARDOWN 命令，立即执行删除 
	else if (memcmp(pRecvData, "TEARDOWN", 8) == 0 && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
	{
		WriteLog(Log_Debug, "收到断开 TEARDOWN 命令，立即执行删除 nClient = %llu \r\n", nClient);
		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
 	}
	
4、http 网络处理，增加超时处理
	//处理网络数据
	int CNethttpServer::ProcessNetData()
	{
		bExitProcessFlagArray[2] = false; 
		thttpProcessStartTime = GetTickCount64();
		while (!bIsInvalidConnectFlag && bRunFlag && netDataCacheLength > 4)
		{ 
		    do something  ... 
		
		    //网络超时处理
			if (::GetTickCount64() - thttpProcessStartTime > 3000)
			{
				WriteLog(Log_Debug, "CNethttpServer= %X  , ProcessNetData() ,http 网络处理超时 ! , nClient = %llu", this, nClient);
				bExitProcessFlagArray[2] = true;
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				return -1;
			}	
	    }
	}

5、rtp包发送失败，增加立即删除函数 	 DeleteNetRevcBaseClient(nClient);
	nSendRet = XHNetSDK_Write(nClient, szSendRtpMediaBuffer, nSendRtpMediaBufferLength, 1);
	if (nSendRet != 0)
	{
		WriteLog(Log_Debug, "发送rtp 包失败 ，nClient = %llu ", nClient);
		DeleteNetRevcBaseClient(nClient);
		return; 
	}	
	
ABLMediaServer-2021-04-14 【ｒｔｓｐ输出正常　】
1 如果rtmp推送265视频，立即删除，不支持rtmp推送265视频 ，要修改 flv 的源码 flv_demuxer_input ，如果发现是265视频，立即返回 -2 
	if (flv_demuxer_input(pClient->flvDemuxer, FLV_TYPE_VIDEO, data, bytes, timestamp) < 0)
	{
		if (!pClient->bDeleteRtmpPushH265Flag)
		{
			pClient->bDeleteRtmpPushH265Flag = true;
			printf("不支持rtmp推送 H265视频【rtmp推流只支持视频H264、音频AAC】，如果要推送H265视频，建议使用http推流。准备删除rtmp推流链接 nClient = %llu \r\n", pClient->nClient);
			pDisconnectBaseNetFifo.push((unsigned char*)&pClient->nClient, sizeof(pClient->nClient));
		}
		return 0;
	}
	
2 	媒体源类库增加一个变量，用于记录是链接接收的推流 
	class CMediaStreamSource
	{
	 public:
	   CMediaStreamSource(char* szURL,uint64_t nClientTemp);
	   
       uint64_t             nClient; //记录是那个链接接收的推流 
     };
	 
	 pClient->pMediaSource =  CreateMediaStreamSource(pClient->szURL,pClient->nClient);
 
3  增加回复 http 的Describe 命令 

	else if (memcmp(pRecvData, "DESCRIBE", 8) == 0 && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
	{
		netBaseNetType = NetBaseNetType_httpServerSendPush; //http 服务器，转发客户端的推上来的码流  

		memset(szCSeq, 0x00, sizeof(szCSeq));
		GetFieldValue("CSeq", szCSeq);

		//记下 httpURL DESCRIBE													
		if (!GetMediaURLFromhttpSDP())
			return;

		//判断源流媒体是否存在
		pMediaSource = GetMediaStreamSource(szMediaSourceURL);
		if (pMediaSource == NULL)
		{
			sprintf(szResponseBuffer, "http/1.0 404 Not FOUND\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
			nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
			printf("媒体流 %s 不存在 ,准备删除 nClient =%llu \r\n", szMediaSourceURL,nClient);

			DeleteNetRevcBaseClient(nClient);
			return;
		}

		m_videoFifo.InitFifo(MaxLiveingVideoFifoBufferLength);
		m_audioFifo.InitFifo(MaxLiveingAudioFifoBufferLength);
	}

4、修改一个BUG，拷贝视频格式到媒体格式变量中
	bool CMediaStreamSource::PushVideo(unsigned char* szVideo, int nLength, char* szVideoCodec)
	{//直接拷贝给每个网络发送对象 
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		//记录视频格式
		if (strlen(m_mediaCodecInfo.szVideoName) == 0)
			strcpy(m_mediaCodecInfo.szVideoName,(char*)szVideoCodec);　　／／修正　szVideoCodec

５、根据媒体信息拼装 SDP 信息
	bool CNethttpServer::GethttpSDPFromMediaStreamSource()
	{
		memset(szhttpSDPContent, 0x00, sizeof(szhttpSDPContent));
		if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName,"H264") == 0)
		{
			//optionVideo.streamtype = e_rtppkt_st_h264;
			nVideoPayload = 96;
			sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\nm=video 6000 RTP/AVP %d\r\nb=AS:832\r\na=rtpmap:%d H264/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n", nVideoPayload, nVideoPayload, nVideoPayload);
		}
		else if (strcmp(pMediaSource->m_mediaCodecInfo.szVideoName, "H264"))
		{
			//optionVideo.streamtype = e_rtppkt_st_h265;
			nVideoPayload = 97;
			sprintf(szhttpSDPContent, "v=0\r\no=- 0 0 IN IP4 127.0.0.1\r\ns=No Name\r\nc=IN IP4 190.15.240.36\r\nt=0 0\r\na=tool:libavformat 55.19.104\r\nm=video 6000 RTP/AVP %d\r\nb=AS:832\r\na=rtpmap:%d H265/90000\r\na=fmtp:%d packetization-mode=1\r\na=control:streamid=0\r\n", nVideoPayload, nVideoPayload, nVideoPayload);
		}
		else
			return false;

		memset(szhttpAudioSDP, 0x00, sizeof(szhttpAudioSDP));
	 
		if (strcmp(pMediaSource->m_mediaCodecInfo.szAudioName, "G711_A") == 0)
		{
			//optionAudio.ttincre = 320; //g711a 的 长度增量
			//optionAudio.streamtype = e_rtppkt_st_g711a;
			nAudioPayload = 8;
			sprintf(szhttpAudioSDP, "m=audio 0 RTP/AVP %d\r\nb=AS:50\r\na=recvonly\r\na=rtpmap:%d PCMA/%d\r\na=control:streamid=1\r\na=framerate:25\r\n",
				nAudioPayload, nAudioPayload, 8000);
		}
		else if (strcmp(pMediaSource->m_mediaCodecInfo.szAudioName, "G711_U") == 0)
		{
			//optionAudio.ttincre = 320; //g711u 的 长度增量
			//optionAudio.streamtype = e_rtppkt_st_g711u;
			nAudioPayload = 0;
			sprintf(szhttpAudioSDP, "m=audio 0 RTP/AVP %d\r\nb=AS:50\r\na=recvonly\r\na=rtpmap:%d PCMU/%d\r\na=control:streamid=1\r\na=framerate:25\r\n",
				nAudioPayload, nAudioPayload, 8000);
		}
		else if (strcmp(pMediaSource->m_mediaCodecInfo.szAudioName, "AAC") == 0)
		{
			//optionAudio.ttincre = 1024;//aac 的长度增量
			//optionAudio.streamtype = e_rtppkt_st_aac;
			nAudioPayload = 104;
			sprintf(szhttpAudioSDP, "m=audio 0 RTP/AVP %d\r\na=rtpmap:%d MPEG4-GENERIC/%d/%d\r\na=fmtp:%d profile-level-id=15; streamtype=5; mode=AAC-hbr; config=1408;SizeLength=13; IndexLength=3; IndexDeltaLength=3; Profile=1;\r\na=control:streamid=1\r\n",
				nAudioPayload, nAudioPayload, pMediaSource->m_mediaCodecInfo.nSampleRate, pMediaSource->m_mediaCodecInfo.nChannels, nAudioPayload);
		}

		//追加音频SDP
		if (strlen(szhttpAudioSDP) > 0 && strlen(szhttpSDPContent) > 0)
			strcat(szhttpSDPContent, szhttpAudioSDP);

		printf("组装好SDP :\r\n%s\r\n", szhttpSDPContent);

		return true;
	}

６、增加ｒｔｐ打包、ｒｔｐ拼接函数、ｒｔｐ数据发送　等等函数　　
	//rtp打包回调视频
	void Video_rtp_packet_callback_func(_rtp_packet_cb* cb)
	{
		CNethttpServer* phttpClient = (CNethttpServer*)cb->userdata;
		phttpClient->ProcessRtpVideoData(cb->data, cb->datasize);
	}

	//rtp 打包回调音频
	void Audio_rtp_packet_callback_func(_rtp_packet_cb* cb)
	{
		CNethttpServer* phttpClient = (CNethttpServer*)cb->userdata;
		phttpClient->ProcessRtpAudioData(cb->data, cb->datasize);
	}

	void CNethttpServer::ProcessRtpVideoData(unsigned char* pRtpVideo,int nDataLength)
	{
		szRtpDataOverTCP[0] = '$';
		szRtpDataOverTCP[1] = 0;
		nVideoRtpLen = htons(nDataLength);
		memcpy(szRtpDataOverTCP + 2, (unsigned char*)&nVideoRtpLen, sizeof(nVideoRtpLen));

		memcpy(szRtpDataOverTCP + 4, pRtpVideo, nDataLength);

		SumSendRtpMediaBuffer(szRtpDataOverTCP, nDataLength + 4);
	}
	void CNethttpServer::ProcessRtpAudioData(unsigned char* pRtpAudio, int nDataLength)
	{
		szAudioRtpDataOverTCP[0] = '$';
		szAudioRtpDataOverTCP[1] = 2;
		nAudioRtpLen = htons(nDataLength);
		memcpy(szAudioRtpDataOverTCP + 2, (unsigned char*)&nAudioRtpLen, sizeof(nAudioRtpLen));

		memcpy(szAudioRtpDataOverTCP + 4, pRtpAudio, nDataLength);

		SumSendRtpMediaBuffer(szAudioRtpDataOverTCP,nDataLength+4);
	}

	//累积rtp包，准备发送
	void CNethttpServer::SumSendRtpMediaBuffer(unsigned char* pRtpMedia, int nRtpLength)
	{
		std::lock_guard<std::mutex> lock(MediaSumRtpMutex);

		if (MaxRtpSendMediaBufferLength - nSendRtpMediaBufferLength < nRtpLength)
		{//剩余空间不够，需要发送 
			nSendRet = XHNetSDK_Write(nClient, szSendRtpMediaBuffer, nSendRtpMediaBufferLength, 1);
			if (nSendRet != 0)
			{
				printf("发送rtp 包失败 ，nClient = %llu \r\n", nClient);
				return; 
			}
			nSendRtpMediaBufferLength = 0;
		}
		memcpy(szSendRtpMediaBuffer + nSendRtpMediaBufferLength, pRtpMedia, nRtpLength);
		nSendRtpMediaBufferLength += nRtpLength;
	}
	
			
ABLMediaServer-2021-04-12 【把多包的aac 进行切割   】
1、增加不支持UDP模式推流，如果以UDP模式推流，立即关闭连接  
	if (strlen(szTransport) == 0 || strstr(szTransport, "RTP/AVP/TCP") == NULL)
	{//不支持UDP，只支持TCP 
		sprintf(szResponseBuffer, "http/1.0 461 Unsupported transport\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
		nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		printf("不支持UDP，只支持TCP %s \r\n", httpProtectArray[httpProtectArrayOrder].szhttpURL);

		pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
		return;
	}

2、增加文本解析类库 ABLSipParse.cpp、ABLSipParse.h 文件
	
3、增加从SDP中获取视频、音频格式信息函数
   //从sdp信息中获取视频、音频格式信息 ,根据这些信息创建rtp解包、rtp打包 
	bool   CNethttpServer::GetMediaInfoFromhttpSDP()
	{
		//把sdp装入分析器
		string strSDPTemp = szhttpContentSDP;
		char   szTemp[128] = { 0 };
		int    nPos1 = strSDPTemp.find("m=video", 0);
		int    nPos2 = strSDPTemp.find("m=audio", 0);
		int    nPos3;
		memset(szVideoSDP, 0x00, sizeof(szVideoSDP));
		memset(szAudioSDP, 0x00, sizeof(szAudioSDP));
		memset(szVideoName, 0x00, sizeof(szVideoName));
		memset(szAudioName, 0x00, sizeof(szAudioName));
		if (nPos1 > 0 && nPos2 > 0)
		{
			memcpy(szVideoSDP, szhttpContentSDP + nPos1, nPos2 - nPos1);
			memcpy(szAudioSDP, szhttpContentSDP + nPos2, strlen(szhttpContentSDP) - nPos2);

			sipParseV.ParseSipString(szVideoSDP);
			sipParseA.ParseSipString(szAudioSDP);
		}
		else if (nPos1 > 0 && nPos2 < 0)
		{
			memcpy(szVideoSDP, szhttpContentSDP + nPos1, strlen(szhttpContentSDP) - nPos1);
			sipParseV.ParseSipString(szVideoSDP);
		}

		//获取视频编码名称
		string strVideoName;
		char   szTemp2[64] = { 0 };
		char   szTemp3[64] = { 0 };
		if (sipParseV.GetSize() > 0)
		{
			if (sipParseV.GetFieldValue("a=rtpmap", szTemp))
			{
				strVideoName = szTemp;
				nPos1 = strVideoName.find(" ", 0);
				if (nPos1 > 0)
				{
					memcpy(szTemp2, szTemp, nPos1);
					nVideoPayload = atoi(szTemp2);
				}
				nPos2 = strVideoName.find("/", 0);
				if (nPos1 > 0 && nPos2 > 0)
				{
					memcpy(szVideoName, szTemp + nPos1 + 1, nPos2 - nPos1 - 1);

					//转为大小
					strVideoName = szVideoName;
					to_upper(strVideoName);
					strcpy(szVideoName, strVideoName.c_str());
				}

				printf("在SDP中，获取到的视频格式为 %s , payload = %d ！\r\n", szVideoName, nVideoPayload);
			}
		}

		  //获取音频信息
		  if (sipParseA.GetSize() > 0)
		  {
			memset(szTemp2, 0x00, sizeof(szTemp2));
			memset(szTemp, 0x00, sizeof(szTemp));
			if (sipParseA.GetFieldValue("a=rtpmap", szTemp))
			{
				strVideoName = szTemp;
				nPos1 = strVideoName.find(" ", 0);
				if (nPos1 > 0)
				{
					memcpy(szTemp2, szTemp, nPos1);
					nAudioPayload = atoi(szTemp2);
				}
				nPos2 = strVideoName.find("/", 0);
				if (nPos1 > 0 && nPos2 > 0)
				{
					memcpy(szAudioName, szTemp + nPos1 + 1, nPos2 - nPos1 - 1);

					//转为大小
					string strName = szAudioName;
					to_upper(strName);
					strcpy(szAudioName, strName.c_str());

					//找出采用频率、通道数
					nPos3 = strVideoName.find("/", nPos2 + 1);
					memset(szTemp2, 0x00, sizeof(szTemp2));
					if (nPos3 > 0)
					{
						memcpy(szTemp2, szTemp + nPos2 + 1, nPos3 - nPos2 - 1);
						nSampleRate = atoi(szTemp2);

						memcpy(szTemp3, szTemp + nPos3 + 1, strlen(szTemp) - nPos3 - 1);
						nChannels = atoi(szTemp3);//通道数量
					}
					else
					{
						memcpy(szTemp2, szTemp + nPos2 + 1, strlen(szTemp) - nPos2 - 1);
						nSampleRate = atoi(szTemp2);
						nChannels = 1;
					}

					//防止音频通道数出错 
					if (nChannels > 2)
						nChannels = 1;
				}
			}

			if (strcmp(szAudioName, "PCMA") == 0)
			{
				strcpy(szAudioName, "G711_A");
			}
			else if (strcmp(szAudioName, "PCMU") == 0)
			{
				strcpy(szAudioName, "G711_U");
			}
			else if (strcmp(szAudioName, "MPEG4-GENERIC") == 0)
			{
				strcpy(szAudioName, "AAC");
			}
			else if (strstr(szAudioName, "G726") != NULL)
			{
				strcpy(szAudioName, "G726LE");
			}
			else
				strcpy(szAudioName, "NONE");

			printf("在SDP中，获取到的音频格式为 %s ,nChannels = %d ,SampleRate = %d , payload = %d ！\r\n", szAudioName, nChannels, nSampleRate, nAudioPayload);
		}

	  if (strlen(szVideoName) == 0)
			  return false;
	   else 
		  return true;
	}
	
4、如果SDP中没有合法的视频、音频信息，立即关闭该连接 
	//从SDP中获取视频、音频格式信息 
	if (!GetMediaInfoFromhttpSDP())
	{
		sprintf(szResponseBuffer, "http/1.0 415 Unsupport Media Type\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
		nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);

		printf("ANNOUNCE SDP 信息中没有合法的媒体数据 %s \r\n", szhttpContentSDP);
		DeleteNetRevcBaseClient(nClient);
		return ;
	}
		
5、把写aac文件代码移动到 切割完AAC的rtp包里面
		if (netBaseNetType == NetBaseNetType_httpServerRecvPush && pMediaSource != NULL)
		{
		   pMediaSource->PushAudio(aacData, SplitterSize[i] +7, szAudioName, nChannels,nSampleRate);

#ifdef WriteRtpDepacketFileFlag //这里写入的AAC音频文件能直接播放 
		   fwrite(aacData, 1, SplitterSize[i] + 7, fWriteRtpAudio);
		   fflush(fWriteRtpAudio);
#endif
		}
		
ABLMediaServer-2021-04-11 【把多包的aac 进行切割   】
1 rtmp 推流、拉流库中，flv 打包，解包按照类型进行创建 
	flvDemuxer =  flv_demuxer_create(NetRtmpServerRecvCallBackFLV, this);
	flvMuxer = flv_muxer_create(NetRtmpServerRec_MuxerFlv, this);

2 增加aac包的切割 
	void  CNethttpServer::SplitterRtpAACData(unsigned char* rtpAAC, int nLength)
	{
		au_header_length = (rtpAAC[0] << 8) + rtpAAC[1];
		au_header_length = (au_header_length + 7) / 8; // bit -> byte
		ptr = rtpAAC;

		au_size = 2; // only AU-size
		au_numbers = au_header_length / au_size;

		ptr += 2; // skip AU headers length section 2-bytes
		pau = ptr + au_header_length; // point to Access Unit

		for (int i = 0; i < au_numbers; i++)
		{
			SplitterSize[i] = (ptr[0] << 8) | (ptr[1] & 0xF8);
			SplitterSize[i] = SplitterSize[i] >> 3; // bit -> byte

			// TODO: add ADTS/ASC ???
			//pkt.payload = pau;
			//pkt.payloadlen = size;
			//rtp_payload_write(helper, &pkt);
			if (SplitterSize[i] > nLength)
			{
				printf("CNethttpServer=%X ,nClient = %llu, rtp 切割长度 有误 \r\n", this, nClient);

				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				return;
			}
		 
			 AddADTSHeadToAAC((unsigned char*)pau, SplitterSize[i]);

			if (netBaseNetType == NetBaseNetType_httpServerRecvPush && pMediaSource != NULL)
			{
			   pMediaSource->PushAudio(aacData, SplitterSize[i] +7, szAudioName,AdtsChannel,nSampleRate);
			}
	 
			ptr += au_size;
			pau += SplitterSize[i];
		}
	}

ABLMediaServer-2021-04-09 【采用老陈的SDK增加AAC的adts头  】
1 采用老陈的SDK增加AAC的adts头 
  结果：
    1)、自研推流库推上来的http，保存AAC音频为aac正常。
	2)、自研推流库推上来的http，保存AAC音频为aac正常,转发为rtmp、http-flv 的aac 声音也正常  
	3)、ffmpeg推上来的http ，视频正常，转发也正常，但是aac声音不正常，发现长度很大  
	
	int len = nAACLength + 7;
	uint8_t profile = 2;
	uint8_t sampling_frequency_index = sample_index;
	uint8_t channel_configuration = AdtsChannel;
	aacData[0] = 0xFF; /* 12-syncword */
	aacData[1] = 0xF0 /* 12-syncword */ | (0 << 3)/*1-ID*/ | (0x00 << 2) /*2-layer*/ | 0x01 /*1-protection_absent*/;
	aacData[2] = ((profile - 1) << 6) | ((sampling_frequency_index & 0x0F) << 2) | ((channel_configuration >> 2) & 0x01);
	aacData[3] = ((channel_configuration & 0x03) << 6) | ((len >> 11) & 0x03); /*0-original_copy*/ /*0-home*/ /*0-copyright_identification_bit*/ /*0-copyright_identification_start*/
	aacData[4] = (uint8_t)(len >> 3);
	aacData[5] = ((len & 0x07) << 5) | 0x1F;
	aacData[6] = 0xFC | ((len / 1024) & 0x03);
	
2  在CNethttpServer 类中增加 一个变量，标识是否为非法连接，如果收到非法命令则 立即修改状态 	
    1）、定义
	   volatile bool  bIsInvalidConnectFlag; //是否为非法连接 
	   
	2）、修改状态 
		else if (memcmp(pRecvData, "TEARDOWN", 8) == 0 && strstr((char*)pRecvData, "\r\n\r\n") != NULL)
		{

		}
		else
		{
			bIsInvalidConnectFlag = true; //确认为非法连接 
			printf("非法的http 命令，立即执行删除 \r\n");
			DeleteNetRevcBaseClient(nClient);
		}
   
    3）、如果非法连接不进行业务处理 
	
	//处理网络数据
	int CNethttpServer::ProcessNetData()
	{
		while (!bIsInvalidConnectFlag && bRunFlag && netDataCacheLength > 4)
		{
			uint32_t nReadLength = 4;
			data_Length = 0;

			int nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
		
	//读取网络数据 ，模拟原来底层网络库读取函数 
	int32_t  CNethttpServer::XHNetSDKRead(NETHANDLE clihandle, uint8_t* buffer, uint32_t* buffsize, uint8_t blocked, uint8_t certain)
	{
		int nWaitCount = 0;
		while (!bIsInvalidConnectFlag && bRunFlag)
		{
			EnterCriticalSection(&netDataLock);
			if (netDataCacheLength >= *buffsize)
			
3 在CNethttpServer 类里面 增加3个状态，在析构函数中，等待3个任务完全退出
   volatile bool  bExitProcessFlagArray[3];

	CNethttpServer::~CNethttpServer()
	{
		bRunFlag = false;

		printf("http 等待任务退出 nTime = %llu, nClient = %llu \r\n",::GetTickCount64(), nClient);

		for (int i = 0; i < 3; i++)
		{
			while (!bExitProcessFlagArray[i])
				Sleep(5);
		}
		printf("http 任务退出完毕 nTime = %llu, nClient = %llu \r\n", ::GetTickCount64(), nClient);
		
ABLMediaServer-2021-04-08 【增加了http推流接收 】
1  已经计算视频帧速度次数 ，当视频帧速度稳定后，不再计算视频帧速度 
   volatile int         nCalcFrameSpeedCount;     //已经计算视频帧速度次数 ，当视频帧速度稳定后，不再计算视频帧速度 
   
   void CNetRevcBase::CalcVideoFrameSpeed()
  { 
	 if (nCalcFrameSpeedCount >= 30)
		return; //视频帧速度已经平稳，不需要再计算 
		
	nPushVideoFrameCount ++;//单位时间内加入视频帧总数 
	if (abs(nCalcFrameSpeedStartTime - 0) < 0.001)
		nCalcFrameSpeedStartTime = ::GetTickCount();//计算帧速度开始时间
	
	//够5秒 ，计算视频帧速度 												
	if (nPushVideoFrameCount >= 25 * 5)
	{
		nCalcFrameSpeedEndTime = ::GetTickCount();  //计算帧速度结束时间
		TempVideoFrameSpeed = (nPushVideoFrameCount / (nCalcFrameSpeedEndTime - nCalcFrameSpeedStartTime)) * 1000.00;

		if (abs(TempVideoFrameSpeed - VideoFrameSpeed) >= 5)
		{//帧速度误差有5帧时，才修正视频帧速度，否则会操作VLC播放声音丢失 
			VideoFrameSpeed =  TempVideoFrameSpeed;
			printf("CNetRevcBase= %X,视频帧速度有变化，前后速度误差超过5帧，需要修正视频帧速度 nClient = %llu,TempVideoFrameSpeed = %d,  VideoFrameSpeed = %d \r\n", this, nClient, TempVideoFrameSpeed,VideoFrameSpeed);
		}

		nPushVideoFrameCount = 0;
		nCalcFrameSpeedStartTime = 0;
		nCalcFrameSpeedCount ++;//累计 计算视频帧速度次数 
	}
	
  }
  
2   记录客户端的IP ，Port

   1、基类定义 
   char                szClientIP[64]; //连接上来的客户端IP 
   unsigned short      nClientPort; //连接上来的客户端端口 
 
   2 、派生类记录  
	   CNetServerHTTP_FLV::CNetServerHTTP_FLV(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort)
	   {  
		 nServer = hServer;
		 nClient = hClient;
		 strcpy(szClientIP, szIP);
		 nClientPort = nPort;
	 
		CNethttpServer::CNethttpServer(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort)
		{
			nServer = hServer;
			nClient = hClient;
			strcpy(szClientIP, szIP);
			nClientPort = nPort;	 
			
		CNetRtmpServerRecv::CNetRtmpServerRecv(NETHANDLE hServer, NETHANDLE hClient, char* szIP, unsigned short nPort)
		{
			bCheckhttpVersionFlag = false;
			nServer = hServer;
			nClient = hClient;
			strcpy(szClientIP, szIP);
			nClientPort = nPort;	

	
ABLMediaServer-2021-04-07 【增加了http推流接收 】
1 从基类 增加是否成功推流标志，只有推流成功，在该类析构时才能销毁 媒体数据源 
   1）、volatile bool           bPushMediaSuccessFlag; //是否成功推流，成功推流了，才能从媒体库中删除 
   
   2）、推流成功
   		//创建原始媒体流 
		pMediaSource = CreateMediaStreamSource(szMediaSourceURL);
		bPushMediaSuccessFlag = true;//成功推流 
		
   3）、该接收推流的类在析构时
	//如果是接收推流，并且成功接收推流的，则需要删除媒体数据源 szURL ，比如 /Media/Camera_00001 
	if(bPushMediaSuccessFlag && netBaseNetType == NetBaseNetType_httpServerRecvPush)
	   DeleteMediaStreamSource(szURL);

ABLMediaServer-2021-04-06 【增加了http推流接收 】
1 增加rtp解包
	//创建视频rtp解包 
	strcpy(szVideoName, "H265");
	nVideoPayload = 96;

	strcpy(szAudioName, "AAC");
	nSampleRate = 16000;
	nAudioPayload = 97;
	AdtsChannel = 1;

	int nRet2 = rtp_depacket_start(rtppacket_callback, (void*)this, (uint32_t*)&hRtpHandle[0]);
	if (strcmp(szVideoName, "H264") == 0)
		rtp_depacket_setpayload(hRtpHandle[0], nVideoPayload, e_rtpdepkt_st_h264);
	else if (strcmp(szVideoName, "H265") == 0)
		rtp_depacket_setpayload(hRtpHandle[0], nVideoPayload, e_rtpdepkt_st_h265);

	nRet2 = rtp_depacket_start(rtppacket_callback, (void*)this, (uint32_t*)&hRtpHandle[1]);

	if (strcmp(szAudioName, "G711_A") == 0)
	{
		rtp_depacket_setpayload(hRtpHandle[1], nAudioPayload, e_rtpdepkt_st_g711a);
	}
	else if (strcmp(szAudioName, "G711_U") == 0)
	{
		rtp_depacket_setpayload(hRtpHandle[1], nAudioPayload, e_rtpdepkt_st_g711u);
	}
	else if (strcmp(szAudioName, "AAC") == 0)
	{
		rtp_depacket_setpayload(hRtpHandle[1], nAudioPayload, e_rtpdepkt_st_aac);
	}
	else if (strstr(szAudioName, "G726LE") != NULL)
	{
		rtp_depacket_setpayload(hRtpHandle[1], nAudioPayload, e_rtpdepkt_st_g726le);
	}

	//确定ADTS头相关参数
	sample_index = 11;
	for (int i = 0; i < 13; i++)
	{
		if (avpriv_mpeg4audio_sample_rates[i] == nSampleRate)
		{
			sample_index = i;
			break;
		}
	} 
	
2  记录视频、音频格式
	bool CMediaStreamSource::PushVideo(unsigned char* szVideo, int nLength, char* szVideoCodec)
	{//直接拷贝给每个网络发送对象 
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		//记录视频格式
		if (strlen(m_mediaCodecInfo.szVideoName) == 0)
			strcpy(m_mediaCodecInfo.szVideoName,(char*)szVideo);

			
	bool CMediaStreamSource::PushAudio(unsigned char* szAudio, int nLength, char* szAudioCodec, int nChannels, int SampleRate)
	{//直接拷贝给每个网络发送对象
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		//记录音频格式
		if (strlen(m_mediaCodecInfo.szAudioName) == 0)
		{
			strcpy(m_mediaCodecInfo.szAudioName, szAudioCodec);
			m_mediaCodecInfo.nChannels = nChannels;
			m_mediaCodecInfo.nSampleRate = SampleRate;
		}			
		
3 增加所有链接的网络类型分类
	//网络基本类型
	enum NetBaseNetType
	{
		NetBaseNetType_Unknown = 0 ,  //未定义的网络类型
		NetBaseNetType_RtmpServerRecvPush      = 1,//RTMP 服务器，接收客户端的推流 
		NetBaseNetType_RtmpServerSendPush      = 2,//RTMP 服务器，转发客户端的推上来的码流
		NetBaseNetType_httpServerRecvPush      = 3,//http 服务器，接收客户端的推流 
		NetBaseNetType_httpServerSendPush      = 4,//http 服务器，转发客户端的推上来的码流
		NetBaseNetType_HttpFLVServerSendPush   = 5,//Http-FLV 服务器，转发 http 、rtmp 、GB28181等等推流上来的码流
		NetBaseNetType_HttpHLSServerSendPush   = 6,//Http-HLS 服务器，转发 http 、rtmp 、GB28181等等推流上来的码流
		NetBaseNetType_WebRtcServerRecvPush    = 7,//WebRtc 服务器，接收客户端的推流 
		NetBaseNetType_WebRtcServerSendPush    = 8,//WebRtc 服务器，转发 http 、rtmp 、GB28181等等推流上来的码流
	};

4 、 创建媒体原始源流对象

	//记下 httpURL DESCRIBE
	strcpy(szCurhttpURL, httpProtectArray[httpProtectArrayOrder].szhttpURL);
	string strCurhttpURL = szCurhttpURL;
	int    nPos1, nPos2;
	bool   bGetMediaSoureURL = false ;
	nPos1 = strCurhttpURL.find("//", 0);
	if (nPos1 > 0)
	{
		nPos2 = strCurhttpURL.find("/", nPos1 + 2);
		if (nPos2 > 0)
		{
			memset(szMediaSourceURL, 0x00, sizeof(szMediaSourceURL));
			memcpy(szMediaSourceURL, szCurhttpURL + nPos2, strlen(szCurhttpURL) - nPos2);
			bGetMediaSoureURL = true;
		}
	}
	if (!bGetMediaSoureURL)
	{
		printf("获取媒体地址失败 ！\r\n");
		DeleteNetRevcBaseClient(nClient);
		return;
	}

	//判断推流地址是否存在
	pMediaSource = GetMediaStreamSource(szMediaSourceURL);
	if (pMediaSource != NULL)
	{
		sprintf(szResponseBuffer, "http/1.0 406 Not Acceptable\r\nServer: %s\r\nCSeq: %s\r\n\r\n", MediaServerVerson, szCSeq);
		nSendRet = XHNetSDK_Write(nClient, (unsigned char*)szResponseBuffer, strlen(szResponseBuffer), 1);
		printf("ANNOUNCE 推流地址已经存在 %s \r\n", szMediaSourceURL);

		DeleteNetRevcBaseClient(nClient);
		return;
	}

	//创建原始媒体流 
	pMediaSource = CreateMediaStreamSource(szMediaSourceURL);
	
5 、增加http码流转 rtmp 、http-flv ,rtmp视频正常，flv还不正常、声音不正常  

    //加入视频
	if (pUserHandle->netBaseNetType == NetBaseNetType_httpServerRecvPush && pUserHandle->pMediaSource != NULL)
	{
		pUserHandle->pMediaSource->PushVideo(cb->data, cb->datasize, pUserHandle->szVideoName);
	}
	
	//加入音频 
	if (pUserHandle->netBaseNetType == NetBaseNetType_httpServerRecvPush && pUserHandle->pMediaSource != NULL)
	{
		pUserHandle->pMediaSource->PushAudio(pUserHandle->aacData, cb->datasize+7, pUserHandle->szAudioName,pUserHandle->AdtsChannel,pUserHandle->nSampleRate);
	}

ABLMediaServer-2021-04-05-2 【增加了http推流接收 】
1 增加了http推流接收 
	int CNethttpServer::ProcessNetData()
	{
		while (netDataCacheLength > 4)
		{
			uint32_t nReadLength = 4;
			data_Length = 0;

			int nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
			if (nRet == 0 && nReadLength == 4)
			{
				//nhttpPacketCount = 0;//接收到数据，超时清0 

				data_Length = 4;

				if (data_[0] == '$')
				{//rtp 数据
					memcpy((char*)&nRtpLength, data_ + 2, 2);
					nRtpLength = nReadLength = ntohs(nRtpLength);

					nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
					if (nRet == 0 && nReadLength == nRtpLength)
					{
						if (data_[1] == 0x00)
						{
							//if(nPrintCount % 200 == 0)
							//  printf("this =%X, Video Length = %d \r\n",this, nReadLength);
							 // rtp_depacket_input(hRtpHandle[0], data_ + 4, nRtpLength);
						}
						else if (data_[1] == 0x02)
						{
							if(nPrintCount % 100 == 0 )
							  printf("this =%X ,Audio Length = %d \r\n",this,nReadLength);
							//rtp_depacket_input(hRtpHandle[1], data_ + 4, nRtpLength);
							nPrintCount ++;
						}
					}
					else
					{
						//WriteLog(Log_Debug, "ReadDataFunc() ,在读取rtp包数据中出错 ! ABLhttpChan = %d ", ABLhttpChan);
						pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
						return -1;
					}
				}
				else
				{//http 数据
					if (!ReadhttpEnd())
					{
						printf("ReadDataFunc() ,在读取http结束数据包中出错 ! ABLhttpChan = %d ", nClient);
						pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
						return  -1;
					}
					else
					{
						//填充http头
						if (FindHttpHeadEndFlag() > 0)
							FillHttpHeadToStruct();

						if (nContentLength > 0)
						{
							nReadLength = nContentLength;
							nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
							if (nRet != 0 || nReadLength != nContentLength)
							{
								//WriteLog(Log_Debug, "ReadDataFunc() ,在读取http交互数据中出错 ! ABLhttpChan = %d ", ABLhttpChan);
								pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
								return -1;
							}
							else
							{
								data_Length += nContentLength;
							}
						}

						data_[data_Length] = 0x00;
						InputhttpData(data_, data_Length);
					}
				}
			}
			else
			{
				//WriteLog(Log_Debug, "CABLhttpClient= %X  , ReadDataFunc() ,在读取包头数据中出错 ! , ABLhttpChan = %d ,dwClient= %d", this, ABLhttpChan, dwClient);
				pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
				return -1;
			}
		}

		return 0;
	}

ABLMediaServer-2021-04-05 【FLV视频流畅、http-flv 不断线，视频帧速度准确计算  】
1 帧速度误差有5帧时，才修正视频帧速度，否则会操作VLC播放声音丢失 
	if (abs(TempVideoFrameSpeed - VideoFrameSpeed) >= 5)
	{//帧速度误差有5帧时，才修正视频帧速度，否则会操作VLC播放声音丢失 
		VideoFrameSpeed = TempVideoFrameSpeed;
		printf("CNetRevcBase= %X,视频帧速度有变化，前后速度误差超过5帧，需要修正视频帧速度 nClient = %llu,TempVideoFrameSpeed = %d,  VideoFrameSpeed = %d \r\n", this, nClient, TempVideoFrameSpeed,VideoFrameSpeed);
	}

2  优化 RTMP、FLV 的音频打包中的时间戳增量
    FLV 增量 
		void  CNetServerHTTP_FLV::MuxerAudioFlV(char* codeName, unsigned char* pAudio, int nLength)
		{
			//if (dwAudioFirstTime == 0)
			//	dwAudioFirstTime = ::GetTickCount();
			//flvAACDts = ::GetTickCount() - dwAudioFirstTime;

			if (strcmp(codeName, "AAC") == 0)
			{
				if (flvMuxer)
					flv_muxer_aac(flvMuxer, pAudio, nLength, flvAACDts, flvAACDts);

				if(mediaCodecInfo.nSampleRate == 16000)
				  flvAACDts += 64;
				else if(mediaCodecInfo.nSampleRate == 8000)
				  flvAACDts += 128;

				//AAC 的时间增量计算 ，以海康的16K采样为例，AAC每1024字节编码一次，那么(1024 / 16000 * 2) * 1000 = 32 毫秒 ，但是海康往往2帧发送一次 ，那么两帧递增 32 * 2 = 64 毫秒 ，64 就是海康摄像头 DTS ,PTS 的增量 
				// 以大华的8K采样为例，AAC每1024字节编码一次，那么(1024 / 8000 * 2) * 1000 = 64 毫秒 ，但是大华往往2帧发送一次 ，那么两帧递增 64 * 2 = 128 毫秒 ，128 就是大华摄像头 DTS ,PTS 的增量 
			}
		}
		
   RTMP 的时间戳增量 
	int CNetRtmpServerRecv::SendAudio()
	{
		if (nWriteErrorCount >= 30)
		{
			DeleteNetRevcBaseClient(nClient);
			return -1;
		}
	 
		unsigned char* pData = NULL;
		int            nLength = 0;
		if ((pData = m_audioFifo.pop(&nLength)) != NULL)
		{
			if (flvMuxer)
			  flv_muxer_aac(flvMuxer, pData, nLength , nAudioDTS, nAudioDTS);

			if (mediaCodecInfo.nSampleRate == 16000)
				nAudioDTS += 64;
			else if (mediaCodecInfo.nSampleRate == 8000)
				nAudioDTS += 128;

			m_audioFifo.pop_front();
		}

		if (nWriteErrorCount >= 30)
			DeleteNetRevcBaseClient(nClient);

		return 0;
	}

3 如果从发送线程移除，即要把该链接准备销毁
	//把客户端从线程池移除 
	bool  CMediaSendThreadPool::DeleteClientToThreadPool(uint64_t nClient)
	{
		std::lock_guard<std::mutex> lock(threadLock);

		for (int i = 0; i < nTrueMaxNetThreadPoolCount; i++)
		{
			for (int j = 0; j < threadContainClient[i].nTrueClientsCount; j++)
			{
				if (threadContainClient[i].nClients[j] == nClient)
				{
					threadContainClient[i].nClients[j] = 0;
					threadContainClient[i].nTrueClientsCount -= 1;

					if (threadContainClient[i].nTrueClientsCount < 0) //保护，防止意外 
						threadContainClient[i].nTrueClientsCount = 0;

					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));  //准备销毁该链接 
					printf("把客户端 nClient = %llu 从媒体发送线程池移除 \r\n", nClient);

					return true;
				}
			}
		}
		return false;
	}

4 如果从拷贝线程移除，也准备把该链接进行销毁  			
	bool CMediaStreamSource::DeleteClientFromMap(NETHANDLE nClient)
	{
		std::lock_guard<std::mutex> lock(mediaSendMapLock);

		MediaSendMap::iterator it;
		it = mediaSendMap.find(nClient);
		if (it != mediaSendMap.end())
		{
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));  //准备把该链接进行销毁 
			
			mediaSendMap.erase(it);

			printf("把一个客户端 %llu 从媒体资源拷贝线程移除 \r\n", nClient);
			return true;
		}else
		   return false ;
	}
		
//处理网络数据
int CNethttpServer::ProcessNetData()
{
	while (netDataCacheLength > 4)
	{
	    uint32_t nReadLength = 4;
		data_Length = 0;

		int nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
		if (nRet == 0 && nReadLength == 4)
		{
			//nhttpPacketCount = 0;//接收到数据，超时清0 

			data_Length = 4;

			if (data_[0] == '$')
			{//rtp 数据
				memcpy((char*)&nRtpLength, data_ + 2, 2);
				nRtpLength = nReadLength = ntohs(nRtpLength);

				nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
				if (nRet == 0 && nReadLength == nRtpLength)
				{
					if (data_[1] == 0x00)
					{
						//if(nPrintCount % 200 == 0)
 						//  printf("this =%X, Video Length = %d \r\n",this, nReadLength);
 						 // rtp_depacket_input(hRtpHandle[0], data_ + 4, nRtpLength);
					}
					else if (data_[1] == 0x02)
					{
						if(nPrintCount % 100 == 0 )
						  printf("this =%X ,Audio Length = %d \r\n",this,nReadLength);
						//rtp_depacket_input(hRtpHandle[1], data_ + 4, nRtpLength);
						nPrintCount ++;
					}
				}
				else
				{
					//WriteLog(Log_Debug, "ReadDataFunc() ,在读取rtp包数据中出错 ! ABLhttpChan = %d ", ABLhttpChan);
					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
					return -1;
				}
			}
			else
			{//http 数据
				if (!ReadhttpEnd())
				{
					printf("ReadDataFunc() ,在读取http结束数据包中出错 ! ABLhttpChan = %d ", nClient);
					pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
					return  -1;
				}
				else
				{
					//填充http头
					if (FindHttpHeadEndFlag() > 0)
						FillHttpHeadToStruct();

					if (nContentLength > 0)
					{
						nReadLength = nContentLength;
						nRet = XHNetSDKRead(nClient, data_ + data_Length, &nReadLength, true, true);
						if (nRet != 0 || nReadLength != nContentLength)
						{
							//WriteLog(Log_Debug, "ReadDataFunc() ,在读取http交互数据中出错 ! ABLhttpChan = %d ", ABLhttpChan);
							pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
							return -1;
						}
						else
						{
							data_Length += nContentLength;
						}
					}

					data_[data_Length] = 0x00;
					InputhttpData(data_, data_Length);
				}
			}
		}
		else
		{
			//WriteLog(Log_Debug, "CABLhttpClient= %X  , ReadDataFunc() ,在读取包头数据中出错 ! , ABLhttpChan = %d ,dwClient= %d", this, ABLhttpChan, dwClient);
			pDisconnectBaseNetFifo.push((unsigned char*)&nClient, sizeof(nClient));
			return -1;
		}
	}

	return 0;
}		
ABLMediaServer-2021-04-04 【FLV视频流畅、http-flv 不断线，视频帧速度尚未计算  】
1 在网络基类增加计算帧速度 
	void CNetRevcBase::CalcVideoFrameSpeed()
	{
		nPushVideoFrameCount++;//单位时间内加入视频帧总数 
		if (abs(nCalcFrameSpeedStartTime - 0) < 0.001)
			nCalcFrameSpeedStartTime = ::GetTickCount();//计算帧速度开始时间
		
		//够5秒 ，计算视频帧速度 												
		if (nPushVideoFrameCount >= 25 * 5)
		{
			nCalcFrameSpeedEndTime = ::GetTickCount();  //计算帧速度结束时间
			VideoFrameSpeed = (nPushVideoFrameCount / (nCalcFrameSpeedEndTime - nCalcFrameSpeedStartTime)) * 1000.00;

			printf("CNetRevcBase= %X, nClient = %llu, VideoFrameSpeed = %d \r\n", this, nClient, VideoFrameSpeed);

			nPushVideoFrameCount = 0;
			nCalcFrameSpeedStartTime = 0;
		}
	}


ABLMediaServer-2021-04-04 【FLV视频流畅、http-flv 不断线，视频帧速度尚未计算  】
1  优化线程发送函数
	while (bRunFlag)
	{
		if (threadContainClient[nCurrentThreadID].nTrueClientsCount > 0)
		{
			for (i = 0; i < threadContainClient[nCurrentThreadID].nTrueClientsCount; i++)
			{
				if (threadContainClient[nCurrentThreadID].nClients[i] > 0)
				{
		           boost::shared_ptr<CNetRevcBase> pClient= GetNetRevcBaseClient(threadContainClient[nCurrentThreadID].nClients[i]);
				   if (pClient)
				   {
					   nVideoFrameCount = pClient->m_videoFifo.GetSize();
					   nAudioFrameCount = pClient->m_audioFifo.GetSize();
					   if (nVideoFrameCount == 0 && nAudioFrameCount == 0)
					   {
						  if(threadContainClient[nCurrentThreadID].nTrueClientsCount == 1 )
						  {//如果该线程只有1个连接，可以等待5毫秒
						    Sleep(5);
						    continue;
						  }
						  else //如果该线程超过2个连接，本次循环不能等待时间 ，因为还需要发送下一个链接的数据 
						    continue ;  
					   }
  
					   for (i = 0; i < nVideoFrameCount;i++)
						   pClient->SendVideo();

					   for (i = 0; i < nAudioFrameCount;i++)
						   pClient->SendAudio();
 				   }
				}
 		    }
 		}else 
 		  Sleep(5);
 	}

2  视频帧速度暂时固定为25帧，这样解决断线问题，解决声音播放丢失问题 
  VideoFrameSpeed = 25;//暂时固定为25帧 

3 视频，音频增加格式
    virtual int PushVideo(uint8_t* pVideoData, uint32_t nDataLength,char* szVideoCodec) = 0;//塞入视频数据
    virtual int PushAudio(uint8_t* pVideoData, uint32_t nDataLength,char* szAudioCodec,int nChannels,int SampleRate) = 0;//塞入音频数据
   
	int CNetServerHTTP_FLV::PushVideo(uint8_t* pVideoData, uint32_t nDataLength, char* szVideoCodec)
	{
		if (strlen(mediaCodecInfo.szVideoName) == 0)
			strcpy(mediaCodecInfo.szVideoName, szVideoCodec);

		m_videoFifo.push(pVideoData, nDataLength);
		return 0 ;
	}

	int CNetServerHTTP_FLV::PushAudio(uint8_t* pAudioData, uint32_t nDataLength, char* szAudioCodec, int nChannels, int SampleRate)
	{
		if (strlen(mediaCodecInfo.szAudioName) == 0)
		{
			strcpy(mediaCodecInfo.szAudioName, szAudioCodec);
			mediaCodecInfo.nChannels = nChannels;
			mediaCodecInfo.nSampleRate = SampleRate;
		}
		m_audioFifo.push(pAudioData, nDataLength);
		return 0;
	}

4  计算音频AAC的格式，比如通道数，采样频率 
	if (strlen(pClient->pMediaSource->m_mediaCodecInfo.szAudioName) == 0 && bytes > 4 && data != NULL )
	{
		unsigned char* pAudioData = (unsigned char*)data;
		strcpy(pClient->pMediaSource->m_mediaCodecInfo.szAudioName, "AAC");

		//采样频率序号只占4位，  8 7 6 5 4 3 2 1  在 6 ~ 3 位，共4个位。所以要和0x3c 与运算，把别的位全部置为0 ，再往右移动2位，
		unsigned char nSampleIndex = ((pAudioData[2] & 0x3c) >> 2) & 0x0F;  //从 pb[2] 中获取采样频率的序号
		if (nSampleIndex <= 12)
			pClient->pMediaSource->m_mediaCodecInfo.nSampleRate = SampleRateArray[nSampleIndex];

		//通道数量计算 pAVData[2]  中有2个位，在最后2位，根 0x03 与运算，得到两位，左移动2位 ，再 或 上 pAVData[3] 的左边最高2位
		//pAVData[3] 左边最高2位获取方法 先 和 0xc0 与运算，再右移6位，为什么要右移6位？因为这2位是在最高位，所以要往右边移动6位
		pClient->pMediaSource->m_mediaCodecInfo.nChannels = ((pAudioData[2] & 0x03) << 2) | ((pAudioData[3] & 0xc0) >> 6);
	}

	if (pClient->pMediaSource)
		pClient->pMediaSource->PushAudio((unsigned char*)data, bytes, pClient->pMediaSource->m_mediaCodecInfo.szAudioName, pClient->pMediaSource->m_mediaCodecInfo.nChannels, pClient->pMediaSource->m_mediaCodecInfo.nSampleRate);


ABLMediaServer-2021-04-03 【FLV视频尚未流畅、http-flv 接收会断线 】
1 优化线程发送函数 ，flv.js \ EasyPlayer.js 能播放 36分钟左右 ，声音正常。
	while (bRunFlag)
	{
		if (threadContainClient[nCurrentThreadID].nTrueClientsCount > 0)
		{
			for (i = 0; i < threadContainClient[nCurrentThreadID].nTrueClientsCount; i++)
			{
				if (threadContainClient[nCurrentThreadID].nClients[i] > 0)
				{
		           boost::shared_ptr<CNetRevcBase> pClient= GetNetRevcBaseClient(threadContainClient[nCurrentThreadID].nClients[i]);
				   if (pClient)
				   {
  					   while ((nVideoFrameCount = pClient->m_videoFifo.GetSize()) > 0)
						   pClient->SendVideo();

					   while ((nAudioFrameCount = pClient->m_audioFifo.GetSize()) > 0)
						   pClient->SendAudio();

					   if (nVideoFrameCount == 0)
						  Sleep(5);
 				   }
				}
 		    }
 		}else 
 		  Sleep(5);
 	}

2 增加一个函数，只要提供nClient ,即可从拷贝线程中移除，不需要再拷贝 
	//把客户端ID，从媒体资源移除，不再拷贝 
	bool DeleteClientMediaStreamSource(uint64_t nClient)
	{
		std::lock_guard<std::mutex> lock(ABL_CMediaStreamSourceMapLock);
		CMediaStreamSource_ptrMap::iterator iterator1;
		CMediaStreamSource_ptr   pClient = NULL;
		bool bDeleteFlag = false;

		for (iterator1 = xh_ABLMediaStreamSourceMap.begin(); iterator1 != xh_ABLMediaStreamSourceMap.end(); ++iterator1)
		{
			pClient = (*iterator1).second;
			if (pClient->DeleteClientFromMap(nClient))
			{
				bDeleteFlag = true;
				break;
			}
		}
		return bDeleteFlag;
	}

3  发送失败次数累计达到30次才关闭该链接 
	if (pClient->nWriteRet != 0)
	{
		pClient->nWriteErrorCount++;
		printf("rtmp_server_send 发送失败，次数 nWriteErrorCount = %d \r\n", pClient->nWriteErrorCount);
	}
	else
		pClient->nWriteErrorCount = 0;


ABLMediaServer-2021-04-02 【FLV视频尚未流畅、http-flv 接收会断线 】
1 增加rtmp 点播功能 
	//rtmp点播，回调 
	static int rtmp_server_onplay(void* param, const char* app, const char* stream, double start, double duration, uint8_t reset)
	{
		printf("rtmp_server_onplay(%s, %s, %f, %f, %d)\n", app, stream, start, duration, (int)reset);
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;

		char  szRtmpName[256] = { 0 };
		sprintf(szRtmpName, "/%s/%s", app, stream);
		boost::shared_ptr<CMediaStreamSource> pushClient = GetMediaStreamSource(szRtmpName);
		if (pushClient == NULL && pClient)
		{
			printf("CNetRtmpServerRecv=%X, 没有推流对象的地址 %s nClient = %llu \r\n", pClient, szRtmpName, pClient->nClient);

			if(pClient)
			  DeleteNetRevcBaseClient(pClient->nClient);

			return -1;
		}

		//把客户端加入媒体拷贝线程 
		if (pClient && pushClient)
		{
			//把客户端加入发送线程 
			pMediaSendThreadPool->AddClientToThreadPool(pClient->nClient);

			pClient->m_videoFifo.InitFifo(MaxLiveingVideoFifoBufferLength);
			pClient->m_audioFifo.InitFifo(MaxLiveingAudioFifoBufferLength);
			pushClient->AddClientToMap(pClient->nClient);
		}
		return 0;
	}
	static int rtmp_server_onpause(void* param, int pause, uint32_t ms)
	{
		printf("rtmp_server_onpause(%d, %u)\n", pause, (unsigned int)ms);
		return 0;
	}
	static int rtmp_server_onseek(void* param, uint32_t ms)
	{
		printf("rtmp_server_onseek(%u)\n", (unsigned int)ms);
		return 0;
	}
	static int rtmp_server_ongetduration(void* param, const char* app, const char* stream, double* duration)
	{
		*duration = 30 * 60;
		return 0;
	}

	//FLV 打包 
	static int NetRtmpServerRec_MuxerFlv(void* flv, int type, const void* data, size_t bytes, uint32_t timestamp)
	{
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)flv;

		int r;
		if (pClient)
		{
			if (FLV_TYPE_VIDEO == type)
			{
				r = rtmp_server_send_video(pClient->rtmp, data, bytes, timestamp);
			}
			else if (FLV_TYPE_AUDIO == type)
			{
				r = rtmp_server_send_audio(pClient->rtmp, data, bytes, timestamp);
			}
		}
		return 0;
	}
	
2 增加一些事务处理 线程函数 
	int  ABLMedisServerProcessThread(LPVOID lpVoid)
	{
		int nDeleteBreakTimer = 0;
		ABL_bExitMediaServerRunFlag = false;
		unsigned char* pData = NULL;
		int            nLength;
		uint64_t       nClient;

		while (ABL_bMediaServerRunFlag)
		{
			if (nDeleteBreakTimer >= 10)
			{
				nDeleteBreakTimer = 0;
				while ((pData = pDisconnectBaseNetFifo.pop(&nLength)) != NULL)
				{
					if (nLength <= sizeof(nClient))
					{
						memcpy((char*)&nClient, pData, sizeof(nClient));
						if (nClient > 0)
						{
							pMediaSendThreadPool->DeleteClientToThreadPool(nClient);
							DeleteNetRevcBaseClient(nClient);
						}
					}

					pDisconnectBaseNetFifo.pop_front();
				}
			}

			nDeleteBreakTimer ++;
			Sleep(100);
		}
		ABL_bExitMediaServerRunFlag = true;
		return 0;
	}

ABLMediaServer-2021-04-01 【FLV视频尚未流畅、http-flv 接收会断线 】
1 在rtmp 接收类库中，媒体数据源是本身产生、销毁的，在使用时不需要频繁去获取，在创建时记忆，回调函数中直接使用 
  析构函数中销毁 
  
	sprintf(pClient->szURL, "/%s/%s", app, stream);
	boost::shared_ptr<CMediaStreamSource> pTempSource = NULL;
	pTempSource = GetMediaStreamSource(pClient->szURL);
	if (pTempSource != NULL)
	{//推流地址已经存在 
		printf("--- 推流地址已经存在--- %s \r\n",pClient->szURL );
		DeleteNetRevcBaseClient(pClient->nClient);
		return 0;
	}
	
	//创建时，记录 
	pClient->pMediaSource =  CreateMediaStreamSource(pClient->szURL);

    //回调函数中直接使用 
	if (pClient->pMediaSource)
	    pClient->pMediaSource->PushVideo((unsigned char*)data, bytes);
	
	if (pClient->pMediaSource)
		pClient->pMediaSource->PushAudio((unsigned char*)data, bytes);

	//析构函数中销毁
  	DeleteMediaStreamSource(szURL);
  	
2  在媒体数据发送线程中，如果视频、音频帧数为0，需要Sleep ，否则占用CPU太高 
   现在改成均匀发送视频、音频数据 
   
	void CMediaSendThreadPool::ProcessFunc()
	{
		int nCurrentThreadID = nCreateThreadProcessCount;
		bExitProcessThreadFlag[nCurrentThreadID] = false;
		bCreateThreadFlag = true; //创建线程完毕
		int i;
		int nVideoFrameCount, nAudioFrameCount;
		int  VideoFrameSpeed = 25;
		int   dwSleep = 1000 / VideoFrameSpeed;

		while (bRunFlag)
		{
			if (threadContainClient[nCurrentThreadID].nTrueClientsCount > 0)
			{
				for (i = 0; i < threadContainClient[nCurrentThreadID].nTrueClientsCount; i++)
				{
					if (threadContainClient[nCurrentThreadID].nClients[i] > 0)
					{
					   boost::shared_ptr<CNetRevcBase> pClient= GetNetRevcBaseClient(threadContainClient[nCurrentThreadID].nClients[i]);
					   if (pClient)
					   {
						   nVideoFrameCount = pClient->m_videoFifo.GetSize();
						   nAudioFrameCount = pClient->m_audioFifo.GetSize();

						   if (nVideoFrameCount > 0)
							   pClient->SendVideo();
						   if (nAudioFrameCount > 0)
							   pClient->SendAudio();

						   if (nVideoFrameCount <= 1)
							   MySleep(dwSleep + 10);
						   else if (nVideoFrameCount > 1 && nVideoFrameCount <= 5)
							   MySleep(dwSleep + 5);
						   else if (nVideoFrameCount > 5 && nVideoFrameCount <= 15)
							   MySleep(dwSleep);
						   else if (nVideoFrameCount > 15 && nVideoFrameCount <= 20)
							   MySleep(dwSleep - 5);
						   else if (nVideoFrameCount > 20 && nVideoFrameCount <= 30)
							   MySleep(dwSleep - 10);
						   else if (nVideoFrameCount > 30 && nVideoFrameCount <= 40)
							   MySleep(dwSleep - 15);
						   else if (nVideoFrameCount > 40 && nVideoFrameCount <= 50)
							   MySleep(dwSleep - 30);
						   else
							   MySleep(1);
					   }
					}
				}
			}else 
			  Sleep(5);
		}
		bExitProcessThreadFlag[nCurrentThreadID] = true;
	}

		
ABLMediaServer-2021-04-01 【FLV视频尚未流畅、http-flv 接收会断线 】
1 增加查找FLV文件名字 
	int CNetServerHTTP_FLV::InputNetData(NETHANDLE nServerHandle, NETHANDLE nClientHandle, uint8_t* pData, uint32_t nDataLength)
	{
		if (MaxNetDataCacheCount - nNetEnd >= nDataLength)
		{//剩余空间足够
			memcpy(netDataCache + nNetEnd, pData, nDataLength);
			netDataCacheLength += nDataLength;
			nNetEnd += nDataLength;
		}
		else
		{//剩余空间不够，需要把剩余的buffer往前移动
			if (netDataCacheLength > 0)
			{//如果有少量剩余
				memmove(netDataCache, netDataCache + nNetStart, netDataCacheLength);
				nNetStart = 0;
				nNetEnd = netDataCacheLength;
			}
			else
			{//没有剩余，那么 首，尾指针都要复位 
				nNetStart = 0;
				nNetEnd = 0;
				netDataCacheLength = 0;
			}
			memcpy(netDataCache + nNetEnd, pData, nDataLength);
			netDataCacheLength += nDataLength;
			nNetEnd += nDataLength;
		}

		printf("InputNetData() ... \r\n");

		return true;
	}

	int CNetServerHTTP_FLV::ProcessNetData()
	{
		if (!bFindFlvNameFlag)
		{
			if (strstr((char*)netDataCache, "\r\n\r\n") == NULL)
			{
				printf("数据尚未接收完整 \r\n");
				return -1;
			}
		}

		if (!bCheckHttpFlvFlag)
		{
			bCheckHttpFlvFlag = true;

			//把请求的FLV文件读取出来　
			string  strHttpHead = (char*)netDataCache;
			int     nPos1, nPos2;
			nPos1 = strHttpHead.find("GET ", 0);
			if (nPos1 >= 0)
			{
				nPos2 = strHttpHead.find(" HTTP/", 0);
				if (nPos2 > 0)
				{
					bFindFlvNameFlag = true;
					memset(szFlvName, 0x00, sizeof(szFlvName));
					memcpy(szFlvName, netDataCache + nPos1 + 4, nPos2 - nPos1 - 4);

					printf("CNetServerHTTP_FLV=%X ,nClient = %llu ,拷贝出FLV 文件名字 %s \r\n", this, nClient, szFlvName);
				}
			}

			if (!bFindFlvNameFlag)
			{
				printf("CNetServerHTTP_FLV=%X, 检测出 非法的 Http-flv 协议数据包 nClient = %llu \r\n",this, nClient);
				DeleteNetRevcBaseClient(nClient);
				return -1;
			}
		}
	  
		return 0;
	}
	
2 增加判断FLV 文件名字是否存在，如果不存储则关闭该请求 
	//根据FLV文件，进行查找推流对象 
	if (strstr(szFlvName, ".flv") != NULL || strstr(szFlvName, ".FLV") != NULL)
		szFlvName[strlen(szFlvName) - 4] = 0x00;

	boost::shared_ptr<CMediaStreamSource> pushClient = GetMediaStreamSource(szFlvName);
	if (pushClient == NULL)
	{
		printf("CNetServerHTTP_FLV=%X, 没有推流对象的地址 %s nClient = %llu \r\n", this, szFlvName, nClient);
		DeleteNetRevcBaseClient(nClient);
		return -1;
	}
	
3 在发送网络线程池中 ，增加视频、音频发送功能
	void CMediaSendThreadPool::ProcessFunc()
	{
		int nCurrentThreadID = nCreateThreadProcessCount;
		bExitProcessThreadFlag[nCurrentThreadID] = false;
		bCreateThreadFlag = true; //创建线程完毕
		int i;

		while (bRunFlag)
		{
			if (threadContainClient[nCurrentThreadID].nTrueClientsCount > 0)
			{
				for (i = 0; i < threadContainClient[nCurrentThreadID].nTrueClientsCount; i++)
				{
					if (threadContainClient[nCurrentThreadID].nClients[i] > 0)
					{
					   boost::shared_ptr<CNetRevcBase> pClient= GetNetRevcBaseClient(threadContainClient[nCurrentThreadID].nClients[i]);
					   if (pClient)
					   {
						 pClient->SendVideo();  //发送视频 
						 pClient->SendAudio();  //发送音频
					   }
					}
				}
			}else 
			  Sleep(5);
		}
		bExitProcessThreadFlag[nCurrentThreadID] = true;
	}

4  增加FLV视频、音频打包功能
	void  CNetServerHTTP_FLV::MuxerVideoFlV(char* codeName, unsigned char* pVideo, int nLength)
	{
		//if (dwVideoFirstTime == 0)
		//	dwVideoFirstTime = ::GetTickCount();
		//flvPS = ::GetTickCount() - dwVideoFirstTime;

		if (strcmp(codeName, "H264") == 0)
		{
			if (flvMuxer)
				flv_muxer_avc(flvMuxer, pVideo, nLength, flvPS, flvPS);
		}
		else if (strcmp(codeName, "H265") == 0)
		{
			if (flvMuxer)
				flv_muxer_hevc(flvMuxer, pVideo, nLength, flvPS, flvPS);
		}

		//printf("flvPS = %d \r\n", flvPS);

		flvPS += 1000 / VideoFrameSpeed;
	}

	void  CNetServerHTTP_FLV::MuxerAudioFlV(char* codeName, unsigned char* pAudio, int nLength)
	{
		//if (dwAudioFirstTime == 0)
		//	dwAudioFirstTime = ::GetTickCount();
		//flvAACDts = ::GetTickCount() - dwAudioFirstTime;

		if (strcmp(codeName, "AAC") == 0)
		{
			if (flvMuxer)
				flv_muxer_aac(flvMuxer, pAudio, nLength, flvAACDts, flvAACDts);

			flvAACDts += 64;
			//AAC 的时间增量计算 ，以海康的16K采样为例，AAC每1024字节编码一次，那么(1024 / 16000 * 2) * 1000 = 32 毫秒 ，但是海康往往2帧发送一次 ，那么两帧递增 32 * 2 = 64 毫秒 ，64 就是海康摄像头 DTS ,PTS 的增量 
			// 以大华的8K采样为例，AAC每1024字节编码一次，那么(1024 / 8000 * 2) * 1000 = 64 毫秒 ，但是大华往往2帧发送一次 ，那么两帧递增 64 * 2 = 128 毫秒 ，128 就是大华摄像头 DTS ,PTS 的增量 
		}
	}

5 如果发送失败，立即删除该链接，不能在回调函数里面删除 
    //在回调函数里面，记下发送返回值 
    pHttpFLV->nWriteRet = XHNetSDK_Write(pHttpFLV->nClient,(unsigned char*)vec[i].ptr, vec[i].len,true);	
	
	//在发送视频函数中判断返回值，如果发送失败，立即删除 
	int CNetServerHTTP_FLV::SendVideo()
	{
		if (nWriteRet != 0)
		{
			DeleteNetRevcBaseClient(nClient);
			return -1;
		}	
	
ABLMediaServer-2021-03-31
1 增加专门发送视频的线程池 
	/*
	功能：
		自研的线程池功能，能以多个线程去执行一类实例，不同的任务
		这个线程池，当达到帧数据时会触发线程池 拷贝视频动作  	
	日期    2021-03-29
	作者    罗家兄弟
	QQ      79941308
	E-Mail  79941308@qq.com
	*/

	#include "stdafx.h"
	#include "MediaSendThreadPool.h"

	extern boost::shared_ptr<CNetRevcBase> GetNetRevcBaseClient(NETHANDLE CltHandle);

	CMediaSendThreadPool::CMediaSendThreadPool(int nMaxThreadCount)
	{
	}

2 在网络基类增加发送视频，发送音频函数 
    virtual int SendVideo() = 0;//发送视频数据
    virtual int SendAudio() = 0;//发送音频数据
	
	int CNetServerHTTP_FLV::PushAudio(uint8_t* pVideoData, uint32_t nDataLength) 
	{
		return 0;
	}

	int CNetServerHTTP_FLV::SendVideo()
	{
		return 0;
	}

	int CNetServerHTTP_FLV::SendAudio()
	{
		return 0;
	}

ABLMediaServer-2021-03-29
1 给所有类增加功能说明  
	/*
	功能：
		   实现http-flv服务器的媒体数据发送功能 
	日期    2021-03-29
	作者    罗家兄弟
	QQ      79941308
	E-Mail  79941308@qq.com
	*/
	
2 增加音视频存储类库
	#define   MediaStreamSource_VideoFifoLength   1024*1024*2  //视频存储长度
	#define   MediaStreamSource_AudioFifoLength   1024*256     //音频存储长度 

	class CMediaStreamSource
	{
	public:
	   CMediaStreamSource(char* szURL);
	   ~CMediaStreamSource();

	   bool                 PushVideo(unsigned char* szVideo, int nLength);
	   bool                 PushAudio(unsigned char* szAudio, int nLength);
	   
	   char                 m_szURL[512]; //比如  /Media/Camera_00001     /Live/Camera_00001 ,  url 建议至少有2级 
	   MediaCodecInfo       m_mediaCodecInfo;

	   CMediaFifo           m_videoFifo;
	   CMediaFifo           m_audioFifo;
	};
 	
3 把rtmp推流上来的视频、音频存储起来

	if (pMediaSource)
		pMediaSource->PushVideo((unsigned char*)data, bytes);

	if (pMediaSource)
		pMediaSource->PushAudio((unsigned char*)data, bytes);
	
ABLMediaServer-2021-03-28
1 工程刚刚建立 

2 加入rtmp流接收

3 固定某个客户端只在某一个线程进行处理，否则会出现数据处理不是线性的。
	bool CNetBaseThreadPool::InsertIntoTask(uint64_t nClientID)
	{
		std::lock_guard<std::mutex> lock(threadLock);

		int               nThreadThread = 0;
		ClientProcessThreadMap::iterator it;

		it = clientThreadMap.find(nClientID);
		if (it != clientThreadMap.end())
		{//找到 
			nThreadThread = (*it).second;
		}
		else
		{//尚未加入过
			nThreadThread = nThreadProcessCount % nTrueNetThreadPoolCount;
			clientThreadMap.insert(ClientProcessThreadMap::value_type(nClientID, nThreadThread));
			nThreadProcessCount  ++;
		}

		m_NetHandleQueue[nThreadThread].push(nClientID);

		return true;
	}

4  增加写FLV文件的调试功能

	#ifdef  WriteFlvFileByDebug
	   void*                        s_flv;
	#endif

	#ifdef  WriteFlvFileByDebug
		char  szFlvFile[256] = { 0 };
		sprintf(szFlvFile,".\\%X_%d.flv", this, rand());
		s_flv = flv_writer_create(szFlvFile);
	#endif
	
	static int rtmp_server_onvideo(void* param, const void* data, size_t bytes, uint32_t timestamp)
	{//写入视频 
	#ifdef  WriteFlvFileByDebug
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
		  flv_writer_input(pClient->s_flv, FLV_TYPE_VIDEO, data, bytes, timestamp);
	#endif
		return 0;
	}

	static int rtmp_server_onaudio(void* param, const void* data, size_t bytes, uint32_t timestamp)
	{//写入音频 
	#ifdef  WriteFlvFileByDebug
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
			flv_writer_input(pClient->s_flv, FLV_TYPE_AUDIO, data, bytes, timestamp);
	#endif
		return 0;
	}

5 简单检测包头是否合法，是否符合rtmp协议,如果非法立即销毁 	
	if (!bCheckhttpVersionFlag)
	{
		bCheckhttpVersionFlag = true;
		if (!(pData[0] == 0x03 && pData[1] == 0x00 && pData[2] == 0x00 && pData[3] == 0x00 && pData[4] == 0x00))
		{//简单检测包头是否合法，是否符合rtmp协议
			DeleteNetRevcBaseClient(nClient);
			return -1;
		}
	}
6 增加flv解包 
	static int rtmp_server_onscript(void* param, const void* script, size_t bytes, uint32_t timestamp)
	{//写入 script 内容 
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
		  flv_demuxer_input(pClient->flvDemuxer, FLV_TYPE_SCRIPT, script, bytes, timestamp);

	#ifdef  WriteFlvFileByDebug
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
		   flv_writer_input(pClient->s_flv, FLV_TYPE_SCRIPT, script, bytes, timestamp);
	#endif
		return 0;
	}

	static int rtmp_server_onvideo(void* param, const void* data, size_t bytes, uint32_t timestamp)
	{//写入视频 
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
			flv_demuxer_input(pClient->flvDemuxer, FLV_TYPE_VIDEO, data, bytes, timestamp);

	#ifdef  WriteFlvFileByDebug
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
		  flv_writer_input(pClient->s_flv, FLV_TYPE_VIDEO, data, bytes, timestamp);
	#endif
		return 0;
	}

	static int rtmp_server_onaudio(void* param, const void* data, size_t bytes, uint32_t timestamp)
	{//写入音频 
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
			flv_demuxer_input(pClient->flvDemuxer, FLV_TYPE_AUDIO, data, bytes, timestamp);

	#ifdef  WriteFlvFileByDebug
		CNetRtmpServerRecv* pClient = (CNetRtmpServerRecv*)param;
		if (pClient != NULL)
			flv_writer_input(pClient->s_flv, FLV_TYPE_AUDIO, data, bytes, timestamp);
	#endif
		return 0;
	}


	
	